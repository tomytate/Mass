----- C:\Users\Administrator\Desktop\Mass\src\Mass.CLI\Commands\BurnCommand.cs -----
using System.CommandLine;
using Spectre.Console;

namespace Mass.CLI.Commands;

public class BurnCommand : Command
{
    public BurnCommand() : base("burn", "Burn an ISO image to a USB drive")
    {
        var isoOption = new Option<string>(
            aliases: new[] { "--iso", "-i" },
            description: "Path to the ISO image file")
        {
            IsRequired = true
        };

        var driveOption = new Option<string>(
            aliases: new[] { "--drive", "-d" },
            description: "Target USB drive letter (e.g., E:)")
        {
            IsRequired = true
        };

        var fsOption = new Option<string>(
            aliases: new[] { "--filesystem", "-fs" },
            description: "Target filesystem",
            getDefaultValue: () => "FAT32");

        var schemeOption = new Option<string>(
            aliases: new[] { "--partition", "-p" },
            description: "Partition scheme",
            getDefaultValue: () => "GPT");

        AddOption(isoOption);
        AddOption(driveOption);
        AddOption(fsOption);
        AddOption(schemeOption);

        this.SetHandler(async (iso, drive, fs, scheme) =>
        {
            await BurnIso(iso, drive, fs, scheme);
        }, isoOption, driveOption, fsOption, schemeOption);
    }

    private async Task BurnIso(string isoPath, string driveLetter, string filesystem, string scheme)
    {
        if (!File.Exists(isoPath))
        {
            AnsiConsole.MarkupLine($"[red]Error: ISO file not found: {isoPath}[/]");
            return;
        }

        AnsiConsole.MarkupLine($"[bold]Burning ISO:[/] {isoPath}");
        AnsiConsole.MarkupLine($"[bold]Target Drive:[/] {driveLetter}");
        AnsiConsole.MarkupLine($"[bold]Filesystem:[/] {filesystem}");
        AnsiConsole.MarkupLine($"[bold]Scheme:[/] {scheme}");
        AnsiConsole.WriteLine();

        await AnsiConsole.Progress()
            .StartAsync(async ctx => 
            {
                var task = ctx.AddTask("[green]Burning ISO...[/]");
                
                try 
                {
                    for (int i = 0; i <= 100; i += 10)
                    {
                        task.Value = i;
                        await Task.Delay(100);
                    }
                    
                    task.StopTask();
                    AnsiConsole.MarkupLine("[yellow]Note: Full USB burning implementation requires running the GUI application.[/]");
                }
                catch (Exception ex)
                {
                    AnsiConsole.MarkupLine($"[red]Error: {ex.Message}[/]");
                }
            });

        AnsiConsole.MarkupLine("[bold green]Command completed![/]");
    }
}



----- C:\Users\Administrator\Desktop\Mass\src\Mass.CLI\Commands\ConfigCommand.cs -----
using System.CommandLine;
using Mass.Core;
using Mass.Core.Configuration;
using Spectre.Console;

namespace Mass.CLI.Commands;

public class ConfigCommand : Command
{
    private readonly IConfigurationManager _configManager;

    public ConfigCommand() : base("config", "Manage application configuration")
    {
        // In a real DI scenario, this would be injected.
        // For CLI, we initialize it here or pass it in.
        _configManager = new ConfigurationManager(Constants.ConfigPath);
        
        AddCommand(CreateListCommand());
        AddCommand(CreateGetCommand());
        AddCommand(CreateSetCommand());
    }

    private Command CreateListCommand()
    {
        var command = new Command("list", "List all configuration values");
        command.SetHandler(async () => await ListConfig());
        return command;
    }

    private Command CreateGetCommand()
    {
        var command = new Command("get", "Get a configuration value");
        var keyArgument = new Argument<string>("key", "Configuration key (e.g. App.Theme)");
        command.AddArgument(keyArgument);
        command.SetHandler(GetConfig, keyArgument);
        return command;
    }

    private Command CreateSetCommand()
    {
        var command = new Command("set", "Set a configuration value");
        var keyArgument = new Argument<string>("key", "Configuration key (e.g. App.Theme)");
        var valueArgument = new Argument<string>("value", "Configuration value");
        command.AddArgument(keyArgument);
        command.AddArgument(valueArgument);
        command.SetHandler(SetConfig, keyArgument, valueArgument);
        return command;
    }

    private async Task ListConfig()
    {
        await _configManager.LoadAsync();
        var config = _configManager.Current;

        var table = new Table();
        table.AddColumn("Section");
        table.AddColumn("Key");
        table.AddColumn("Value");

        // App Settings
        table.AddRow("App", "Theme", config.App.Theme);
        table.AddRow("App", "Language", config.App.Language);
        
        // PXE Settings
        table.AddRow("Pxe", "RootPath", config.Pxe.RootPath);
        table.AddRow("Pxe", "EnableDhcp", config.Pxe.EnableDhcp.ToString());

        // USB Settings
        table.AddRow("Usb", "VerifyAfterBurn", config.Usb.VerifyAfterBurn.ToString());
        
        AnsiConsole.Write(table);
    }

    private async Task GetConfig(string key)
    {
        await _configManager.LoadAsync();
        // Simple reflection or property traversal could go here.
        // For now, just printing that we need to implement the traversal logic.
        AnsiConsole.MarkupLine($"[yellow]Get logic for '{key}' not fully implemented in this refactor step yet.[/]");
    }

    private async Task SetConfig(string key, string value)
    {
        await _configManager.LoadAsync();
        
        // Update logic would go here.
        // For now, just acknowledging.
        
        AnsiConsole.MarkupLine($"[green]Configuration updated (simulation):[/]");
        AnsiConsole.MarkupLine($"[bold]{key}[/] = [blue]{value}[/]");
        
        // await _configManager.SaveAsync();
    }
}



----- C:\Users\Administrator\Desktop\Mass\src\Mass.CLI\Commands\WorkflowCommand.cs -----
using System.CommandLine;
using Spectre.Console;
using Mass.Core.Workflows;

namespace Mass.CLI.Commands;

public class WorkflowCommand : Command
{
    public WorkflowCommand() : base("workflow", "Manage and execute workflows")
    {
        AddCommand(CreateRunCommand());
        AddCommand(CreateListCommand());
        AddCommand(CreateValidateCommand());
        AddCommand(CreateTemplateCommand());
    }

    private Command CreateRunCommand()
    {
        var command = new Command("run", "Execute a workflow file");
        
        var fileOption = new Option<string>(
            aliases: new[] { "--file", "-f" },
            description: "Path to the workflow file (.yaml, .yml, .json)")
        {
            IsRequired = true
        };

        command.AddOption(fileOption);

        command.SetHandler(async (filePath) =>
        {
            await ExecuteWorkflow(filePath);
        }, fileOption);

        return command;
    }

    private Command CreateListCommand()
    {
        var command = new Command("list", "List available workflows");
        
        command.SetHandler(() =>
        {
            ListWorkflows();
        });

        return command;
    }

    private async Task ExecuteWorkflow(string filePath)
    {
        if (!File.Exists(filePath))
        {
            AnsiConsole.MarkupLine($"[red]Error: Workflow file not found: {filePath}[/]");
            return;
        }

        try
        {
            var parser = new WorkflowParser();
            var workflow = parser.ParseFromFile(filePath);
            var executor = new WorkflowExecutor();

            AnsiConsole.MarkupLine($"[bold green]Starting workflow: {workflow.Name}[/]");
            if (!string.IsNullOrEmpty(workflow.Description))
            {
                AnsiConsole.MarkupLine($"[dim]{workflow.Description}[/]");
            }
            AnsiConsole.WriteLine();

            await AnsiConsole.Status()
                .Spinner(Spinner.Known.Dots)
                .StartAsync("Executing workflow...", async ctx =>
                {
                    var result = await executor.ExecuteAsync(workflow);

                    if (result.Success)
                    {
                        AnsiConsole.MarkupLine($"[bold green]Workflow completed successfully![/]");
                    }
                    else
                    {
                        AnsiConsole.MarkupLine($"[bold red]Workflow failed: {result.Message}[/]");
                    }

                    if (result.Context != null && result.Context.Logs.Any())
                    {
                        AnsiConsole.WriteLine();
                        AnsiConsole.Write(new Rule("[yellow]Execution Log[/]"));
                        foreach (var log in result.Context.Logs)
                        {
                            AnsiConsole.MarkupLine($"[dim]{log}[/]");
                        }
                    }
                });
        }
        catch (Exception ex)
        {
            AnsiConsole.WriteException(ex);
        }
    }

    private void ListWorkflows()
    {
        var workflowDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite", "workflows");
        
        if (!Directory.Exists(workflowDir))
        {
            AnsiConsole.MarkupLine($"[yellow]No workflows directory found at {workflowDir}[/]");
            return;
        }

        var files = Directory.GetFiles(workflowDir, "*.yaml")
            .Concat(Directory.GetFiles(workflowDir, "*.yml"))
            .Concat(Directory.GetFiles(workflowDir, "*.json"));

        var table = new Table();
        table.AddColumn("Name");
        table.AddColumn("Version");
        table.AddColumn("Steps");
        table.AddColumn("File");

        var parser = new WorkflowParser();

        foreach (var file in files)
        {
            try
            {
                var workflow = parser.ParseFromFile(file);
                table.AddRow(
                    workflow.Name, 
                    workflow.Version, 
                    workflow.Steps.Count.ToString(), 
                    Path.GetFileName(file));
            }
            catch
            {
                table.AddRow(
                    $"[red]Invalid: {Path.GetFileName(file)}[/]", 
                    "-", 
                    "-", 
                    Path.GetFileName(file));
            }
        }

        AnsiConsole.Write(table);
    }

    private Command CreateValidateCommand()
    {
        var command = new Command("validate", "Validate a workflow file");
        
        var fileArgument = new Argument<string>("file", "Path to the workflow file to validate");
        command.AddArgument(fileArgument);

        command.SetHandler(async (filePath) =>
        {
            await ValidateWorkflow(filePath);
        }, fileArgument);

        return command;
    }

    private Command CreateTemplateCommand()
    {
        var command = new Command("template", "Manage workflow templates");
        
        var listCmd = new Command("list", "List available workflow templates");
        listCmd.SetHandler(ListTemplates);
        
        var createCmd = new Command("create", "Create workflow from template");
        var templateArg = new Argument<string>("template", "Template name (e.g., burn-iso)");
        var outputOpt = new Option<string>(
            aliases: ["--output", "-o"],
            description: "Output file path",
            getDefaultValue: () => "workflow.yaml");
        createCmd.AddArgument(templateArg);
        createCmd.AddOption(outputOpt);
        createCmd.SetHandler(CreateFromTemplate, templateArg, outputOpt);
        
        command.AddCommand(listCmd);
        command.AddCommand(createCmd);
        
        return command;
    }

    private async Task ValidateWorkflow(string filePath)
    {
        if (!File.Exists(filePath))
        {
            AnsiConsole.MarkupLine($"[red]Error: Workflow file not found: {filePath}[/]");
            return;
        }

        try
        {
            var workflowsPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite", "workflows");
            var engine = new WorkflowEngine(workflowsPath);
            
            var parser = new WorkflowParser();
            var workflow = parser.ParseFromFile(filePath);
            
            var validation = await engine.ValidateWorkflowAsync(workflow.Id);
            
            if (validation.IsValid)
            {
                AnsiConsole.MarkupLine($"[green]✓ Workflow is valid![/]");
                AnsiConsole.MarkupLine($"[dim]Name:[/] {workflow.Name}");
                AnsiConsole.MarkupLine($"[dim]Steps:[/] {workflow.Steps.Count}");
            }
            else
            {
                AnsiConsole.MarkupLine($"[red]✗ Workflow validation failed:[/]");
                foreach (var error in validation.Errors)
                {
                    AnsiConsole.MarkupLine($"  [red]• {error}[/]");
                }
            }
        }
        catch (Exception ex)
        {
            AnsiConsole.WriteException(ex);
        }
    }

    private void ListTemplates()
    {
        var templatesDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite", "workflows", "templates");
        
        if (!Directory.Exists(templatesDir))
        {
            AnsiConsole.MarkupLine("[yellow]No templates directory found.[/]");
            return;
        }

        var templates = Directory.GetFiles(templatesDir, "*.yaml")
            .Concat(Directory.GetFiles(templatesDir, "*.yml"));

        if (!templates.Any())
        {
            AnsiConsole.MarkupLine("[yellow]No templates found.[/]");
            return;
        }

        var table = new Table();
        table.AddColumn("Template");
        table.AddColumn("Description");
        table.AddColumn("File");

        var parser = new WorkflowParser();
        foreach (var file in templates)
        {
            try
            {
                var workflow = parser.ParseFromFile(file);
                table.AddRow(
                    workflow.Name,
                    workflow.Description,
                    Path.GetFileName(file));
            }
            catch
            {
                table.AddRow(
                    $"[red]{Path.GetFileName(file)}[/]",
                    "[red]Invalid[/]",
                    Path.GetFileName(file));
            }
        }

        AnsiConsole.Write(table);
    }

    private void CreateFromTemplate(string templateName, string outputPath)
    {
        var templatesDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite", "workflows", "templates");
        var templatePath = Path.Combine(templatesDir, $"{templateName}.yaml");

        if (!File.Exists(templatePath))
        {
            // Try .yml extension
            templatePath = Path.Combine(templatesDir, $"{templateName}.yml");
            if (!File.Exists(templatePath))
            {
                AnsiConsole.MarkupLine($"[red]Error: Template '{templateName}' not found.[/]");
                return;
            }
        }

        try
        {
            File.Copy(templatePath, outputPath, overwrite: false);
            AnsiConsole.MarkupLine($"[green]✓ Created workflow from template: {outputPath}[/]");
            AnsiConsole.MarkupLine($"[dim]Edit the file to customize parameters before running.[/]");
        }
        catch (IOException)
        {
            AnsiConsole.MarkupLine($"[red]Error: File '{outputPath}' already exists.[/]");
        }
        catch (Exception ex)
        {
            AnsiConsole.WriteException(ex);
        }
    }
}



----- C:\Users\Administrator\Desktop\Mass\src\Mass.CLI\Mass.CLI.csproj -----
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\Mass.Core\Mass.Core.csproj" />
    <ProjectReference Include="..\ProUSB\ProUSB.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Spectre.Console" Version="0.54.0" />
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
  </ItemGroup>

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>14</LangVersion>
    <Version>1.0.1</Version>
    <Authors>Tomy Tolledo</Authors>
    <Company>Tomy Tolledo</Company>
    <Product>Mass CLI</Product>
  </PropertyGroup>

</Project>



----- C:\Users\Administrator\Desktop\Mass\src\Mass.CLI\Program.cs -----
using System.CommandLine;
using Mass.CLI.Commands;
using Spectre.Console;

var rootCommand = new RootCommand("Mass Suite CLI - Professional Deployment & Media Creation Tool");

rootCommand.AddCommand(new BurnCommand());
rootCommand.AddCommand(new WorkflowCommand());
rootCommand.AddCommand(new ConfigCommand());

// Add version info
AnsiConsole.Write(
    new FigletText("Mass Suite")
        .Color(Color.Blue));

return await rootCommand.InvokeAsync(args);



