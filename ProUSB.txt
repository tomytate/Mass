================================================================================
PROUSB SOURCE CODE DOCUMENTATION
================================================================================
Created: 2025-12-01
Purpose: Complete source code documentation for ProUSB project
================================================================================

PROJECT: ProUSB
DESCRIPTION: Advanced bootable USB creation tool with modern UI
TECHNOLOGY: .NET 10.0, Avalonia UI, MVVM
================================================================================

======================================
FILE: Domain\Services\IsoPatcher.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Services.Logging;

namespace ProUSB.Domain.Services;

public class IsoPatcher {
    private readonly FileLogger _log;

    private static readonly HashSet<string> SyslinuxCfgs = new(StringComparer.OrdinalIgnoreCase) {
        "isolinux.cfg", "syslinux.cfg", "extlinux.conf", "txt.cfg", "live.cfg"
    };
    
    private static readonly HashSet<string> GrubCfgs = new(StringComparer.OrdinalIgnoreCase) {
        "grub.cfg", "loopback.cfg"
    };

    private const string MenuCfg = "menu.cfg";

    public IsoPatcher(FileLogger log) {
        _log = log;
    }

    public async Task PatchAsync(string driveLetter, CancellationToken ct) {
        _log.Info("=== LINUX ISO PATCHING START ===");
        
        var configFiles = new List<string>();
        FindConfigFiles(driveLetter, configFiles);

        if (configFiles.Count == 0) {
            _log.Info("No Linux bootloader config files found to patch.");
            return;
        }

        _log.Info($"Found {configFiles.Count} config files to potential patch.");

        foreach (var file in configFiles) {
            ct.ThrowIfCancellationRequested();
            await PatchConfigFileAsync(file, ct);
        }
        
        _log.Info("=== LINUX ISO PATCHING COMPLETE ===");
    }

    private void FindConfigFiles(string rootPath, List<string> results) {
        try {
            foreach (var file in Directory.GetFiles(rootPath)) {
                var name = Path.GetFileName(file);
                if (IsConfigFile(name)) {
                    results.Add(file);
                }
            }

            foreach (var dir in Directory.GetDirectories(rootPath)) {
                var dirName = Path.GetFileName(dir);

                if (dirName.Equals("System Volume Information", StringComparison.OrdinalIgnoreCase) ||
                    dirName.Equals("$RECYCLE.BIN", StringComparison.OrdinalIgnoreCase)) {
                    continue;
                }
                FindConfigFiles(dir, results);
            }
        } catch (Exception ex) {
            _log.Warn($"Error scanning directory {rootPath}: {ex.Message}");
        }
    }

    private bool IsConfigFile(string filename) {
        return SyslinuxCfgs.Contains(filename) || 
               GrubCfgs.Contains(filename) || 
               filename.Equals(MenuCfg, StringComparison.OrdinalIgnoreCase) ||
               (filename.EndsWith(".conf", StringComparison.OrdinalIgnoreCase) && filename.Length > 5); 
    }

    private async Task PatchConfigFileAsync(string filePath, CancellationToken ct) {
        try {
            string content = await File.ReadAllTextAsync(filePath, ct);
            string originalContent = content;
            bool modified = false;
            string filename = Path.GetFileName(filePath);
            
            bool isGrub = GrubCfgs.Contains(filename);
            bool isSyslinux = SyslinuxCfgs.Contains(filename);
            bool isMenu = filename.Equals(MenuCfg, StringComparison.OrdinalIgnoreCase);

            if (isGrub || isMenu || isSyslinux) {

                if (Regex.IsMatch(content, @"file=/cdrom/preseed")) {
                     content = Regex.Replace(content, @"(file=/cdrom/preseed)", "persistent $1");
                     if (content != originalContent) {
                         _log.Info($"Patched {filename}: Added 'persistent' (preseed match)");
                         modified = true;
                     }

                     if (isGrub && content.Contains("maybe-ubiquity")) {
                         content = content.Replace("maybe-ubiquity", "");
                         _log.Info($"Patched {filename}: Removed 'maybe-ubiquity'");
                         modified = true;
                     }
                }

                else if (content.Contains("boot=casper")) {
                    if (!content.Contains("boot=casper persistent")) {
                        content = content.Replace("boot=casper", "boot=casper persistent");
                        _log.Info($"Patched {filename}: Added 'persistent' (boot=casper match)");
                        modified = true;
                    }
                }

                else if (content.Contains("/casper/vmlinuz")) {
                    if (!content.Contains("/casper/vmlinuz persistent")) {
                        content = content.Replace("/casper/vmlinuz", "/casper/vmlinuz persistent");
                        _log.Info($"Patched {filename}: Added 'persistent' (vmlinuz match)");
                        modified = true;
                    }
                }

                else if (content.Contains("boot=live")) {
                    if (!content.Contains("boot=live persistence")) {
                        content = content.Replace("boot=live", "boot=live persistence");
                        _log.Info($"Patched {filename}: Added 'persistence' (boot=live match)");
                        modified = true;
                    }
                }
            }

            if (content.Contains("inst.stage2=") && !filePath.Contains("netinst", StringComparison.OrdinalIgnoreCase)) {
                 content = content.Replace("inst.stage2=", "inst.repo=");
                 _log.Info($"Patched {filename}: Replaced inst.stage2= with inst.repo=");
                 modified = true;
            }

            if (modified) {

                var attr = File.GetAttributes(filePath);
                if ((attr & FileAttributes.ReadOnly) == FileAttributes.ReadOnly) {
                    File.SetAttributes(filePath, attr & ~FileAttributes.ReadOnly);
                }
                
                // Atomic write: Write to temp file, then move/replace
                string tempFile = filePath + ".tmp";
                await File.WriteAllTextAsync(tempFile, content, ct);
                
                try {
                    File.Move(tempFile, filePath, overwrite: true);
                    _log.Info($"Saved patched config file (atomic): {filePath}");
                } catch (Exception ex) {
                    _log.Error($"Atomic move failed for {filePath}: {ex.Message}");
                    // Fallback to direct write if move fails (unlikely but safe)
                    await File.WriteAllTextAsync(filePath, content, ct);
                    File.Delete(tempFile);
                }
            }

        } catch (Exception ex) {
            _log.Warn($"Failed to patch {filePath}: {ex.Message}");
        }
    }
}



======================================
FILE: Domain\BootEnums.cs
======================================

namespace ProUSB.Domain;

public enum BootMode {
    Unknown,
    Legacy,
    UEFI,
    Hybrid
}

public enum BootloaderType {
    None,
    Unknown,
    WindowsBoot,
    GRUB,
    Syslinux,
    UEFIGeneric
}




======================================
FILE: Domain\BootVerificationResult.cs
======================================

using System;
using System.Collections.Generic;
using System.Linq;

namespace ProUSB.Domain;

public record BootVerificationResult {
    private string _deviceName = "Unknown";
    public required string DeviceName {
        get => _deviceName;
        init => _deviceName = value ?? "Unknown";
    }
    
    private string _deviceId = "";
    public required string DeviceId {
        get => _deviceId;
        init => _deviceId = value ?? "";
    }
    
    public bool IsBootable { get; set; }
    public BootMode BootMode { get; set; }
    public bool HasValidMBRSignature { get; set; }
    public bool HasActivePartition { get; set; }
    public bool IsGPT { get; set; }
    public bool HasESP { get; set; }
    public BootloaderType DetectedBootloader { get; set; }
    
    public List<string> Warnings { get; init; } = new();
    public List<string> Details { get; init; } = new();
    
    public string GetSummary() {
        var bootable = IsBootable ? "✅ Bootable" : "❌ Not Bootable";
        var mode = BootMode != BootMode.Unknown ? $"({BootMode})" : "";
        var loader = DetectedBootloader != BootloaderType.None 
            ? $" - {DetectedBootloader}" 
            : "";
        
        return $"{bootable} {mode}{loader}".Trim();
    }
}




======================================
FILE: Domain\BurnProfile.cs
======================================

using System;

namespace ProUSB.Domain;

public record BurnProfile {
    private string _name = "";
    public required string Name {
        get => _name;
        init {
            if(string.IsNullOrWhiteSpace(value)) {
                throw new ArgumentException("Profile name cannot be empty");
            }
            _name = value;
        }
    }
    
    public string Description { get; init; } = "";
    
    private string _partitionScheme = "gpt";
    public string PartitionScheme {
        get => _partitionScheme;
        init => _partitionScheme = value?.ToLowerInvariant() ?? "gpt";
    }
    
    private string _fileSystem = "fat32";
    public string FileSystem {
        get => _fileSystem;
        init => _fileSystem = value?.ToLowerInvariant() ?? "fat32";
    }
    
    private int _clusterSize;
    public int ClusterSize {
        get => _clusterSize;
        init => _clusterSize = Math.Max(0, value);
    }
    
    public bool QuickFormat { get; init; } = true;
    public bool BypassWin11 { get; init; } = false;
    public bool IsRaw { get; init; } = false;
    
    private int _persistenceSize;
    public int PersistenceSize {
        get => _persistenceSize;
        init => _persistenceSize = Math.Max(0, value);
    }
    
    public DateTime CreatedAt { get; init; } = DateTime.Now;
    public DateTime LastUsedAt { get; init; } = DateTime.Now;
    public bool IsDefault { get; init; } = false;
}




======================================
FILE: Domain\Enums.cs
======================================

namespace ProUSB.Domain;
public enum BurnStrategy { RawSectorWrite, FileSystemCopy }
public enum PartitionStyle { MBR, GPT, Hybrid, SuperFloppy }
public enum IsoType { Windows, Linux, Hybrid, Unknown }
public enum DeviceRiskLevel { Safe, Caution, Critical, SystemLockdown }
public enum DeviceBusType { Unknown, USB, SD, MMC, SCSI, ATA, NVMe, Virtual }



======================================
FILE: Domain\Interfaces.cs
======================================

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;

namespace ProUSB.Domain.Drivers {
    public interface IDiskDriver : IDisposable {
        string PhysicalId { get; }
        long Capacity { get; }
        int SectorSize { get; }
        DeviceBusType BusType { get; }
        Task ExclusiveLockAsync(CancellationToken ct);
        Task UnlockAsync(CancellationToken ct);
        Task WriteSectorsAsync(long offset, byte[] data, CancellationToken ct);
        Task<byte[]> ReadSectorsAsync(long offset, int count, CancellationToken ct);
        Task RefreshPartitionTableAsync(CancellationToken ct);
    }
    public interface IDriverFactory {
        Task<IDiskDriver> OpenDriverAsync(string deviceId, bool writeAccess, CancellationToken ct);
        Task<IEnumerable<UsbDeviceInfo>> EnumerateDevicesAsync(CancellationToken ct);
    }
}

namespace ProUSB.Domain.Services {
    public interface IBurnStrategy {
        BurnStrategy StrategyType { get; }
        Task ExecuteAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct);
        Task VerifyAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct);
    }
    public interface ISafetyGuard {
        DeviceRiskLevel EvaluateRisk(UsbDeviceInfo device);
    }
}




======================================
FILE: Domain\IsoCreationModels.cs
======================================

namespace ProUSB.Domain;

public enum IsoCreationMode {
    RawCopy,
    SmartCopy
}

public record IsoCreationProgress {
    public double PercentComplete { get; init; }
    public long BytesCopied { get; init; }
    public long TotalBytes { get; init; }
    public double SpeedBytesPerSecond { get; init; }
    public string Message { get; init; } = "";
}

public record IsoCreationResult {
    public bool Success { get; init; }
    public string OutputPath { get; init; } = "";
    public long FileSizeBytes { get; init; }
    public IsoCreationMode CreationMode { get; init; }
    public TimeSpan Duration { get; init; }
    public string? ErrorMessage { get; init; }
}




======================================
FILE: Domain\IsoDownloadModels.cs
======================================

using System;
using System.Collections.Generic;

namespace ProUSB.Domain;

public enum DownloadStatus {
    Queued,
    Downloading,
    Verifying,
    Complete,
    Failed,
    Cancelled
}

public record OsInfo {
    public required string Id { get; init; }
    public required string Name { get; init; }
    public required string Vendor { get; init; }
    public required string Version { get; init; }
    public required string Architecture { get; init; }
    public required string Category { get; init; }
    public string? DirectDownloadUrl { get; init; }
    public string? DownloadPageUrl { get; init; }
    public long? FileSizeBytes { get; init; }
    public string? Sha256Checksum { get; init; }
    public DateTime? ReleaseDate { get; init; }
}

public record DownloadJob {
    public required OsInfo OS { get; init; }
    public required string OutputPath { get; init; }
    public DownloadStatus Status { get; set; }
    public long BytesDownloaded { get; set; }
    public long TotalBytes { get; set; }
    public double SpeedBytesPerSecond { get; set; }
    public TimeSpan? TimeRemaining { get; set; }
    public string? ErrorMessage { get; set; }
}

public record DownloadProgress {
    public required double PercentComplete { get; init; }
    public required long BytesDownloaded { get; init; }
    public required long TotalBytes { get; init; }
    public required double SpeedMBps { get; init; }
    public required TimeSpan TimeRemaining { get; init; }
    public required string Status { get; init; }
}

public record OsCatalog {
    public required List<OsInfo> OperatingSystems { get; init; }
}




======================================
FILE: Domain\LogEntry.cs
======================================

using System;

namespace ProUSB.Domain;

public record LogEntry {
    public DateTime Timestamp { get; init; }
    public LogLevel Level { get; init; }
    public string Message { get; init; } = "";
    public string Source { get; init; } = "";

    public string GetFormattedEntry() {
        return $"[{Timestamp:HH:mm:ss}] [{Level}] {Message}";
    }

    public string GetCsvEntry() {
        return $"\"{Timestamp:yyyy-MM-dd HH:mm:ss}\",\"{Level}\",\"{Message.Replace("\"", "\"\"")}\"";
    }
}




======================================
FILE: Domain\LogLevel.cs
======================================

namespace ProUSB.Domain;

public enum LogLevel {
    Debug,
    Info,
    Warn,
    Error
}




======================================
FILE: Domain\Models.cs
======================================

using System;
using System.Collections.Generic;
namespace ProUSB.Domain;

public record IsoMetadata {
    public string FilePath { get; init; } = "";
    public string FileName { get; init; } = "";
    public long FileSize { get; init; }
}

public record UsbDeviceInfo {
    public string DeviceId { get; init; } = "";
    public int PhysicalIndex { get; init; }
    public string FriendlyName { get; init; } = "";
    public string BusType { get; init; } = "Unknown";
    public long TotalSize { get; init; }
    public List<string> MountPoints { get; init; } = new();
    public ushort VendorId { get; init; }
    public ushort ProductId { get; init; }
}

public record PartitionDefinition {
    public string Label { get; init; } = "New Volume";
    public string FileSystem { get; init; } = "FAT32"; 
    public long SizeMB { get; init; } 
    public bool IsBootable { get; init; }
}

public record DeploymentConfiguration {
    public required string JobName { get; init; }
    public required IsoMetadata SourceIso { get; init; }
    public required UsbDeviceInfo TargetDevice { get; init; }
    public BurnStrategy Strategy { get; init; }
    public string VolumeLabel { get; init; } = "BOOT";
    public string FileSystem { get; init; } = "fat32";
    public string PartitionScheme { get; init; } = "gpt";
    public int ClusterSize { get; init; } = 0;
    public bool QuickFormat { get; init; } = true;
    public bool BypassWin11 { get; init; }
    public int PersistenceSize { get; init; } = 0; 
    public List<PartitionDefinition>? CustomLayout { get; init; }
}

public struct WriteStatistics {
    public long BytesWritten;
    public double PercentComplete;
    public string Message;
    public double SpeedMBps;
    public TimeSpan TimeElapsed;
    public TimeSpan TimeRemaining;
}

public record BurnJob {
    public required UsbDeviceInfo Device { get; init; }
    public required string IsoPath { get; init; }
    public required DeploymentConfiguration Config { get; init; }
    public string Status { get; set; } = "Pending";
    public double Progress { get; set; } = 0;
}




======================================
FILE: Domain\PxeBootModels.cs
======================================

using System;
using System.Collections.Generic;

namespace ProUSB.Domain;

public enum PxeBootType {
    Windows,
    Linux,
    Generic
}

public record PxeBootConfiguration {
    public required string OutputDirectory { get; init; }
    public required string IsoPath { get; init; }
    public required PxeBootType BootType { get; init; }
    public bool GenerateUefiConfig { get; init; } = true;
    public bool GenerateBiosConfig { get; init; } = true;
}

public record PxeFileMapping {
    public required string SourcePath { get; init; }
    public required string DestinationPath { get; init; }
    public required string Description { get; init; }
    public long FileSize { get; init; }
}

public record PxeBootResult {
    public required bool Success { get; init; }
    public required List<PxeFileMapping> FilesCreated { get; init; }
    public required List<string> Warnings { get; init; }
    public string? ErrorMessage { get; init; }
    public TimeSpan Duration { get; init; }
}

public record PxeCreationProgress {
    public required double PercentComplete { get; init; }
    public required string Message { get; init; }
    public required string CurrentFile { get; init; }
    public long BytesProcessed { get; init; }
    public long TotalBytes { get; init; }
}




======================================
FILE: Infrastructure\DeviceDetection\DeviceSignatureDatabase.cs
======================================

using System.Collections.Generic;
using System.Linq;

namespace ProUSB.Infrastructure.DeviceDetection;

public enum DeviceType {
    Unknown,
    UsbFlashDrive,
    ExternalHdd,
    CardReader,
    SdCard,
    MemoryStick
}

public record DeviceSignature {
    public ushort VendorId { get; init; }
    public ushort ProductId { get; init; }
    public DeviceType Type { get; init; }
    public string Description { get; init; } = "";
}

public static class DeviceSignatureDatabase {
    private static readonly List<DeviceSignature> Signatures = new() {
        new() { VendorId = 0x0011, ProductId = 0x7788, Type = DeviceType.CardReader, Description = "SCM Microsystems card reader" },
        new() { VendorId = 0x03eb, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "Atmel generic UFD" },
        new() { VendorId = 0x03f0, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "HP external HDD" },
        new() { VendorId = 0x0402, ProductId = 0x5621, Type = DeviceType.CardReader, Description = "ALi card reader" },
        new() { VendorId = 0x0409, ProductId = 0x0040, Type = DeviceType.CardReader, Description = "NEC card reader" },
        new() { VendorId = 0x0411, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "Buffalo external HDD" },
        new() { VendorId = 0x0424, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "SMSC card reader" },
        new() { VendorId = 0x0480, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Toshiba card reader" },
        new() { VendorId = 0x0480, ProductId = 0xa006, Type = DeviceType.ExternalHdd, Description = "Toshiba external HDD" },
        new() { VendorId = 0x04c5, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Fujitsu card reader" },
        new() { VendorId = 0x04e8, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "Samsung external HDD" },
        new() { VendorId = 0x054c, ProductId = 0x0000, Type = DeviceType.MemoryStick, Description = "Sony Memory Stick" },
        new() { VendorId = 0x058f, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Alcor Micro card reader" },
        new() { VendorId = 0x059b, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Iomega card reader" },
        new() { VendorId = 0x059f, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "LaCie card reader" },
        new() { VendorId = 0x05ac, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "Apple external device" },
        new() { VendorId = 0x05dc, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Lexar card reader" },
        new() { VendorId = 0x05e3, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Genesys Logic card reader" },
        new() { VendorId = 0x0644, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "TEAC card reader" },
        new() { VendorId = 0x067b, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Prolific card reader" },
        new() { VendorId = 0x0718, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Imation card reader" },
        new() { VendorId = 0x0781, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "SanDisk UFD" },
        new() { VendorId = 0x0781, ProductId = 0x5530, Type = DeviceType.CardReader, Description = "SanDisk card reader" },
        new() { VendorId = 0x0789, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Logitec card reader" },
        new() { VendorId = 0x0930, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "Toshiba UFD" },
        new() { VendorId = 0x0951, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "Kingston UFD" },
        new() { VendorId = 0x0984, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Apricorn card reader" },
        new() { VendorId = 0x0a16, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Yakumo card reader" },
        new() { VendorId = 0x0bc2, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "Seagate external HDD" },
        new() { VendorId = 0x0bda, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Realtek card reader" },
        new() { VendorId = 0x0c76, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "JMicron card reader" },
        new() { VendorId = 0x0d7d, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Phison card reader" },
        new() { VendorId = 0x0dd8, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Netac card reader" },
        new() { VendorId = 0x0ea0, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Ours Technology card reader" },
        new() { VendorId = 0x0f88, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "VTech card reader" },
        new() { VendorId = 0x1005, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Apacer card reader" },
        new() { VendorId = 0x1058, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "Western Digital external HDD" },
        new() { VendorId = 0x1307, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "USBest card reader" },
        new() { VendorId = 0x13fd, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Initio card reader" },
        new() { VendorId = 0x1516, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Compro card reader" },
        new() { VendorId = 0x152d, ProductId = 0x0000, Type = DeviceType.ExternalHdd, Description = "JMicron external HDD" },
        new() { VendorId = 0x154b, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "PNY UFD" },
        new() { VendorId = 0x1f75, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Innostor card reader" },
        new() { VendorId = 0x8564, ProductId = 0x0000, Type = DeviceType.UsbFlashDrive, Description = "Transcend UFD" },
        new() { VendorId = 0x8644, ProductId = 0x0000, Type = DeviceType.CardReader, Description = "Generic card reader" },
    };

    public static DeviceType DetectDeviceType(ushort vendorId, ushort productId) {
        var exactMatch = Signatures.FirstOrDefault(s => s.VendorId == vendorId && s.ProductId == productId);
        if (exactMatch != null) {
            return exactMatch.Type;
        }

        var vendorMatch = Signatures.FirstOrDefault(s => s.VendorId == vendorId && s.ProductId == 0x0000);
        if (vendorMatch != null) {
            return vendorMatch.Type;
        }

        return DeviceType.Unknown;
    }

    public static string GetDeviceDescription(ushort vendorId, ushort productId) {
        var exactMatch = Signatures.FirstOrDefault(s => s.VendorId == vendorId && s.ProductId == productId);
        if (exactMatch != null) {
            return exactMatch.Description;
        }

        var vendorMatch = Signatures.FirstOrDefault(s => s.VendorId == vendorId && s.ProductId == 0x0000);
        return vendorMatch?.Description ?? "Unknown device";
    }

    public static bool IsKnownSafeUfd(ushort vendorId, ushort productId) {
        var type = DetectDeviceType(vendorId, productId);
        return type == DeviceType.UsbFlashDrive;
    }

    public static bool IsKnownDangerousDevice(ushort vendorId, ushort productId) {
        var type = DetectDeviceType(vendorId, productId);
        return type == DeviceType.ExternalHdd || type == DeviceType.CardReader;
    }
}




======================================
FILE: Infrastructure\DiskManagement\Native\Crc32.cs
======================================

using System;

namespace ProUSB.Infrastructure.DiskManagement.Native;

public static class Crc32 {
    private static readonly uint[] Table;

    static Crc32() {
        uint poly = 0xedb88320;
        Table = new uint[256];
        for (uint i = 0; i < 256; i++) {
            uint temp = i;
            for (int j = 8; j > 0; j--) {
                if ((temp & 1) == 1) {
                    temp = (uint)((temp >> 1) ^ poly);
                } else {
                    temp >>= 1;
                }
            }
            Table[i] = temp;
        }
    }

    public static uint Compute(byte[] bytes) {
        uint crc = 0xffffffff;
        for (int i = 0; i < bytes.Length; i++) {
            byte index = (byte)((crc & 0xff) ^ bytes[i]);
            crc = (uint)((crc >> 8) ^ Table[index]);
        }
        return ~crc;
    }
}




======================================
FILE: Infrastructure\DiskManagement\Native\NativeMethods.cs
======================================

using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace ProUSB.Infrastructure.DiskManagement.Native;

internal static class NativeMethods {
    public const uint GENERIC_READ = 0x80000000;
    public const uint GENERIC_WRITE = 0x40000000;
    public const uint FILE_SHARE_READ = 0x00000001;
    public const uint FILE_SHARE_WRITE = 0x00000002;
    public const uint OPEN_EXISTING = 3;
    public const uint FILE_ATTRIBUTE_NORMAL = 0x00000080;
    public const uint FILE_FLAG_NO_BUFFERING = 0x20000000;
    public const uint FILE_FLAG_WRITE_THROUGH = 0x80000000;
    public const uint FILE_FLAG_OVERLAPPED = 0x40000000;

    public const uint IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00074050;
    public const uint IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x0007C054;
    public const uint IOCTL_DISK_CREATE_DISK = 0x0007C058;
    public const uint IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x0007C0E0;
    public const uint IOCTL_DISK_UPDATE_PROPERTIES = 0x00070024;
    public const uint IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x000700A0;
    public const uint IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x00560000;
    public const uint IOCTL_STORAGE_QUERY_PROPERTY = 0x002D1400;
    public const uint FSCTL_LOCK_VOLUME = 0x00090018;
    public const uint FSCTL_UNLOCK_VOLUME = 0x0009001C;
    public const uint FSCTL_DISMOUNT_VOLUME = 0x00090020;
    public const uint FSCTL_ALLOW_EXTENDED_DASD_IO = 0x00090083;

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern SafeFileHandle CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool DeviceIoControl(
        SafeFileHandle hDevice,
        uint dwIoControlCode,
        IntPtr lpInBuffer,
        uint nInBufferSize,
        IntPtr lpOutBuffer,
        uint nOutBufferSize,
        out uint lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool WriteFile(
        SafeFileHandle hFile,
        IntPtr lpBuffer,
        uint nNumberOfBytesToWrite,
        out uint lpNumberOfBytesWritten,
        IntPtr lpOverlapped);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool ReadFile(
        SafeFileHandle hFile,
        IntPtr lpBuffer,
        uint nNumberOfBytesToRead,
        out uint lpNumberOfBytesRead,
        IntPtr lpOverlapped);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool SetFilePointerEx(
        SafeFileHandle hFile,
        long liDistanceToMove,
        IntPtr lpNewFilePointer,
        uint dwMoveMethod);

    [StructLayout(LayoutKind.Sequential)]
    public struct CREATE_DISK {
        public int PartitionStyle;
        public CREATE_DISK_UNION Union;
    }

    [StructLayout(LayoutKind.Explicit)]
    public struct CREATE_DISK_UNION {
        [FieldOffset(0)] public CREATE_DISK_MBR Mbr;
        [FieldOffset(0)] public CREATE_DISK_GPT Gpt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct CREATE_DISK_MBR {
        public uint Signature;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct CREATE_DISK_GPT {
        public Guid DiskId;
        public uint MaxPartitionCount;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct DRIVE_LAYOUT_INFORMATION_EX {
        public uint PartitionStyle;
        public uint PartitionCount;
        public DRIVE_LAYOUT_INFORMATION_UNION Union;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public PARTITION_INFORMATION_EX[] PartitionEntry;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public struct DRIVE_LAYOUT_INFORMATION_UNION {
        [FieldOffset(0)] public DRIVE_LAYOUT_INFORMATION_MBR Mbr;
        [FieldOffset(0)] public DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DRIVE_LAYOUT_INFORMATION_MBR {
        public uint Signature;
        public uint CheckSum;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DRIVE_LAYOUT_INFORMATION_GPT {
        public Guid DiskId;
        public long StartingUsableOffset;
        public long UsableLength;
        public uint MaxPartitionCount;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PARTITION_INFORMATION_EX {
        public uint PartitionStyle;
        public long StartingOffset;
        public long PartitionLength;
        public uint PartitionNumber;
        [MarshalAs(UnmanagedType.U1)]
        public bool RewritePartition;
        [MarshalAs(UnmanagedType.U1)]
        public bool IsServicePartition;
        public PARTITION_INFORMATION_UNION Union;
    }

    [StructLayout(LayoutKind.Explicit, Size = 112)]
    public unsafe struct PARTITION_INFORMATION_UNION {
        [FieldOffset(0)] public PARTITION_INFORMATION_MBR Mbr;
        [FieldOffset(0)] public PARTITION_INFORMATION_GPT Gpt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct PARTITION_INFORMATION_MBR {
        public byte PartitionType;
        [MarshalAs(UnmanagedType.U1)]
        public bool BootIndicator;
        [MarshalAs(UnmanagedType.U1)]
        public bool RecognizedPartition;
        public byte Padding1;
        public uint HiddenSectors;
        public Guid PartitionId;
        public fixed byte Padding2[88];
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct PARTITION_INFORMATION_GPT {
        public Guid PartitionType;
        public Guid PartitionId;
        public ulong Attributes;
        public fixed byte NameBytes[72];
        
        public void SetName(string value) {
            fixed (byte* pName = NameBytes) {
                for (int i = 0; i < 72; i++) {
                    pName[i] = 0;
                }
                
                if (!string.IsNullOrEmpty(value)) {
                    byte[] bytes = System.Text.Encoding.Unicode.GetBytes(value);
                    int copyLen = Math.Min(bytes.Length, 72);
                    for (int i = 0; i < copyLen; i++) {
                        pName[i] = bytes[i];
                    }
                }
            }
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DISK_GEOMETRY {
        public long Cylinders;
        public uint MediaType;
        public uint TracksPerCylinder;
        public uint SectorsPerTrack;
        public uint BytesPerSector;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DISK_GEOMETRY_EX {
        public DISK_GEOMETRY Geometry;
        public long DiskSize;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public byte[] Data;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DISK_EXTENT {
        public int DiskNumber;
        public long StartingOffset;
        public long ExtentLength;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct VOLUME_DISK_EXTENTS {
        public int NumberOfDiskExtents;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
        public DISK_EXTENT[] Extents;
    }

    public enum PARTITION_STYLE : int {
        MBR = 0,
        GPT = 1,
        RAW = 2
    }

    public const ulong GPT_ATTRIBUTE_PLATFORM_REQUIRED = 0x0000000000000001;
    public const ulong GPT_ATTRIBUTE_NO_BLOCK_IO_PROTOCOL = 0x0000000000000002;
    public const ulong GPT_ATTRIBUTE_LEGACY_BIOS_BOOTABLE = 0x0000000000000004;
    public const ulong GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 0x8000000000000000;
    public const ulong GPT_BASIC_DATA_ATTRIBUTE_HIDDEN = 0x4000000000000000;
    public const ulong GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY = 0x2000000000000000;
    public const ulong GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY = 0x1000000000000000;
    
    [DllImport("fmifs.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern void FormatEx(
        string DriveRoot,
        int MediaFlag,
        string FileSystem,
        string Label,
        bool QuickFormat,
        int ClusterSize,
        FormatCallback Callback);

    public delegate bool FormatCallback(
        int Command,
        int SubAction,
        IntPtr ActionInfo);

    public enum FMIFS_PACKET_TYPE {
        FmIfsPercentCompleted = 0,
        FmIfsFormatReport = 1,
        FmIfsInsertDisk = 2,
        FmIfsIncompatibleFileSystem = 3,
        FmIfsFormattingDestination = 4,
        FmIfsIncompatibleMedia = 5,
        FmIfsAccessDenied = 6,
        FmIfsMediaWriteProtected = 7,
        FmIfsCantLock = 8,
        FmIfsCantQuickFormat = 9,
        FmIfsIoError = 10,
        FmIfsFinished = 11,
        FmIfsBadLabel = 12
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STORAGE_PROPERTY_QUERY {
        public uint PropertyId;
        public uint QueryType;
        public byte AdditionalParameters;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct STORAGE_DEVICE_DESCRIPTOR_HEADER {
        public uint Version;
        public uint Size;
        public byte DeviceType;
        public byte DeviceTypeModifier;
        [MarshalAs(UnmanagedType.U1)] public bool RemovableMedia;
        [MarshalAs(UnmanagedType.U1)] public bool CommandQueueing;
        public uint VendorIdOffset;
        public uint ProductIdOffset;
        public uint ProductRevisionOffset;
        public uint SerialNumberOffset;
        public uint BusType;
        public uint RawPropertiesLength;
    }
}




======================================
FILE: Infrastructure\DiskManagement\Vds\IVdsInterfaces.cs
======================================

using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;

namespace ProUSB.Infrastructure.DiskManagement.Vds;

[ComImport]
[Guid("B6B22DA8-F903-4BE7-B492-C09D875AC9DA")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVdsServiceLoader {
    [PreserveSig]
    int LoadService([In, MarshalAs(UnmanagedType.LPWStr)] string machineName, out IVdsService service);
}

[ComImport]
[Guid("0818A8EF-9BA9-40D8-A6F9-E22833CC771E")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVdsService {
    [PreserveSig]
    int IsServiceReady();

    [PreserveSig]
    int WaitForServiceReady();

    [PreserveSig]
    int GetProperties(out VDS_SERVICE_PROP properties);

    [PreserveSig]
    int QueryProviders(uint masks, out IEnumVdsObject enumObject);

    [PreserveSig]
    int QueryMaskedDisks(out IEnumVdsObject enumObject);

    [PreserveSig]
    int QueryUnallocatedDisks(out IEnumVdsObject enumObject);

    [PreserveSig]
    int GetObject([In, MarshalAs(UnmanagedType.Struct)] Guid objectId, VDS_OBJECT_TYPE type, out object obj);

    [PreserveSig]
    int QueryDriveLetters(byte wcFirstLetter, uint count, out VDS_DRIVE_LETTER_PROP driveLetterPropArray);

    [PreserveSig]
    int QueryFileSystemTypes(out IntPtr ppFileSystemTypeProps, out int plNumberOfFileSystems);

    [PreserveSig]
    int Reenumerate();

    [PreserveSig]
    int Refresh();

    [PreserveSig]
    int CleanupObsoleteMountPoints();
}

[ComImport]
[Guid("118610B7-8D94-4030-B5B8-500889788E4E")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IEnumVdsObject {
    [PreserveSig]
    int Next(uint celt, [Out, MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.IUnknown)] object[] ppObjectArray, out uint pcFetched);

    [PreserveSig]
    int Skip(uint celt);

    [PreserveSig]
    int Reset();

    [PreserveSig]
    int Clone([MarshalAs(UnmanagedType.Interface)] out IEnumVdsObject ppEnum);
}

[StructLayout(LayoutKind.Sequential)]
public struct VDS_SERVICE_PROP {
    [MarshalAs(UnmanagedType.LPWStr)]
    public string pwszVersion;
    public uint ulFlags;
}

[StructLayout(LayoutKind.Sequential)]
public struct VDS_DRIVE_LETTER_PROP {
    public byte wcLetter;
    public Guid volumeId;
    public uint ulFlags;
    [MarshalAs(UnmanagedType.Bool)]
    public bool bUsed;
}

public enum VDS_OBJECT_TYPE {
    VDS_OT_UNKNOWN = 0,
    VDS_OT_PROVIDER = 1,
    VDS_OT_PACK = 10,
    VDS_OT_VOLUME = 11,
    VDS_OT_VOLUME_PLEX = 12,
    VDS_OT_DISK = 13
}

[ComImport]
[Guid("9AA58360-CE33-4F92-B658-ED24B14425B8")]
public class VdsServiceLoader { }




======================================
FILE: Infrastructure\DiskManagement\Vds\VdsPartitionRefresher.cs
======================================

using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Services.Logging;

namespace ProUSB.Infrastructure.DiskManagement.Vds;

public class VdsPartitionRefresher {
    private readonly FileLogger _log;

    public VdsPartitionRefresher(FileLogger log) {
        _log = log;
    }

    public async Task<bool> RefreshPartitionsAsync(CancellationToken ct) {
        return await Task.Run(() => RefreshPartitions(), ct);
    }

    private bool RefreshPartitions() {
        if (!OperatingSystem.IsWindows()) {
            _log.Debug("VDS is only available on Windows");
            return false;
        }

        IVdsServiceLoader? loader = null;
        IVdsService? service = null;

        try {
            _log.Info("Attempting VDS partition refresh...");
            
            var vdsLoaderType = Type.GetTypeFromCLSID(new Guid("9C38ED61-D565-4728-AEEE-C80952F0ECDE"));
            if (vdsLoaderType == null) {
                _log.Warn("VDS Loader type not found");
                return false;
            }
            
            var vdsLoaderObj = Activator.CreateInstance(vdsLoaderType);
            if (vdsLoaderObj == null) {
                _log.Warn("Failed to create VDS Loader instance");
                return false;
            }

            loader = vdsLoaderObj as IVdsServiceLoader;
            if (loader == null) {
                _log.Warn("VDS Loader instance is not of expected type");
                return false;
            }

            int hr = loader.LoadService(null!, out service);
            if (hr != 0 || service == null) {
                _log.Warn($"VDS LoadService failed: 0x{hr:X8}");
                return false;
            }

            hr = service.WaitForServiceReady();
            if (hr != 0) {
                _log.Warn($"VDS WaitForServiceReady failed: 0x{hr:X8}");
                return false;
            }

            _log.Info("VDS service ready, calling Reenumerate...");
            hr = service.Reenumerate();
            if (hr != 0) {
                _log.Warn($"VDS Reenumerate failed: 0x{hr:X8}");
                return false;
            }

            _log.Info("Calling VDS Refresh...");
            hr = service.Refresh();
            if (hr != 0) {
                _log.Warn($"VDS Refresh failed: 0x{hr:X8}");
                return false;
            }

            _log.Info("VDS partition refresh successful");
            return true;

        } catch (Exception ex) {
            _log.Warn($"VDS refresh exception: {ex.Message}");
            return false;
        } finally {
            if (OperatingSystem.IsWindows()) {
                if (service != null) {
                    try { Marshal.ReleaseComObject(service); } catch { }
                }
                if (loader != null) {
                    try {  Marshal.ReleaseComObject(loader); } catch { }
                }
            }
        }
    }
}





======================================
FILE: Infrastructure\DiskManagement\Vds\VdsRescanService.cs
======================================

using System;
using System.Runtime.InteropServices;
using ProUSB.Services.Logging;

namespace ProUSB.Infrastructure.DiskManagement.Vds;

public class VdsRescanService {
    private readonly FileLogger _log;

    [Flags]
    public enum RescanType {
        Refresh = 1,      
        Reenumerate = 2   
    }

    public VdsRescanService(FileLogger log) {
        _log = log;
    }

    public async System.Threading.Tasks.Task<bool> RescanAsync(RescanType rescanType, int sleepAfterMs = 0) {
        _log.Info("Forcing VDS rescan to prevent Windows from 'losing' the disk...");
        
        try {
            var refresher = new VdsPartitionRefresher(_log);
            await refresher.RefreshPartitionsAsync(System.Threading.CancellationToken.None);
            
            if (sleepAfterMs > 0) {
                _log.Info($"Waiting {sleepAfterMs}ms for rescan to complete...");
                await System.Threading.Tasks.Task.Delay(sleepAfterMs);
            }
            
            _log.Info("VDS rescan completed successfully");
            return true;
        } catch (Exception ex) {
            _log.Warn($"VDS rescan failed: {ex.Message}");
            return false;
        }
    }
}






======================================
FILE: Infrastructure\DiskManagement\AdvancedVolumeMounter.cs
======================================

using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Win32.SafeHandles;
using ProUSB.Services.Logging;

namespace ProUSB.Infrastructure.DiskManagement;

public class AdvancedVolumeMounter {
    private readonly FileLogger _log;

    public AdvancedVolumeMounter(FileLogger log) {
        _log = log;
    }

    public async Task<string> WaitForVolumeAsync(int diskIndex, long partitionOffset, int timeoutSeconds, CancellationToken ct, bool wildcard = false) {
        _log.Info($"=== ADVANCED VOLUME MOUNT (Multi-API Technique) ===");
        _log.Info($"Waiting for volume on Disk {diskIndex}, Partition offset {partitionOffset}, Wildcard: {wildcard}");

        var startTime = DateTime.UtcNow;
        string? volumePath = null;

        await TriggerMultipleRefreshMethods(diskIndex, ct);

        int attempts = 0;
        int maxAttempts = timeoutSeconds * 2;

        while (attempts < maxAttempts && volumePath == null) {
            ct.ThrowIfCancellationRequested();
            
            volumePath = GetVolumeForPartition(diskIndex, partitionOffset, wildcard);
            
            if (volumePath != null) {
                var elapsed = (DateTime.UtcNow - startTime).TotalSeconds;
                _log.Info($"Volume found: {volumePath} (after {elapsed:F1}s)");
                
                if (await WaitForVolumeReady(volumePath, ct)) {
                    return volumePath;
                }
            }

            if (attempts % 10 == 0 && attempts > 0) {
                _log.Debug($"Still waiting... {attempts * 0.5:F1}s / {timeoutSeconds}s");
                
                if (attempts % 20 == 0) {
                    _log.Info("Triggering additional refresh...");
                    await TriggerMultipleRefreshMethods(diskIndex, ct);
                }
            }

            await Task.Delay(500, ct);
            attempts++;
        }

        var totalElapsed = (DateTime.UtcNow - startTime).TotalSeconds;
        throw new MountFailedException(
            $"Volume did not appear after {totalElapsed:F1}s. " +
            $"Disk {diskIndex} may need manual drive letter assignment in Disk Management.");
    }

    public async Task TriggerMultipleRefreshMethods(int diskIndex, CancellationToken ct) {
        _log.Info("Triggering comprehensive partition refresh...");

        await Task.Run(() => {
            RefreshDiskLayout(diskIndex);
        }, ct);

        var vdsRefresher = new Vds.VdsPartitionRefresher(_log);
        await vdsRefresher.RefreshPartitionsAsync(ct);

        TriggerDeviceArrival();

        await Task.Delay(500, ct);
    }

    private void RefreshDiskLayout(int diskIndex) {
        try {
            using var hDrive = NativeMethods.CreateFile(
                $@"\\.\PhysicalDrive{diskIndex}",
                NativeMethods.GENERIC_READ,
                NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE,
                IntPtr.Zero,
                NativeMethods.OPEN_EXISTING,
                0,
                IntPtr.Zero);

            if (hDrive.IsInvalid) return;

            NativeMethods.DeviceIoControl(
                hDrive,
                NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES,
                IntPtr.Zero, 0, IntPtr.Zero, 0,
                out _, IntPtr.Zero);

            int layoutSize = 4096;
            IntPtr layoutPtr = Marshal.AllocHGlobal(layoutSize);
            try {
                NativeMethods.DeviceIoControl(
                    hDrive,
                    NativeMethods.IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                    IntPtr.Zero, 0, layoutPtr, (uint)layoutSize,
                    out _, IntPtr.Zero);
            } finally {
                Marshal.FreeHGlobal(layoutPtr);
            }

        } catch (Exception ex) {
            _log.Debug($"RefreshDiskLayout error: {ex.Message}");
        }
    }

    private void TriggerDeviceArrival() {
        try {
            IntPtr hWnd = NativeMethods.HWND_BROADCAST;
            IntPtr result = IntPtr.Zero;
            
            NativeMethods.SendMessageTimeout(
                hWnd,
                NativeMethods.WM_DEVICECHANGE,
                new IntPtr(0x8000),
                IntPtr.Zero,
                0,
                1000,
                out result);

            _log.Debug("Broadcasted device arrival message");
        } catch (Exception ex) {
            _log.Debug($"TriggerDeviceArrival error: {ex.Message}");
        }
    }

    public string[] GetVolumesOnDisk(int diskIndex) {
        var result = new System.Collections.Generic.List<string>();
        try {
            var volumes = EnumerateVolumes();
            foreach (var volume in volumes) {
                var extents = GetVolumeExtents(volume);
                if (extents.Any(e => e.DiskNumber == diskIndex)) {
                     result.Add(volume.TrimEnd('\\')); 
                }
            }
        } catch (Exception ex) {
            _log.Debug($"GetVolumesOnDisk error: {ex.Message}");
        }
        return result.ToArray();
    }

    public string? GetVolumeForPartition(int diskIndex, long partitionOffset, bool wildcard) {
        try {
            var volumes = EnumerateVolumes();
            
            foreach (var volume in volumes) {
                var extents = GetVolumeExtents(volume);
                
                if (extents.Any(e => e.DiskNumber == diskIndex && (wildcard || e.StartingOffset == partitionOffset))) {
                    var mountPoint = GetVolumeMountPoint(volume);
                    if (mountPoint != null) {
                        return mountPoint;
                    }
                }
            }
        } catch (Exception ex) {
            _log.Debug($"GetVolumeForPartition error: {ex.Message}");
        }

        return null;
    }

    private string[] EnumerateVolumes() {
        var volumes = new System.Collections.Generic.List<string>();
        var volumeName = new System.Text.StringBuilder(260);
        
        IntPtr hFind = NativeMethods.FindFirstVolume(volumeName, volumeName.Capacity);
        
        if (hFind != IntPtr.Zero && hFind.ToInt64() != -1) {
            try {
                do {
                    volumes.Add(volumeName.ToString());
                } while (NativeMethods.FindNextVolume(hFind, volumeName, volumeName.Capacity));
            } finally {
                NativeMethods.FindVolumeClose(hFind);
            }
        }

        return volumes.ToArray();
    }

    private (int DiskNumber, long StartingOffset)[] GetVolumeExtents(string volumeName) {
        var extents = new System.Collections.Generic.List<(int, long)>();

        try {
            var trimmed = volumeName.TrimEnd('\\');
            using var hVolume = NativeMethods.CreateFile(
                trimmed,
                0,
                NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE,
                IntPtr.Zero,
                NativeMethods.OPEN_EXISTING,
                0,
                IntPtr.Zero);

            if (hVolume.IsInvalid) return extents.ToArray();

            int size = Marshal.SizeOf<VOLUME_DISK_EXTENTS>() + 32 * Marshal.SizeOf<DISK_EXTENT>();
            IntPtr buffer = Marshal.AllocHGlobal(size);

            try {
                if (NativeMethods.DeviceIoControl(
                    hVolume,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    IntPtr.Zero, 0,
                    buffer, (uint)size,
                    out uint bytesReturned,
                    IntPtr.Zero)) {

                    var vde = Marshal.PtrToStructure<VOLUME_DISK_EXTENTS>(buffer);
                    IntPtr extentPtr = IntPtr.Add(buffer, 8);

                    for (int i = 0; i < vde.NumberOfDiskExtents; i++) {
                        var extent = Marshal.PtrToStructure<DISK_EXTENT>(extentPtr);
                        extents.Add((extent.DiskNumber, extent.StartingOffset));
                        extentPtr = IntPtr.Add(extentPtr, Marshal.SizeOf<DISK_EXTENT>());
                    }
                }
            } finally {
                Marshal.FreeHGlobal(buffer);
            }
        } catch { }

        return extents.ToArray();
    }

    private string? GetVolumeMountPoint(string volumeName) {
        var pathNames = new System.Text.StringBuilder(1024);
        uint returnLength = 0;

        if (NativeMethods.GetVolumePathNamesForVolumeName(
            volumeName,
            pathNames,
            (uint)pathNames.Capacity,
            ref returnLength)) {

            var paths = pathNames.ToString().Split('\0', StringSplitOptions.RemoveEmptyEntries);
            return paths.FirstOrDefault();
        }

        return null;
    }

    private async Task<bool> WaitForVolumeReady(string volumePath, CancellationToken ct) {
        for (int i = 0; i < 10; i++) {
            try {
                if (Directory.Exists(volumePath)) {
                    var di = new DriveInfo(volumePath);
                    if (di.IsReady) {
                        _log.Info($"Volume {volumePath} is ready");
                        return true;
                    }
                }
            } catch { }

            await Task.Delay(200, ct);
        }

        return false;
    }

    private const uint IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 0x00560000;

    [StructLayout(LayoutKind.Sequential)]
    private struct VOLUME_DISK_EXTENTS {
        public uint NumberOfDiskExtents;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct DISK_EXTENT {
        public int DiskNumber;
        public long StartingOffset;
        public long ExtentLength;
    }

    private static class NativeMethods {
        public const uint GENERIC_READ = 0x80000000;
        public const uint FILE_SHARE_READ = 0x00000001;
        public const uint FILE_SHARE_WRITE = 0x00000002;
        public const uint OPEN_EXISTING = 3;
        public const uint IOCTL_DISK_UPDATE_PROPERTIES = 0x00070140;
        public const uint IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00070050;
        public const uint WM_DEVICECHANGE = 0x0219;
        public static readonly IntPtr HWND_BROADCAST = new IntPtr(0xFFFF);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern SafeFileHandle CreateFile(
            string lpFileName,
            uint dwDesiredAccess,
            uint dwShareMode,
            IntPtr lpSecurityAttributes,
            uint dwCreationDisposition,
            uint dwFlagsAndAttributes,
            IntPtr hTemplateFile);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DeviceIoControl(
            SafeFileHandle hDevice,
            uint dwIoControlCode,
            IntPtr lpInBuffer,
            uint nInBufferSize,
            IntPtr lpOutBuffer,
            uint nOutBufferSize,
            out uint lpBytesReturned,
            IntPtr lpOverlapped);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern IntPtr FindFirstVolume(
            System.Text.StringBuilder lpszVolumeName,
            int cchBufferLength);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool FindNextVolume(
            IntPtr hFindVolume,
            System.Text.StringBuilder lpszVolumeName,
            int cchBufferLength);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool FindVolumeClose(IntPtr hFindVolume);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool GetVolumePathNamesForVolumeName(
            string lpszVolumeName,
            System.Text.StringBuilder lpszVolumePathNames,
            uint cchBufferLength,
            ref uint lpcchReturnLength);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,
            uint Msg,
            IntPtr wParam,
            IntPtr lParam,
            uint fuFlags,
            uint uTimeout,
            out IntPtr lpdwResult);
    }
}





======================================
FILE: Infrastructure\DiskManagement\AutoMountManager.cs
======================================

using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using ProUSB.Services.Logging;

namespace ProUSB.Infrastructure.DiskManagement;

public class AutoMountManager {
    private readonly FileLogger _log;
    private const string MOUNTMGR_DOS_DEVICE_NAME = @"\\.\MountPointManager";
    private const uint IOCTL_MOUNTMGR_SET_AUTO_MOUNT = 0x006DC034;
    private const uint IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT = 0x006DC038;

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern SafeFileHandle CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,

        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool DeviceIoControl(
        SafeFileHandle hDevice,
        uint dwIoControlCode,
        ref bool lpInBuffer,
        int nInBufferSize,
        IntPtr lpOutBuffer,
        int nOutBufferSize,
        IntPtr lpBytesReturned,
        IntPtr lpOverlapped);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool DeviceIoControl(
        SafeFileHandle hDevice,
        uint dwIoControlCode,
        IntPtr lpInBuffer,
        int nInBufferSize,
        ref bool lpOutBuffer,
        int nOutBufferSize,
        out int lpBytesReturned,
        IntPtr lpOverlapped);

    public AutoMountManager(FileLogger log) {
        _log = log;
    }

    public bool SetAutoMount(bool enable) {
        using var hMountMgr = CreateFile(
            MOUNTMGR_DOS_DEVICE_NAME,
            0, 
            3, 
            IntPtr.Zero,
            3, 
            0x80, 
            IntPtr.Zero
        );

        if (hMountMgr.IsInvalid) {
            _log.Warn($"Failed to open MountPointManager: {Marshal.GetLastWin32Error()}");
            return false;
        }

        bool enableValue = enable;
        bool result = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_SET_AUTO_MOUNT,
            ref enableValue,
            sizeof(bool),
            IntPtr.Zero,
            0,
            IntPtr.Zero,
            IntPtr.Zero
        );

        if (result) {
            _log.Info($"AutoMount {(enable ? "enabled" : "disabled")} successfully");
        } else {
            _log.Warn($"Failed to set AutoMount: {Marshal.GetLastWin32Error()}");
        }

        return result;
    }

    public bool GetAutoMount(out bool enabled) {
        enabled = false;
        
        using var hMountMgr = CreateFile(
            MOUNTMGR_DOS_DEVICE_NAME,
            0,
            3,
            IntPtr.Zero,
            3,
            0x80,
            IntPtr.Zero
        );

        if (hMountMgr.IsInvalid) {
            return false;
        }

        bool result = DeviceIoControl(
            hMountMgr,
            IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT,
            IntPtr.Zero,
            0,
            ref enabled,
            sizeof(bool),
            out _,
            IntPtr.Zero
        );

        return result;
    }

    public void WithAutoMountDisabled(Action action) {
        bool wasEnabled = false;
        bool savedState = GetAutoMount(out wasEnabled);

        try {
            if (wasEnabled) {
                _log.Info("Temporarily disabling AutoMount for disk operation...");
                SetAutoMount(false);
            }

            action();
        } finally {
            if (savedState && wasEnabled) {
                _log.Info("Restoring AutoMount to enabled state...");
                SetAutoMount(true);
            }
        }
    }
}






======================================
FILE: Infrastructure\DiskManagement\DiskConstants.cs
======================================

namespace ProUSB.Infrastructure.DiskManagement;

public static class DiskConstants {
    public const int DefaultMountDelayMs = 2000;
    public const long MbrDataOffset = 1048576;
    public const long GptDataOffset = 17825792;
    public const int MbrDataPartitionNumber = 1;
    public const int GptDataPartitionNumber = 2;
}




======================================
FILE: Infrastructure\DiskManagement\DiskHelper.cs
======================================

using System;

namespace ProUSB.Infrastructure.DiskManagement;

public static class DiskHelper
{
    public static int GetDataPartitionNumber(bool isGpt)
    {
        return isGpt ? DiskConstants.GptDataPartitionNumber : DiskConstants.MbrDataPartitionNumber;
    }

    public static long GetExpectedOffset(string partitionScheme)
    {
        if (string.IsNullOrWhiteSpace(partitionScheme))
            throw new ArgumentNullException(nameof(partitionScheme));

        return partitionScheme.Contains("GPT", StringComparison.OrdinalIgnoreCase)
            ? DiskConstants.GptDataOffset
            : DiskConstants.MbrDataOffset;
    }
}




======================================
FILE: Infrastructure\DiskManagement\DriveLockingService.cs
======================================

using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Threading;
using Microsoft.Win32.SafeHandles;
using ProUSB.Infrastructure.DiskManagement.Native;
using ProUSB.Services.Logging;

namespace ProUSB.Infrastructure.DiskManagement;

public class DriveLockingService {
    private readonly FileLogger _log;
    private const int DRIVE_ACCESS_RETRIES = 20;
    private const int DRIVE_ACCESS_TIMEOUT = 5000; 

    public DriveLockingService(FileLogger log) {
        _log = log;
    }

    public SafeFileHandle OpenAndLockDrive(int diskIndex, bool writeAccess) {
        string path = $@"\\.\PhysicalDrive{diskIndex}";
        SafeFileHandle hDrive = new SafeFileHandle(IntPtr.Zero, true);
        bool bWriteShare = false;

        for (int i = 0; i < DRIVE_ACCESS_RETRIES; i++) {

            
            uint access = NativeMethods.GENERIC_READ | (writeAccess ? NativeMethods.GENERIC_WRITE : 0);
            uint share = NativeMethods.FILE_SHARE_READ | (bWriteShare ? NativeMethods.FILE_SHARE_WRITE : 0);

            hDrive = NativeMethods.CreateFile(
                path,
                access,
                share,
                IntPtr.Zero,
                NativeMethods.OPEN_EXISTING,
                NativeMethods.FILE_ATTRIBUTE_NORMAL | NativeMethods.FILE_FLAG_NO_BUFFERING | NativeMethods.FILE_FLAG_WRITE_THROUGH,
                IntPtr.Zero
            );

            if (!hDrive.IsInvalid) {
                break; 
            }

            int error = Marshal.GetLastWin32Error();
            if (error != 32 && error != 5) { 

                throw new Win32Exception(error, $"Failed to open drive {path}");
            }

            if (i == 0) {
                _log.Info($"Waiting for access on {path}...");
            } else if (!bWriteShare && i > DRIVE_ACCESS_RETRIES / 3) {
                _log.Warn("Could not obtain exclusive rights. Retrying with write sharing enabled...");
                bWriteShare = true;
            }

            Thread.Sleep(DRIVE_ACCESS_TIMEOUT / DRIVE_ACCESS_RETRIES);
        }

        if (hDrive.IsInvalid) {
            throw new Win32Exception(Marshal.GetLastWin32Error(), $"Could not open {path} after {DRIVE_ACCESS_RETRIES} retries.");
        }

        if (writeAccess) {
            if (!LockDrive(hDrive)) {
                hDrive.Dispose();
                throw new Win32Exception(Marshal.GetLastWin32Error(), $"Could not lock drive {path}");
            }
        }

        return hDrive;
    }

    private bool LockDrive(SafeFileHandle hDrive) {
        uint bytesReturned;

        if (NativeMethods.DeviceIoControl(hDrive, NativeMethods.FSCTL_ALLOW_EXTENDED_DASD_IO, IntPtr.Zero, 0, IntPtr.Zero, 0, out bytesReturned, IntPtr.Zero)) {
            _log.Info("I/O boundary checks disabled (FSCTL_ALLOW_EXTENDED_DASD_IO success)");
        }

        long endTime = DateTime.Now.Ticks + (DRIVE_ACCESS_TIMEOUT * 10000);
        
        while (DateTime.Now.Ticks < endTime) {
            if (NativeMethods.DeviceIoControl(hDrive, NativeMethods.FSCTL_LOCK_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out bytesReturned, IntPtr.Zero)) {
                _log.Info("FSCTL_LOCK_VOLUME success");
                return true;
            }
            Thread.Sleep(DRIVE_ACCESS_TIMEOUT / DRIVE_ACCESS_RETRIES);
        }

        _log.Warn($"Could not lock drive: {Marshal.GetLastWin32Error()}");
        return false;
    }
}






======================================
FILE: Infrastructure\DiskManagement\DriveSafetyValidator.cs
======================================

using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using ProUSB.Services.Logging;
using ProUSB.Domain;

namespace ProUSB.Infrastructure.DiskManagement;

public class DriveSafetyValidator {
    private readonly FileLogger _log;

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern uint GetSystemDirectory(
        [Out] System.Text.StringBuilder lpBuffer,
        uint uSize);

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern bool GetVolumePathName(
        string lpszFileName,
        [Out] System.Text.StringBuilder lpszVolumePathName,
        uint cchBufferLength);

    public enum SafetyViolation {
        None = 0,
        IsSystemDrive = 1,
        IsSourceDrive = 2,
        TooSmall = 4,
        IsReadOnly = 8
    }

    public DriveSafetyValidator(FileLogger log) {
        _log = log;
    }

    public SafetyViolation ValidateDrive(UsbDeviceInfo deviceInfo, string? isoPath = null) {
        SafetyViolation violations = SafetyViolation.None;

        if (IsSystemDrive(deviceInfo)) {
            violations |= SafetyViolation.IsSystemDrive;
            _log.Warn($"⚠️ CRITICAL: Device {deviceInfo.FriendlyName} is a SYSTEM DRIVE!");
        }

        if (!string.IsNullOrEmpty(isoPath) && IsSourceDrive(deviceInfo, isoPath)) {
            violations |= SafetyViolation.IsSourceDrive;
            _log.Warn($"⚠️ WARNING: Device {deviceInfo.FriendlyName} contains the source ISO!");
        }

        if (deviceInfo.TotalSize < 64 * 1024 * 1024) {
            violations |= SafetyViolation.TooSmall;
            _log.Warn($"⚠️ WARNING: Device {deviceInfo.FriendlyName} is too small ({deviceInfo.TotalSize} bytes)");
        }

        return violations;
    }

    private bool IsSystemDrive(UsbDeviceInfo deviceInfo) {
        try {

            var sysDir = new System.Text.StringBuilder(260);
            GetSystemDirectory(sysDir, 260);
            string windowsPath = sysDir.ToString();

            if (string.IsNullOrEmpty(windowsPath)) {
                _log.Warn("Could not determine Windows directory");
                return false;
            }

            string systemRoot = Path.GetPathRoot(windowsPath) ?? "";

            foreach (var mountPoint in deviceInfo.MountPoints) {
                string driveLetter = mountPoint.TrimEnd('\\');
                if (driveLetter.Equals(systemRoot.TrimEnd('\\'), StringComparison.OrdinalIgnoreCase)) {
                    return true;
                }
            }

            return false;
        } catch (Exception ex) {
            _log.Warn($"Error checking system drive: {ex.Message}");

            return true;
        }
    }

    private bool IsSourceDrive(UsbDeviceInfo deviceInfo, string isoPath) {
        try {
            if (!File.Exists(isoPath)) {
                return false;
            }

            var volumePath = new System.Text.StringBuilder(260);
            if (!GetVolumePathName(isoPath, volumePath, 260)) {
                _log.Warn($"Could not get volume path for ISO: {isoPath}");
                return false;
            }

            string isoRoot = volumePath.ToString().TrimEnd('\\');

            foreach (var mountPoint in deviceInfo.MountPoints) {
                string driveLetter = mountPoint.TrimEnd('\\');
                if (driveLetter.Equals(isoRoot, StringComparison.OrdinalIgnoreCase)) {
                    return true;
                }
            }

            return false;
        } catch (Exception ex) {
            _log.Warn($"Error checking source drive: {ex.Message}");
            return false;
        }
    }

    public string GetViolationMessage(SafetyViolation violations) {
        if (violations == SafetyViolation.None) {
            return "Drive is safe to format.";
        }

        var messages = new System.Collections.Generic.List<string>();

        if ((violations & SafetyViolation.IsSystemDrive) != 0) {
            messages.Add("🛑 CRITICAL: This is your SYSTEM DRIVE (contains Windows). Formatting it will destroy your operating system!");
        }

        if ((violations & SafetyViolation.IsSourceDrive) != 0) {
            messages.Add("⚠️ WARNING: This drive contains the ISO file you're trying to burn. Choose a different target.");
        }

        if ((violations & SafetyViolation.TooSmall) != 0) {
            messages.Add("⚠️ WARNING: This drive is unusually small. It may be corrupted.");
        }

        if ((violations & SafetyViolation.IsReadOnly) != 0) {
            messages.Add("⚠️ WARNING: This drive is read-only.");
        }

        return string.Join("\n", messages);
    }

    public bool IsCritical(SafetyViolation violations) {
        return (violations & (SafetyViolation.IsSystemDrive | SafetyViolation.IsSourceDrive)) != 0;
    }
}





======================================
FILE: Infrastructure\DiskManagement\FormatFailedException.cs
======================================

using System;

namespace ProUSB.Infrastructure.DiskManagement;

public class FormatFailedException : Exception
{
    public FormatFailedException(string message) : base(message) { }
    public FormatFailedException(string message, Exception innerException) : base(message, innerException) { }
}




======================================
FILE: Infrastructure\DiskManagement\MountFailedException.cs
======================================

using System;

namespace ProUSB.Infrastructure.DiskManagement;

public class MountFailedException : Exception
{
    public MountFailedException(string message) : base(message) { }
    public MountFailedException(string message, Exception innerException) : base(message, innerException) { }
}




======================================
FILE: Infrastructure\DiskManagement\NativeDiskFormatter.cs
======================================

using System;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Win32.SafeHandles;
using ProUSB.Infrastructure.DiskManagement.Native;
using ProUSB.Services.Logging;
using ProUSB.Domain;
using System.Text;
using System.Collections.Generic;

namespace ProUSB.Infrastructure.DiskManagement;

public class NativeDiskFormatter {
    private readonly FileLogger _log;
    private readonly DriveLockingService _lockService;
    private readonly AutoMountManager _autoMountManager;
    private readonly Lock _lock = new();
    public int VolumeMountDelay { 
        get; 
        set => field = value > 0 ? value : DiskConstants.DefaultMountDelayMs; 
    } = DiskConstants.DefaultMountDelayMs;

    public class FallbackRequiredException : Exception {
        public bool UseGPT { get; }
        public long DiskSize { get; }
        
        public FallbackRequiredException(bool useGPT, long diskSize) {
            UseGPT = useGPT;
            DiskSize = diskSize;
        }
    }

    public NativeDiskFormatter(FileLogger log, LogLevel minLevel = LogLevel.Info) {
        _log = log;
        _log.MinLevel = minLevel;
        _lockService = new DriveLockingService(log);
        _autoMountManager = new AutoMountManager(log);
    }

    public async Task FormatAsync(int diskIndex, string label, string fileSystem, string partitionScheme, int clusterSize, bool quickFormat, CancellationToken ct) {
        _log.Info($"=== NATIVE FORMAT START === Disk {diskIndex}, Label: {label}, FS: {fileSystem}, Scheme: {partitionScheme}");

        _autoMountManager.WithAutoMountDisabled(() => {
            try {
                LockAndDismountVolumes(diskIndex);
                PerformDiskOperation(diskIndex, async (hDrive) => {
                     long diskSize = GetDiskSize(hDrive);
                     CleanDisk(hDrive);
                     bool useGPT = partitionScheme.ToLower().Contains("gpt");
                     InitializeDisk(hDrive, useGPT);
                     CreateSinglePartition(hDrive, useGPT, diskSize);
                     ForceRescan(hDrive);
                }, ct).Wait(ct);
            } catch (Exception ex) {
                _log.Error($"Disk preparation failed: {ex.Message}", ex);
                throw new FormatFailedException("Failed to prepare disk layout", ex);
            }
        });
        
        await Task.Delay(500, ct);
        
        bool useGPT = partitionScheme.ToLower().Contains("gpt");
        int dataPartitionNumber = DiskHelper.GetDataPartitionNumber(useGPT);
        
        long partitionOffset = useGPT ? DiskConstants.GptDataOffset : DiskConstants.MbrDataOffset;
        
        try {
            string volumePath = await WaitForVolume(diskIndex, dataPartitionNumber, partitionOffset, ct);
            
            if (fileSystem.Equals("FAT32", StringComparison.OrdinalIgnoreCase)) {
                _log.Info("FAT32 detected - applying special handling for volume mounting...");
                await FormatVolumeAsync(volumePath, fileSystem, label, quickFormat, clusterSize, ct);
                await ForceVolumeOnlineAndAssignLetter(diskIndex, dataPartitionNumber, ct);
            } else {
                await FormatVolumeAsync(volumePath, fileSystem, label, quickFormat, clusterSize, ct);
            }
        } catch (Exception ex) when (ex is not OperationCanceledException) {
             _log.Error($"Format/Mount failed: {ex.Message}", ex);
             throw new FormatFailedException($"Failed to format/mount volume on disk {diskIndex}", ex);
        }
    }

    private void LockAndDismountVolumes(int diskIndex) {
        _log.Info($"Locking and dismounting volumes on disk {diskIndex}");
        var mounter = new AdvancedVolumeMounter(_log);
        var volumes = mounter.GetVolumesOnDisk(diskIndex);
        foreach (var vol in volumes) {
            _log.Info($"Dismounting {vol}...");
            try {
                using var hVol = NativeMethods.CreateFile(vol, 
                    NativeMethods.GENERIC_READ | NativeMethods.GENERIC_WRITE, 
                    NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE, 
                    IntPtr.Zero, 
                    NativeMethods.OPEN_EXISTING, 
                    0, 
                    IntPtr.Zero);
                
                if (!hVol.IsInvalid) {
                    uint bytesReturned;
                    NativeMethods.DeviceIoControl(hVol, NativeMethods.FSCTL_LOCK_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out bytesReturned, IntPtr.Zero);
                    if (!NativeMethods.DeviceIoControl(hVol, NativeMethods.FSCTL_DISMOUNT_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out bytesReturned, IntPtr.Zero)) {
                        _log.Warn($"Failed to dismount volume {vol}: {Marshal.GetLastWin32Error()}");
                    }
                }
            } catch (Exception ex) {
                _log.Warn($"Error dismounting {vol}: {ex.Message}");
            }
        }
    }

    private async Task PerformDiskOperation(int diskIndex, Func<SafeFileHandle, Task> action, CancellationToken ct) {
        _log.Info($"Opening disk {diskIndex} with robust locking...");
        using var hDrive = _lockService.OpenAndLockDrive(diskIndex, writeAccess: true);
        
        if (hDrive.IsInvalid) {
            throw new InvalidOperationException($"Failed to open and lock disk {diskIndex}");
        }

        await action(hDrive);
    }

    private long GetDiskSize(SafeFileHandle hDrive) {
        var geom = new NativeMethods.DISK_GEOMETRY_EX();
        int size = Marshal.SizeOf(geom);
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try {
            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, IntPtr.Zero, 0, ptr, (uint)size, out _, IntPtr.Zero)) {
                throw new Win32Exception(Marshal.GetLastWin32Error(), "Failed to get disk geometry");
            }
            geom = Marshal.PtrToStructure<NativeMethods.DISK_GEOMETRY_EX>(ptr);
            _log.Info($"Disk size: {geom.DiskSize / (1024*1024*1024)} GB ({geom.DiskSize} bytes)");
            return geom.DiskSize;
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
    }

    private void CleanDisk(SafeFileHandle hDrive) {
        _log.Info("Cleaning disk (Setting to RAW)...");
        var createDisk = new NativeMethods.CREATE_DISK {
            PartitionStyle = (int)NativeMethods.PARTITION_STYLE.RAW,
            Union = new NativeMethods.CREATE_DISK_UNION()
        };

        int size = Marshal.SizeOf(createDisk);
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try {
            Marshal.StructureToPtr(createDisk, ptr, false);
            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_CREATE_DISK, ptr, (uint)size, IntPtr.Zero, 0, out _, IntPtr.Zero)) {
                int err = Marshal.GetLastWin32Error();
                _log.Warn($"Failed to clean disk (IOCTL_DISK_CREATE_DISK RAW): {err}");
            } else {
                _log.Info("Disk cleaned successfully");
            }
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
        NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES, IntPtr.Zero, 0, IntPtr.Zero, 0, out _, IntPtr.Zero);
    }

    public async Task FormatCustomAsync(int diskIndex, List<PartitionDefinition> partitions, CancellationToken ct) {
        _log.Info($"=== NATIVE CUSTOM FORMAT START === Disk {diskIndex}, Partitions: {partitions.Count}");
        long totalDiskSize = 0;

        _autoMountManager.WithAutoMountDisabled(() => {
            try {
                LockAndDismountVolumes(diskIndex);
                PerformDiskOperation(diskIndex, async (hDrive) => {
                     totalDiskSize = GetDiskSize(hDrive);
                     CleanDisk(hDrive);
                     InitializeDisk(hDrive, true); 
                     CreateCustomPartitionLayout(hDrive, partitions, totalDiskSize);
                     ForceRescan(hDrive);
                }, ct).Wait(ct);
            } catch (Exception ex) {
                _log.Error($"Disk preparation failed: {ex.Message}", ex);
                throw new FormatFailedException("Failed to prepare disk layout", ex);
            }
        });
        
        await Task.Delay(1000, ct);

        
        
        long currentOffset = DiskConstants.GptDataOffset; 

        for (int i = 0; i < partitions.Count; i++) {
            var partDef = partitions[i];
            int partitionNumber = i + 2; 
            
            try {
                _log.Info($"Processing Partition {partitionNumber}: {partDef.Label} ({partDef.FileSystem})");
                string volumePath = await WaitForVolume(diskIndex, partitionNumber, currentOffset, ct);
                
                await FormatVolumeAsync(volumePath, partDef.FileSystem, partDef.Label, true, 0, ct);
                
                if (partDef.IsBootable) {
                    
                    
                }

                
                
                
                long sizeBytes = partDef.SizeMB == 0 
                    ? (totalDiskSize - currentOffset - (1024*1024)) 
                    : (partDef.SizeMB * 1024 * 1024);
                
                
                currentOffset += sizeBytes; 

            } catch (Exception ex) {
                _log.Error($"Failed to format partition {partitionNumber}: {ex.Message}");
                
                
                throw;
            }
        }
    }

    private void CreateCustomPartitionLayout(SafeFileHandle hDrive, List<PartitionDefinition> partitions, long diskSize) {
        _log.Info($"Creating custom GPT partition layout with {partitions.Count} user partitions");
        
        var layout = new NativeMethods.DRIVE_LAYOUT_INFORMATION_EX {
            PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.GPT,
            PartitionCount = (uint)(partitions.Count + 1), 
            Union = new NativeMethods.DRIVE_LAYOUT_INFORMATION_UNION()
        };

        layout.Union.Gpt = new NativeMethods.DRIVE_LAYOUT_INFORMATION_GPT {
            DiskId = Guid.NewGuid(),
            StartingUsableOffset = 34 * 512, 
            UsableLength = diskSize - (34 * 512) * 2,
            MaxPartitionCount = 128
        };

        var nativePartitions = new NativeMethods.PARTITION_INFORMATION_EX[partitions.Count + 1];

        
        nativePartitions[0] = new NativeMethods.PARTITION_INFORMATION_EX {
            PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.GPT,
            StartingOffset = 1024 * 1024, 
            PartitionLength = 16 * 1024 * 1024, 
            PartitionNumber = 1,
            RewritePartition = true,
            Union = new NativeMethods.PARTITION_INFORMATION_UNION {
                Gpt = new NativeMethods.PARTITION_INFORMATION_GPT {
                    PartitionType = new Guid("E3C9E316-0B5C-4DB8-817D-F92DF00215AE"), 
                    PartitionId = Guid.NewGuid(),
                    Attributes = 0
                }
            }
        };
        nativePartitions[0].Union.Gpt.SetName("Microsoft Reserved Partition");

        
        long currentOffset = nativePartitions[0].StartingOffset + nativePartitions[0].PartitionLength;
        
        for (int i = 0; i < partitions.Count; i++) {
            var def = partitions[i];
            long sizeBytes = def.SizeMB * 1024 * 1024;
            
            if (def.SizeMB == 0 || i == partitions.Count - 1 && def.SizeMB == 0) {
                
                
                sizeBytes = diskSize - currentOffset - (1024 * 1024);
            }

            nativePartitions[i + 1] = new NativeMethods.PARTITION_INFORMATION_EX {
                PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.GPT,
                StartingOffset = currentOffset,
                PartitionLength = sizeBytes,
                PartitionNumber = (uint)(i + 2),
                RewritePartition = true,
                Union = new NativeMethods.PARTITION_INFORMATION_UNION {
                    Gpt = new NativeMethods.PARTITION_INFORMATION_GPT {
                        PartitionType = new Guid("EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"), 
                        PartitionId = Guid.NewGuid(),
                        Attributes = 0
                    }
                }
            };
            nativePartitions[i + 1].Union.Gpt.SetName(def.Label);
            
            currentOffset += sizeBytes;
        }

        SetDriveLayout(hDrive, layout, nativePartitions);
    }

    private void InitializeDisk(SafeFileHandle hDrive, bool useGPT) {
        _log.Info($"Initializing disk (GPT={useGPT})...");
        var createDisk = new NativeMethods.CREATE_DISK {
            PartitionStyle = useGPT ? (int)NativeMethods.PARTITION_STYLE.GPT : (int)NativeMethods.PARTITION_STYLE.MBR,
            Union = new NativeMethods.CREATE_DISK_UNION()
        };

        if (useGPT) {
            createDisk.Union.Gpt = new NativeMethods.CREATE_DISK_GPT {
                DiskId = Guid.NewGuid(),
                MaxPartitionCount = 128
            };
        } else {
            createDisk.Union.Mbr = new NativeMethods.CREATE_DISK_MBR {
                Signature = (uint)new Random().Next()
            };
        }

        int size = Marshal.SizeOf(createDisk);
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try {
            Marshal.StructureToPtr(createDisk, ptr, false);
            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_CREATE_DISK, ptr, (uint)size, IntPtr.Zero, 0, out _, IntPtr.Zero)) {
                int err = Marshal.GetLastWin32Error();
                _log.Warn($"IOCTL_DISK_CREATE_DISK returned error {err}");
            } else {
                _log.Info("Disk initialized successfully");
            }
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
        NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES, IntPtr.Zero, 0, IntPtr.Zero, 0, out _, IntPtr.Zero);
    }

    private void CreateSinglePartition(SafeFileHandle hDrive, bool useGPT, long diskSize) {
        _log.Info($"Creating partition layout: {(useGPT ? "GPT" : "MBR")}");
        var layout = new NativeMethods.DRIVE_LAYOUT_INFORMATION_EX {
            PartitionStyle = useGPT ? (uint)NativeMethods.PARTITION_STYLE.GPT : (uint)NativeMethods.PARTITION_STYLE.MBR,
            PartitionCount = useGPT ? 2u : 1u,
            Union = new NativeMethods.DRIVE_LAYOUT_INFORMATION_UNION()
        };

        if (useGPT) {
            layout.Union.Gpt = new NativeMethods.DRIVE_LAYOUT_INFORMATION_GPT {
                DiskId = Guid.NewGuid(),
                StartingUsableOffset = 34 * 512, 
                UsableLength = diskSize - (34 * 512) * 2,
                MaxPartitionCount = 128
            };

            var partitions = new NativeMethods.PARTITION_INFORMATION_EX[2];
            var msrPartition = new NativeMethods.PARTITION_INFORMATION_EX {
                PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.GPT,
                StartingOffset = 1024 * 1024, 
                PartitionLength = 16 * 1024 * 1024, 
                PartitionNumber = 1,
                RewritePartition = true,
                Union = new NativeMethods.PARTITION_INFORMATION_UNION {
                    Gpt = new NativeMethods.PARTITION_INFORMATION_GPT {
                        PartitionType = new Guid("E3C9E316-0B5C-4DB8-817D-F92DF00215AE"), 
                        PartitionId = Guid.NewGuid(),
                        Attributes = 0
                    }
                }
            };
            msrPartition.Union.Gpt.SetName("Microsoft Reserved Partition");
            partitions[0] = msrPartition;

            var dataPartition = new NativeMethods.PARTITION_INFORMATION_EX {
                PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.GPT,
                StartingOffset = DiskConstants.GptDataOffset,
                PartitionLength = diskSize - DiskConstants.GptDataOffset - (1024*1024), 
                PartitionNumber = 2,
                RewritePartition = true,
                Union = new NativeMethods.PARTITION_INFORMATION_UNION {
                    Gpt = new NativeMethods.PARTITION_INFORMATION_GPT {
                        PartitionType = new Guid("EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"), 
                        PartitionId = Guid.NewGuid(),
                        Attributes = 0
                    }
                }
            };
            dataPartition.Union.Gpt.SetName("Basic Data Partition");
            partitions[1] = dataPartition;
            SetDriveLayout(hDrive, layout, partitions);
        } else {
            layout.Union.Mbr = new NativeMethods.DRIVE_LAYOUT_INFORMATION_MBR {
                Signature = (uint)new Random().Next()
            };

            var partitions = new NativeMethods.PARTITION_INFORMATION_EX[1];
            partitions[0] = new NativeMethods.PARTITION_INFORMATION_EX {
                PartitionStyle = (uint)NativeMethods.PARTITION_STYLE.MBR,
                StartingOffset = DiskConstants.MbrDataOffset,
                PartitionLength = diskSize - DiskConstants.MbrDataOffset - (1024*1024),
                PartitionNumber = 1,
                RewritePartition = true,
                Union = new NativeMethods.PARTITION_INFORMATION_UNION {
                    Mbr = new NativeMethods.PARTITION_INFORMATION_MBR {
                        PartitionType = 0x07, 
                        BootIndicator = true,
                        RecognizedPartition = true,
                        HiddenSectors = (uint)(DiskConstants.MbrDataOffset / 512)
                    }
                }
            };
            SetDriveLayout(hDrive, layout, partitions);
        }
    }

    private void SetDriveLayout(SafeFileHandle hDrive, NativeMethods.DRIVE_LAYOUT_INFORMATION_EX layout, NativeMethods.PARTITION_INFORMATION_EX[] partitions) {
        int headerSize = Marshal.SizeOf(typeof(NativeMethods.DRIVE_LAYOUT_INFORMATION_EX));
        int partitionSize = Marshal.SizeOf(typeof(NativeMethods.PARTITION_INFORMATION_EX));
        int totalSize = headerSize + (partitions.Length > 0 ? (partitions.Length - 1) * partitionSize : 0);

        _log.Info($"Structure sizes: Header={headerSize}, Partition={partitionSize}");
        _log.Info($"Setting drive layout: TotalSize={totalSize}, PartitionCount={partitions.Length}");

        layout.PartitionCount = (uint)partitions.Length;
        layout.PartitionEntry = new NativeMethods.PARTITION_INFORMATION_EX[1];
        if (partitions.Length > 0) {
            layout.PartitionEntry[0] = partitions[0];
        }

        IntPtr ptr = Marshal.AllocHGlobal(totalSize);
        try {
            for (int i = 0; i < totalSize; i++) {
                Marshal.WriteByte(ptr, i, 0);
            }
            Marshal.StructureToPtr(layout, ptr, false);
            for (int i = 1; i < partitions.Length; i++) {
                IntPtr partitionPtr = new IntPtr(ptr.ToInt64() + headerSize + (i - 1) * partitionSize);
                Marshal.StructureToPtr(partitions[i], partitionPtr, false);
            }

            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_SET_DRIVE_LAYOUT_EX, ptr, (uint)totalSize, IntPtr.Zero, 0, out _, IntPtr.Zero)) {
                int error = Marshal.GetLastWin32Error();
                _log.Error($"SetDriveLayout failed with Win32 error {error}");
                throw new Win32Exception(error, "Failed to set drive layout");
            }
            _log.Info("Drive layout set successfully");
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
        NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES, IntPtr.Zero, 0, IntPtr.Zero, 0, out _, IntPtr.Zero);
    }

    private void ForceRescan(SafeFileHandle hDrive) {
        _log.Info("Step 4: Updating disk properties (Force Rescan)");
        if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES, IntPtr.Zero, 0, IntPtr.Zero, 0, out _, IntPtr.Zero)) {
            int err = Marshal.GetLastWin32Error();
            _log.Warn($"IOCTL_DISK_UPDATE_PROPERTIES returned error {err} (ignoring)");
        }
        
        int size = 4096; 
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try {
            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_GET_DRIVE_LAYOUT_EX, IntPtr.Zero, 0, ptr, (uint)size, out _, IntPtr.Zero)) {
                _log.Warn($"IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed during rescan (ignoring): {Marshal.GetLastWin32Error()}");
            } else {
                _log.Info("Rescan: Successfully read back drive layout");
            }
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
    }

    private async Task<string> WaitForVolume(int diskIndex, int partitionNumber, long partitionOffset, CancellationToken ct) {
        _log.Info($"Waiting for volume on disk {diskIndex} partition {partitionNumber} (offset {partitionOffset})...");
        var mounter = new AdvancedVolumeMounter(_log);

        await mounter.TriggerMultipleRefreshMethods(diskIndex, ct);

        var sw = System.Diagnostics.Stopwatch.StartNew();
        var timeout = TimeSpan.FromSeconds(45);
        int attempt = 0;
        bool triedAssign = false;
        
        while (sw.Elapsed < timeout) {
            ct.ThrowIfCancellationRequested();
            
            string? volumePath = mounter.GetVolumeForPartition(diskIndex, partitionOffset, false);
            if (volumePath != null) {
                _log.Info($"Found volume: {volumePath}");
                return volumePath;
            }
            
            if (sw.Elapsed.TotalSeconds > 5 && !triedAssign) {
                _log.Warn("Volume not appearing after 5s. Forcing drive letter assignment via diskpart...");
                try {
                    await AssignDriveLetterAsync(diskIndex, partitionNumber, ct);
                    await mounter.TriggerMultipleRefreshMethods(diskIndex, ct);
                } catch (Exception ex) {
                    _log.Warn($"Failed to force assign letter: {ex.Message}");
                }
                triedAssign = true;
            }

            attempt++;
            int delay = Math.Min(2000, 100 * (1 << Math.Min(attempt, 6)));
            await Task.Delay(delay, ct);
        }
        throw new MountFailedException($"Volume did not appear after 45 seconds on disk {diskIndex} partition {partitionNumber}");
    }

    private async Task FormatVolumeAsync(string volumePath, string fileSystem, string label, bool quickFormat, int clusterSize, CancellationToken ct) {
        _log.Info($"Step 5: Formatting volume {volumePath} as {fileSystem}, Label: {label}");
        string driveLetter = volumePath.Replace(@"\\.\", "") + "\\";
        
        if (fileSystem.Equals("ext4", StringComparison.OrdinalIgnoreCase)) {
            _log.Warn($"Ext4 formatting requested for {volumePath}. Windows format.com does not support Ext4. Skipping format (Partition created but unformatted).");
            return;
        }

        await Task.Run(() => {
             var psi = new System.Diagnostics.ProcessStartInfo {
                 FileName = "format.com",
                 Arguments = $"{driveLetter.TrimEnd('\\')} /FS:{fileSystem} /V:{label} /Q /Y",
                 UseShellExecute = false,
                 CreateNoWindow = true,
                 RedirectStandardOutput = true,
                 RedirectStandardError = true
             };
             if (clusterSize > 0) {
                 psi.Arguments += $" /A:{clusterSize}";
             }
             _log.Info($"Executing: format.com {psi.Arguments}");
             using var p = System.Diagnostics.Process.Start(psi);
             if (p == null) {
                 throw new FormatFailedException("Failed to start format.com process");
             }
             p.WaitForExit();
             if (p.ExitCode != 0) {
                 string err = p.StandardError.ReadToEnd();
                 string outStr = p.StandardOutput.ReadToEnd();
                 _log.Error($"Format failed: {err}\n{outStr}");
                 throw new FormatFailedException($"Format failed with exit code {p.ExitCode}");
             }
        }, ct);
    }

    private async Task ForceVolumeOnlineAndAssignLetter(int diskIndex, int partitionNumber, CancellationToken ct) {
        _log.Info("=== FORCING VOLUME ONLINE AND DRIVE LETTER ASSIGNMENT ===");
        await Task.Delay(VolumeMountDelay, ct);
        var vdsRefresher = new Vds.VdsPartitionRefresher(_log);
        await vdsRefresher.RefreshPartitionsAsync(ct);
        await Task.Delay(1000, ct);
        
        await AssignDriveLetterAsync(diskIndex, partitionNumber, ct);
        
        await Task.Delay(2000, ct);
        _log.Info("=== VOLUME ASSIGNMENT COMPLETE ===");
    }

    private async Task AssignDriveLetterAsync(int diskIndex, int partitionNumber, CancellationToken ct) {
        _log.Info($"Attempting automatic drive letter assignment via diskpart for Disk {diskIndex} Partition {partitionNumber}...");
        var psi = new System.Diagnostics.ProcessStartInfo {
            FileName = "diskpart.exe",
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        using var proc = System.Diagnostics.Process.Start(psi);
        if (proc != null) {
            await proc.StandardInput.WriteLineAsync("rescan");
            await proc.StandardInput.WriteLineAsync($"select disk {diskIndex}");
            await proc.StandardInput.WriteLineAsync($"select partition {partitionNumber}");
            await proc.StandardInput.WriteLineAsync("assign");
            await proc.StandardInput.WriteLineAsync("exit");
            proc.StandardInput.Close();
            await proc.WaitForExitAsync(ct);
            var output = await proc.StandardOutput.ReadToEndAsync(ct);
            _log.Info($"Diskpart output: {output}");
            if (proc.ExitCode == 0) {
                _log.Info("Drive letter assigned successfully via diskpart");
            } else {
                _log.Warn($"Diskpart exited with code {proc.ExitCode}");
            }
        }
    }
}






======================================
FILE: Infrastructure\DiskManagement\VdsErrorTranslator.cs
======================================

using System;
using System.Collections.Generic;

namespace ProUSB.Infrastructure.DiskManagement;

public static class VdsErrorTranslator {
    private static readonly Dictionary<uint, string> _errorMap = new() {
        { 0x80042400, "The operation is not supported by the object." },
        { 0x80042401, "VDS or the provider failed to initialize." },
        { 0x80042402, "VDS did not call the hardware provider's initialization method." },
        { 0x80042403, "The provider is already registered." },
        { 0x80042404, "A concurrent second call is made on an object before the first call is completed." },
        { 0x80042405, "The specified object was not found." },
        { 0x80042406, "The specified space is neither free nor valid." },
        { 0x80042407, "No more partitions can be created on the specified disk." },
        { 0x80042408, "The extended partition is not empty." },
        { 0x80042409, "The operation is still in progress." },
        { 0x8004240A, "The operation is not permitted on the specified disk, partition, or volume." },
        { 0x8004240B, "The object no longer exists." },
        { 0x8004240C, "The operation can no longer be canceled." },
        { 0x8004240D, "The operation has already been canceled." },
        { 0x8004240E, "The file system does not support extending this volume." },
        { 0x8004240F, "There is not enough space to complete the operation." },
        { 0x80042410, "There are not enough free disk drives in the subsystem to complete the operation." },
        { 0x80042411, "The cookie was not found." },
        { 0x80042412, "There is no removable media in the drive." },
        { 0x80042413, "The device is currently in use." },
        { 0x80042414, "The disk contains partitions or volumes." },
        { 0x80042415, "The specified operation is not valid." },
        { 0x80042416, "The specified path was not found." },
        { 0x80042417, "The specified disk has not been initialized." },
        { 0x80042418, "The specified disk is not an unallocated disk." },
        { 0x80042419, "An unrecoverable error occurred. The service MUST shut down." },
        { 0x0004241A, "The clean operation was not a full clean or was canceled before it could be completed." },
        { 0x8004241B, "The provider failed to connect to the LDMA service." },
        { 0x8004241C, "The provider failed to initialize." },
        { 0x8004241D, "The object already exists." },
        { 0x8004241E, "No disks were found on the target machine." },
        { 0x8004241F, "The cache for a provider is corrupt." },
        { 0x80042420, "A method call to the LDMA service failed." },
        { 0x00042421, "The provider encountered errors while loading the cache." },
        { 0x80042422, "The device form of the volume pathname could not be retrieved." },
        { 0x80042423, "Failed to open the volume device" },
        { 0x80042424, "A corrupt notification was sent from the LDMA service." },
        { 0x80042425, "The file system is incompatible with the specified operation." },
        { 0x80042426, "The media is incompatible with the specified operation." },
        { 0x80042427, "Access is denied. A VDS operation MUST run elevated." },
        { 0x80042428, "The media is write-protected." },
        { 0x80042429, "The volume label is not valid." },
        { 0x8004242A, "The volume cannot be quick-formatted." },
        { 0x8004242B, "An I/O error occurred during the operation." },
        { 0x8004242C, "The volume size is too small." },
        { 0x8004242D, "The volume size is too large." },
        { 0x8004242E, "The cluster size is too small." },
        { 0x8004242F, "The cluster size is too large." },
        { 0x80042430, "The number of clusters is too large to be represented as a 32-bit integer." },
        { 0x80042431, "The component that the object represents has failed." },
        { 0x80042432, "The volume is incomplete." },
        { 0x80042433, "The specified extent size is too small." },
        { 0x00042434, "The operation was successful, but VDS failed to update the boot options." },
        { 0x00042436, "The boot partition's partition number will change as a result of the operation." },
        { 0x80042436, "The boot partition's partition number will change as a result of the operation." },
        { 0x80042437, "The specified disk does not have enough free space to complete the operation." },
        { 0x80042438, "An active partition was detected on the selected disk." },
        { 0x80042439, "The partition information cannot be read." },
        { 0x8004243A, "A partition with an unknown type was detected on the specified disk." },
        { 0x8004243C, "A volume on the specified disk could not be opened." },
        { 0x8004243D, "The volume is not online." },
        { 0x8004243E, "The volume is failing or has failed." },
        { 0x8004243F, "The volume spans multiple disks." },
        { 0x80042440, "The volume does not consist of a single disk extent." },
        { 0x80042441, "A provider returned bad data." },
        { 0x80042442, "A provider failed to complete an operation." },
        { 0x00042443, "The file system was formatted successfully but could not be compressed." },
        { 0x80042444, "The pack is offline." },
        { 0x80042445, "The volume is not a mirror." },
        { 0x80042446, "No extents were found for the volume." },
        { 0x80042447, "The migrated disk failed to load to the cache." },
        { 0x80042448, "VDS encountered an internal error." },
        { 0x8004244A, "The method call is not supported for the specified provider type." },
        { 0x8004244B, "One or more of the specified disks are not online." },
        { 0x8004244C, "One or more extents of the disk are already being used by the volume." },
        { 0x0004244D, "The asynchronous operation is in progress." },
        { 0x8004244E, "Failure initializing the asynchronous object." },
        { 0x8004244F, "The volume is not mounted." },
        { 0x80042450, "The pack was not found." },
        { 0x80042453, "The reference to the object might be stale." },
        { 0x80042454, "The specified disk could not be found." },
        { 0x80042455, "The provider's list of PnP registered disks has become corrupted." },
        { 0x80042457, "The provider does not support the VDS_VF_NO DRIVELETTER volume flag." },
        { 0x80042459, "Some volume flags are already set." },
        { 0x0004245B, "Unable to retrieve the GPT attributes for this volume." },
        { 0x8004245C, "The volume is already dismounted temporarily." },
        { 0x8004245D, "The volume is already permanently dismounted." },
        { 0x8004245E, "The volume cannot be dismounted permanently because it still has an access path." },
        { 0x8004245F, "The operation timed out." },
        { 0x80042461, "The operation timed out in the LDMA service. Retry the operation." },
        { 0x80042462, "The flags to be cleared do not match the flags that were set previously." },
        { 0x80042463, "The operation failed. Retry the operation." },
        { 0x80042464, "The operation failed, because an online pack object already exists." },
        { 0x80042468, "Only the first 2TB are usable on large MBR disks." },
        { 0x80042500, "There are no software providers loaded." },
        { 0x80042501, "The disk is not missing." },
        { 0x80042502, "The volume's layout could not be retrieved." },
        { 0x80042503, "The volume's driver information is corrupted." },
        { 0x80042504, "The enumerator is corrupted" },
        { 0x80042505, "An internal error occurred in the volume management driver." },
        { 0x80042507, "The volume name is not valid." },
        { 0x00042508, "The disk is missing and not all information could be returned." },
        { 0x80042509, "The disk's partition information is corrupted." },
        { 0x0004250A, "The disk's partition information does not conform to what is expected on a dynamic disk." },
        { 0x8004250B, "The disk's extent information is corrupted." },
        { 0x0004250E, "Warning: There was a failure while checking for the system partition." },
        { 0x8004250F, "The PNP service sent a corrupted notification to the provider." },
        { 0x80042510, "No disk/volume arrival notification was received." },
        { 0x80042511, "No disk/volume arrival notification was received." },
        { 0x80042512, "No disk/volume removal notification was received." },
        { 0x80042513, "No disk/volume removal notification was received." },
        { 0x80042514, "The provider is exiting." },
        { 0x00042517, "No volume arrival notification was received." },
        { 0x80042519, "The specified disk is not valid." },
        { 0x8004251A, "The specified disk pack is not valid." },
        { 0x8004251B, "This operation is not allowed on disks with volumes." },
        { 0x8004251C, "The driver returned an invalid parameter error." },
        { 0x8004253D, "The object was not found in the driver cache." },
        { 0x8004253E, "The disk layout contains partitions which are not cylinder aligned." },
        { 0x8004253F, "The disk layout contains partitions which are less than the minimum required size." },
        { 0x80042540, "The I/O to the disk is failing." },
        { 0x80042543, "Invalid GPT attributes were specified." },
        { 0x8004254D, "An unexpected layout change occurred external to the volume manager." },
        { 0x8004254E, "The volume length is invalid." },
        { 0x8004254F, "The volume length is not a multiple of the sector size." },
        { 0x80042550, "The volume does not have a retained partition association." },
        { 0x80042551, "The volume already has a retained partition association." },
        { 0x80042553, "The specified alignment is beyond the first cylinder." },
        { 0x80042554, "The specified alignment is not a multiple of the sector size." },
        { 0x80042555, "The specified partition type cannot be created with a non-zero alignment." },
        { 0x80042556, "The service's cache has become corrupt." },
        { 0x80042557, "The specified volume flag cannot be cleared." },
        { 0x80042558, "The operation is not allowed on a disk that is in the process of being cleaned." },
        { 0x8004255A, "The operation is not supported on removable media." },
        { 0x8004255B, "The operation is not supported on a non-empty removable disk." },
        { 0x8004255C, "The specified drive letter is not free to be assigned." },
        { 0x8004255E, "The specified drive letter is not valid." },
        { 0x8004255F, "The specified number of drive letters to retrieve is not valid." },
        { 0x80042560, "The specified file system flag is not valid." },
        { 0x80042561, "The specified file system is not valid." },
        { 0x80042562, "The specified object type is not valid." },
        { 0x80042563, "The specified partition layout is invalid." },
        { 0x80042564, "VDS only supports MBR or GPT partition style disks." },
        { 0x80042565, "The specified partition type is not valid for this operation." },
        { 0x80042566, "A NULL GUID was passed to the provider." },
        { 0x80042567, "A NULL GUID was passed to the provider." },
        { 0x8004256A, "A NULL GUID was passed to the provider." },
        { 0x80042568, "The specified provider name is invalid." },
        { 0x80042569, "The specified provider type is invalid." },
        { 0x8004256B, "The specified provider version string is invalid." },
        { 0x8004256C, "The specified query provider flag is invalid." },
        { 0x8004256D, "The specified service flag is invalid." },
        { 0x8004256E, "The specified volume flag is invalid." },
        { 0x8004256F, "The operation is only supported on an OEM, ESP, or unknown partition." },
        { 0x80042570, "Cannot delete a protected partition without the force protected parameter set." },
        { 0x80042571, "The specified partition style is not the same as the disk's partition style." },
        { 0x80042572, "An internal error has occurred in the provider." },
        { 0x80042575, "An unrecoverable error occurred in the provider." },
        { 0x80042576, "Cannot assign a mount point to a hidden volume." },
        { 0x00042577, "Failed to dismount/remount the volume after setting the volume flags." },
        { 0x00042578, "Failed to dismount/remount the volume after setting the volume flags." },
        { 0x80042579, "Cannot set the specified flag as revert-on-close because it is already set." },
        { 0x8004257B, "The input volume id cannot be the id of the volume that is the target of the operation." },
        { 0x00042583, "Failed to obtain a file system lock." },
        { 0x80042584, "The volume is read only." },
        { 0x80042585, "The volume type is invalid for this operation." },
        { 0x80042588, "This operation is not supported on a mirrored volume." },
        { 0x80042589, "The operation is only supported on simple or spanned volumes." },
        { 0x8004258C, "The operation is not supported on this type of partitions." },
        { 0x8004258D, "The operation is not supported on this type of partitions." },
        { 0x0004258E, "The boot entries cannot be updated automatically on WinPE." },
        { 0x8004258F, "The alignment is not a power of two." },
        { 0x80042590, "The alignment is zero." },
        { 0x80042593, "The default file system could not be determined." },
        { 0x80042595, "This disk is already online." },
        { 0x80042596, "The online operation failed." },
        { 0x80042597, "The offline operation failed." },
        { 0x80042598, "The operation could not be completed because the specified revision number is not supported." },
        { 0x80042599, "The shrink operation was cancelled by the user." },
        { 0x8004259a, "The volume you have selected to shrink may be corrupted. Use Chkdsk to fix the corruption problem, and then try again." },
        { 0x00042700, "The name was set successfully but had to be truncated." },
        { 0x80042701, "The specified name is not unique." },
        { 0x8004270F, "The disk's path could not be retrieved. Some operations on the disk might fail." },
        { 0x80042711, "The path could not be retrieved for one or more volumes." },
        { 0x80042712, "The provider's cache is not in sync with the driver cache." },
        { 0x80042713, "No import target was set for the subsystem." },
        { 0x00042714, "The object already exists." },
        { 0x00042715, "Some, but not all, of the properties were successfully retrieved." },
        { 0x80042803, "Volume disk extent information could not be retrieved for the boot volume." },
        { 0x80042807, "Disk attributes cannot be changed on the boot disk." },
        { 0x00042808, "One or more of the volumes on the disk could not be mounted/dismounted." },
        { 0x00042809, "One or more of the volumes on the disk could not be mounted/dismounted." },
        { 0x8004280A, "The operation cannot be performed on a disk that is offline or read-only." },
        { 0x8004280B, "The operation cannot be performed on a disk that is offline or read-only." },
        { 0x8004280C, "The operation cannot be performed on a disk that contains a pagefile, hibernation or crashdump volume." },
        { 0x8004280D, "The operation cannot be performed on a disk that contains a pagefile, hibernation or crashdump volume." },
        { 0x8004280E, "The operation cannot be performed on a disk that contains a pagefile, hibernation or crashdump volume." },
        { 0x8004280F, "A system error occurred while retrieving the system disk information." },
        { 0x80042810, "Multiple disk extents reported for the system volume - system error." },
        { 0x80042811, "Disk attributes cannot be changed on the current system disk or BIOS disk 0." },
        { 0x80042823, "The sector size MUST be non-zero, a power of 2, and less than the maximum sector size." },
        { 0x80042907, "The provider returned a NULL subsystem identification string." },
        { 0x8004290C, "A reboot is required before any further operations are initiated." },
        { 0x8004290D, "Volume GUID pathnames are not valid input to this method." },
        { 0x8004290E, "Assigning or removing drive letters on the current boot or pagefile volume is not allowed." },
        { 0x8004290F, "Delete is not allowed on a critical volume." },
        { 0x80042910, "The FORCE parameter MUST be set to TRUE in order to clean a disk that contains a data or OEM volume." },
        { 0x80042911, "The FORCE parameter MUST be set to TRUE in order to clean a disk that contains a data or OEM volume." },
        { 0x80042912, "Clean is not allowed on a critical disk." },
        { 0x80042913, "Format is not allowed on a critical volume." },
        { 0x80042914, "The requested file system format is not supported on this volume." },
        { 0x80042915, "The requested file system format is not supported on this volume." },
        { 0x80042916, "The requested file system format is not supported on this volume." },
        { 0x80042917, "The volume is not formattable." },
        { 0x80042918, "The specified file system does not support compression." }
    };

    public static string GetErrorString(uint errorCode) {
        if (_errorMap.TryGetValue(errorCode, out var message)) {
            return $"[0x{errorCode:X8}] {message}";
        }
        return $"[0x{errorCode:X8}] Unknown VDS Error";
    }
}




======================================
FILE: Infrastructure\Drivers\Windows\WindowsDiskDriver.cs
======================================

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Win32.SafeHandles;
using ProUSB.Domain;
using ProUSB.Domain.Drivers;
using ProUSB.Infrastructure.DiskManagement.Native;

namespace ProUSB.Infrastructure.Drivers.Windows;

public sealed class WindowsDiskDriver : IDiskDriver {
    private readonly FileStream _stream;
    private readonly SafeFileHandle _handle;
    private readonly string _path;
    private readonly int _sectorSize;
    private readonly long _capacity;
    private readonly DeviceBusType _busType;
    private readonly SemaphoreSlim _ioLock = new(1, 1);
    private bool _locked = false;

    internal WindowsDiskDriver(SafeFileHandle h, string p, int ss, long c, DeviceBusType b) {
        _handle=h; _path=p; _sectorSize=ss; _capacity=c; _busType=b;
        _stream = new FileStream(_handle, FileAccess.ReadWrite, _sectorSize, isAsync: true);
    }

    public string PhysicalId => _path;
    public long Capacity => _capacity;
    public int SectorSize => _sectorSize;
    public DeviceBusType BusType => _busType;

    public async Task ExclusiveLockAsync(CancellationToken ct) {
        if(_locked) return;
        await _ioLock.WaitAsync(ct);
        try {
            await Task.Run(() => {
                uint b;
                NativeMethods.DeviceIoControl(_handle, NativeMethods.FSCTL_ALLOW_EXTENDED_DASD_IO, IntPtr.Zero, 0, IntPtr.Zero, 0, out b, IntPtr.Zero);
                NativeMethods.DeviceIoControl(_handle, NativeMethods.FSCTL_DISMOUNT_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out b, IntPtr.Zero);
                if(!NativeMethods.DeviceIoControl(_handle, NativeMethods.FSCTL_LOCK_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out b, IntPtr.Zero))
                    throw new IOException($"Lock Failed: {Marshal.GetLastWin32Error()}");
                _locked = true;
            }, ct);
        } finally { _ioLock.Release(); }
    }

    public async Task UnlockAsync(CancellationToken ct) {
        if(!_locked) return;
        await _ioLock.WaitAsync(ct);
        try {
            await Task.Run(() => {
                uint b;
                NativeMethods.DeviceIoControl(_handle, NativeMethods.FSCTL_UNLOCK_VOLUME, IntPtr.Zero, 0, IntPtr.Zero, 0, out b, IntPtr.Zero);
                NativeMethods.DeviceIoControl(_handle, NativeMethods.IOCTL_DISK_UPDATE_PROPERTIES, IntPtr.Zero, 0, IntPtr.Zero, 0, out b, IntPtr.Zero);
                _locked = false;
            });
        } finally { _ioLock.Release(); }
    }

    public async Task WriteSectorsAsync(long o, byte[] d, CancellationToken ct) {
        if(o%_sectorSize!=0 || d.Length%_sectorSize!=0) throw new ArgumentException("Align Error");
        await _ioLock.WaitAsync(ct);
        try { _stream.Seek(o, SeekOrigin.Begin); await _stream.WriteAsync(d, 0, d.Length, ct); }
        catch (Exception ex) { throw new IOException($"Write IO: {ex.Message}", ex); }
        finally { _ioLock.Release(); }
    }

    public async Task<byte[]> ReadSectorsAsync(long o, int cnt, CancellationToken ct) {
        int len=cnt*_sectorSize;
        if(o%_sectorSize!=0) throw new ArgumentException("Align Error");
        await _ioLock.WaitAsync(ct);
        try {
            _stream.Seek(o, SeekOrigin.Begin);
            byte[] b=new byte[len]; int r=0;
            while(r<len) { int n=await _stream.ReadAsync(b, r, len-r, ct); if(n==0) break; r+=n; }
            if(r!=len) throw new IOException("Short Read");
            return b;
        } finally { _ioLock.Release(); }
    }
    
    public void Dispose() { _stream?.Dispose(); _ioLock?.Dispose(); GC.SuppressFinalize(this); }
    public Task RefreshPartitionTableAsync(CancellationToken ct) => Task.CompletedTask;
}




======================================
FILE: Infrastructure\Drivers\Windows\WindowsDriverFactory.cs
======================================

using System;
using System.Collections.Generic;
using System.Management;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Domain.Drivers;
using ProUSB.Infrastructure.DiskManagement.Native;
namespace ProUSB.Infrastructure.Drivers.Windows;

public class WindowsDriverFactory : IDriverFactory {
    public async Task<IDiskDriver> OpenDriverAsync(string id, bool w, CancellationToken ct) {
        if(!id.StartsWith(@"\\.\PHYSICALDRIVE")) throw new ArgumentException("Bad Path");
        uint acc = w ? (NativeMethods.GENERIC_READ | NativeMethods.GENERIC_WRITE) : NativeMethods.GENERIC_READ;
        uint fl = NativeMethods.FILE_FLAG_NO_BUFFERING | NativeMethods.FILE_FLAG_WRITE_THROUGH | NativeMethods.FILE_FLAG_OVERLAPPED;
        var h = NativeMethods.CreateFile(id, acc, 3, IntPtr.Zero, 3, fl, IntPtr.Zero);
        if(h.IsInvalid) throw new IOException($"Open Fail: {Marshal.GetLastWin32Error()}");
        try { var g=GetG(h); var b=GetB(h); return new WindowsDiskDriver(h, id, (int)g.Geometry.BytesPerSector, g.DiskSize, b); }
        catch { h.Dispose(); throw; }
    }

    [SupportedOSPlatform("windows")]
    public async Task<IEnumerable<UsbDeviceInfo>> EnumerateDevicesAsync(CancellationToken ct) {
        return await Task.Run(() => {
            var l = new List<UsbDeviceInfo>();
            try {
                using var s=new ManagementObjectSearcher(@"SELECT * FROM Win32_DiskDrive WHERE InterfaceType='USB'");
                foreach(ManagementObject d in s.Get()) {
                    ct.ThrowIfCancellationRequested();
                    try {
                        var u = new UsbDeviceInfo{ DeviceId=d["DeviceID"]?.ToString()??"", FriendlyName=d["Caption"]?.ToString()??"", TotalSize=Convert.ToInt64(d["Size"]), BusType="USB", PhysicalIndex=PIdx(d["DeviceID"]?.ToString()) };
                        Resolv(u, u.DeviceId); l.Add(u);
                    } catch {}
                }
            } catch (Exception e) { if(e is UnauthorizedAccessException) throw; }
            return l;
        }, ct);
    }
    
    [SupportedOSPlatform("windows")]
    private void Resolv(UsbDeviceInfo d, string pid) {
        try {
            string q1=$"ASSOCIATORS OF {{Win32_DiskDrive.DeviceID='{pid.Replace("\\","\\\\")}'}} WHERE AssocClass=Win32_DiskDriveToDiskPartition";
            using var s1=new ManagementObjectSearcher(q1);
            foreach(ManagementObject p in s1.Get()) {
                string q2=$"ASSOCIATORS OF {{Win32_DiskPartition.DeviceID='{p["DeviceID"]}'}} WHERE AssocClass=Win32_LogicalDiskToPartition";
                using var s2=new ManagementObjectSearcher(q2);
                foreach(ManagementObject ld in s2.Get()) d.MountPoints.Add(ld["DeviceID"]?.ToString()!);
            }
        } catch {}
    }

    private int PIdx(string? s) => (s!=null && int.TryParse(s.Replace(@"\\.\PHYSICALDRIVE",""),out int i))?i:-1;
    private NativeMethods.DISK_GEOMETRY_EX GetG(Microsoft.Win32.SafeHandles.SafeFileHandle h) {
        int s=Marshal.SizeOf<NativeMethods.DISK_GEOMETRY_EX>(); IntPtr p=Marshal.AllocHGlobal(s);
        try{if(!NativeMethods.DeviceIoControl(h, NativeMethods.IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,IntPtr.Zero,0,p,(uint)s,out _,IntPtr.Zero))throw new IOException("GeomErr");return Marshal.PtrToStructure<NativeMethods.DISK_GEOMETRY_EX>(p);}finally{Marshal.FreeHGlobal(p);}
    }
    private DeviceBusType GetB(Microsoft.Win32.SafeHandles.SafeFileHandle h) {
        int s=Marshal.SizeOf<NativeMethods.STORAGE_PROPERTY_QUERY>(); IntPtr q=Marshal.AllocHGlobal(s); IntPtr o=Marshal.AllocHGlobal(4096);
        try{
            Marshal.StructureToPtr(new NativeMethods.STORAGE_PROPERTY_QUERY(),q,false);
            if(NativeMethods.DeviceIoControl(h, NativeMethods.IOCTL_STORAGE_QUERY_PROPERTY,q,(uint)s,o,4096,out _,IntPtr.Zero)){
                var hd=Marshal.PtrToStructure<NativeMethods.STORAGE_DEVICE_DESCRIPTOR_HEADER>(o);
                if(hd.BusType==7)return DeviceBusType.USB; if(hd.BusType==17)return DeviceBusType.NVMe;
            } return DeviceBusType.Unknown;
        }finally{Marshal.FreeHGlobal(q);Marshal.FreeHGlobal(o);}
    }
}




======================================
FILE: Infrastructure\PortablePathManager.cs
======================================

using System;
using System.IO;
using System.Reflection;

namespace ProUSB.Infrastructure;

public class PortablePathManager {
    private readonly bool _isPortableMode;
    private readonly string _baseDataDirectory;

    public PortablePathManager() {
        _isPortableMode = DetectPortableMode();
        _baseDataDirectory = _isPortableMode ? GetPortableDataDirectory() : GetInstalledDataDirectory();
    }

    public bool IsPortableMode() => _isPortableMode;

    public string GetDataDirectory() => _baseDataDirectory;

    public string GetLogsDirectory() => Path.Combine(_baseDataDirectory, "Logs");

    public string GetProfilesDirectory() => Path.Combine(_baseDataDirectory, "Profiles");

    public string GetConfigDirectory() => Path.Combine(_baseDataDirectory, "Config");

    public void EnsureDirectoriesExist() {
        Directory.CreateDirectory(GetLogsDirectory());
        Directory.CreateDirectory(GetProfilesDirectory());
        Directory.CreateDirectory(GetConfigDirectory());
    }

    private bool DetectPortableMode() {
        try {
            string? exeDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            if (string.IsNullOrEmpty(exeDir)) {
                return false;
            }

            string portableMarker = Path.Combine(exeDir, "portable.txt");
            return File.Exists(portableMarker);
        } catch {
            return false;
        }
    }

    private string GetPortableDataDirectory() {
        string? exeDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        return Path.Combine(exeDir ?? Environment.CurrentDirectory, "Data");
    }

    private string GetInstalledDataDirectory() {
        string appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        return Path.Combine(appDataPath, "ProUSBMediaSuite");
    }
}




======================================
FILE: Resources\os_catalog.json
======================================

{
  "operatingSystems": [
    {
      "id": "windows11_25h2_x64",
      "name": "Windows 11 (25H2)",
      "vendor": "Microsoft",
      "version": "25H2",
      "architecture": "x64",
      "category": "Windows",
      "downloadPageUrl": "https://www.microsoft.com/software-download/windows11",
      "fileSizeBytes": 7516192768,
      "releaseDate": "2025-09-29T00:00:00Z"
    },
    {
      "id": "windows11_24h2_x64",
      "name": "Windows 11 (24H2)",
      "vendor": "Microsoft",
      "version": "24H2",
      "architecture": "x64",
      "category": "Windows",
      "downloadPageUrl": "https://www.microsoft.com/software-download/windows11",
      "fileSizeBytes": 5796675584,
      "releaseDate": "2024-10-01T00:00:00Z"
    },
    {
      "id": "windows11_23h2_x64",
      "name": "Windows 11 (23H2)",
      "vendor": "Microsoft",
      "version": "23H2",
      "architecture": "x64",
      "category": "Windows",
      "downloadPageUrl": "https://www.microsoft.com/software-download/windows11",
      "fileSizeBytes": 6442450944,
      "releaseDate": "2023-10-31T00:00:00Z"
    },
    {
      "id": "windows10_22h2_x64",
      "name": "Windows 10 (22H2)",
      "vendor": "Microsoft",
      "version": "22H2",
      "architecture": "x64",
      "category": "Windows",
      "downloadPageUrl": "https://www.microsoft.com/software-download/windows10",
      "fileSizeBytes": 5987696640,
      "releaseDate": "2022-10-18T00:00:00Z"
    },
    {
      "id": "windows_server_2025_x64",
      "name": "Windows Server 2025",
      "vendor": "Microsoft",
      "version": "2025",
      "architecture": "x64",
      "category": "Windows Server",
      "downloadPageUrl": "https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2025",
      "fileSizeBytes": 5260763136,
      "releaseDate": "2024-11-01T00:00:00Z"
    },
    {
      "id": "macos_sequoia_1572_x64_arm64",
      "name": "macOS Sequoia (15.7.2)",
      "vendor": "Apple",
      "version": "15.7.2",
      "architecture": "x64 / Apple Silicon",
      "category": "macOS",
      "downloadPageUrl": "https://apps.apple.com/app/macos-sequoia/id6596773750",
      "fileSizeBytes": 14548160512,
      "releaseDate": "2024-09-16T00:00:00Z",
      "notes": "InstallAssistant.pkg format - create ISO via Terminal"
    },
    {
      "id": "macos_sonoma_1482_x64_arm64",
      "name": "macOS Sonoma (14.7.6)",
      "vendor": "Apple",
      "version": "14.7.6",
      "architecture": "x64 / Apple Silicon",
      "category": "macOS",
      "downloadPageUrl": "https://apps.apple.com/us/app/macos-sonoma/id6450717509",
      "fileSizeBytes": 12884901888,
      "releaseDate": "2023-09-26T00:00:00Z",
      "notes": "InstallAssistant.pkg format - final version 14.7.6"
    },
    {
      "id": "macos_ventura_1378_x64_arm64",
      "name": "macOS Ventura (13.7.6)",
      "vendor": "Apple",
      "version": "13.7.6",
      "architecture": "x64 / Apple Silicon",
      "category": "macOS",
      "downloadPageUrl": "https://mrmacintosh.com/macos-ventura-13-full-installer-database-download-directly-from-apple/",
      "fileSizeBytes": 12348030976,
      "releaseDate": "2022-10-24T00:00:00Z",
      "notes": "InstallAssistant.pkg format - final version 13.7.6"
    },
    {
      "id": "macos_bigsur_11710_x64_arm64",
      "name": "macOS Big Sur (11.7.10)",
      "vendor": "Apple",
      "version": "11.7.10",
      "architecture": "x64 / Apple Silicon",
      "category": "macOS",
      "downloadPageUrl": "https://mrmacintosh.com/macos-big-sur-full-installer-database-download-directly-from-apple/",
      "fileSizeBytes": 11811160064,
      "releaseDate": "2020-11-12T00:00:00Z",
      "notes": "InstallAssistant.pkg format - final version 11.7.10"
    },
    {
      "id": "ubuntu_2510_desktop_x64",
      "name": "Ubuntu 25.10 Desktop",
      "vendor": "Canonical",
      "version": "25.10",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://releases.ubuntu.com/25.10/ubuntu-25.10-desktop-amd64.iso",
      "fileSizeBytes": 6039797760,
      "releaseDate": "2025-10-16T00:00:00Z"
    },
    {
      "id": "ubuntu_2504_desktop_x64",
      "name": "Ubuntu 25.04 Desktop",
      "vendor": "Canonical",
      "version": "25.04",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://releases.ubuntu.com/25.04/ubuntu-25.04-desktop-amd64.iso",
      "fileSizeBytes": 6442450944,
      "releaseDate": "2025-04-16T00:00:00Z"
    },
    {
      "id": "ubuntu_2404_desktop_x64",
      "name": "Ubuntu 24.04.3 LTS Desktop",
      "vendor": "Canonical",
      "version": "24.04.3 LTS",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://releases.ubuntu.com/24.04/ubuntu-24.04.3-desktop-amd64.iso",
      "fileSizeBytes": 6223306752,
      "releaseDate": "2024-04-25T00:00:00Z"
    },
    {
      "id": "ubuntu_2404_server_x64",
      "name": "Ubuntu 24.04.3 LTS Server",
      "vendor": "Canonical",
      "version": "24.04.3 LTS",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://releases.ubuntu.com/24.04/ubuntu-24.04.3-live-server-amd64.iso",
      "fileSizeBytes": 2792261632,
      "releaseDate": "2024-04-25T00:00:00Z"
    },
    {
      "id": "ubuntu_2204_desktop_x64",
      "name": "Ubuntu 22.04 LTS Desktop",
      "vendor": "Canonical",
      "version": "22.04 LTS",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://releases.ubuntu.com/22.04/ubuntu-22.04.5-desktop-amd64.iso",
      "fileSizeBytes": 5139103744,
      "releaseDate": "2022-04-21T00:00:00Z"
    },
    {
      "id": "fedora_41_workstation_x64",
      "name": "Fedora 41 Workstation",
      "vendor": "Fedora Project",
      "version": "41",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.fedoraproject.org/pub/fedora/linux/releases/41/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-41-1.4.iso",
      "fileSizeBytes": 2469396480,
      "releaseDate": "2024-10-29T00:00:00Z"
    },
    {
      "id": "fedora_40_workstation_x64",
      "name": "Fedora 40 Workstation",
      "vendor": "Fedora Project",
      "version": "40",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.fedoraproject.org/pub/fedora/linux/releases/40/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-40-1.14.iso",
      "fileSizeBytes": 2147483648,
      "releaseDate": "2024-04-16T00:00:00Z"
    },
    {
      "id": "debian_13_x64",
      "name": "Debian 13 (Trixie)",
      "vendor": "Debian",
      "version": "13.0.0",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-13.0.0-amd64-DVD-1.iso",
      "fileSizeBytes": 4099309568,
      "releaseDate": "2025-08-09T00:00:00Z"
    },
    {
      "id": "debian_12_x64",
      "name": "Debian 12 (Bookworm)",
      "vendor": "Debian",
      "version": "12.8.0",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.8.0-amd64-DVD-1.iso",
      "fileSizeBytes": 4009754624,
      "releaseDate": "2023-06-10T00:00:00Z"
    },
    {
      "id": "linuxmint_222_cinnamon_x64",
      "name": "Linux Mint 22.2 Cinnamon",
      "vendor": "Linux Mint",
      "version": "22.2",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://mirrors.edge.kernel.org/linuxmint/stable/22.2/linuxmint-22.2-cinnamon-64bit.iso",
      "fileSizeBytes": 3221225472,
      "releaseDate": "2025-08-21T00:00:00Z"
    },
    {
      "id": "linuxmint_22_cinnamon_x64",
      "name": "Linux Mint 22 Cinnamon",
      "vendor": "Linux Mint",
      "version": "22",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://mirrors.edge.kernel.org/linuxmint/stable/22/linuxmint-22-cinnamon-64bit.iso",
      "fileSizeBytes": 2952790016,
      "releaseDate": "2024-07-16T00:00:00Z"
    },
    {
      "id": "popos_2404_nvidia_x64",
      "name": "Pop!_OS 24.04 LTS (NVIDIA)",
      "vendor": "System76",
      "version": "24.04 LTS",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://iso.pop-os.org/24.04/amd64/nvidia/latest",
      "fileSizeBytes": 3221225472,
      "releaseDate": "2025-12-11T00:00:00Z"
    },
    {
      "id": "popos_2404_intel_x64",
      "name": "Pop!_OS 24.04 LTS (Intel/AMD)",
      "vendor": "System76",
      "version": "24.04 LTS",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://iso.pop-os.org/24.04/amd64/intel/latest",
      "fileSizeBytes": 3110174720,
      "releaseDate": "2025-12-11T00:00:00Z"
    },
    {
      "id": "archlinux_202412_x64",
      "name": "Arch Linux",
      "vendor": "Arch Linux",
      "version": "2024.12.01",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://geo.mirror.pkgbuild.com/iso/2024.12.01/archlinux-2024.12.01-x86_64.iso",
      "fileSizeBytes": 1210089472,
      "releaseDate": "2024-12-01T00:00:00Z"
    },
    {
      "id": "manjaro_250_kde_x64",
      "name": "Manjaro 25.0 KDE Plasma",
      "vendor": "Manjaro",
      "version": "25.0",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.manjaro.org/kde/25.0.10/manjaro-kde-25.0.10-251013-linux612.iso",
      "fileSizeBytes": 4106379264,
      "releaseDate": "2025-10-13T00:00:00Z"
    },
    {
      "id": "manjaro_250_gnome_x64",
      "name": "Manjaro 25.0 GNOME",
      "vendor": "Manjaro",
      "version": "25.0",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.manjaro.org/gnome/25.0.10/manjaro-gnome-25.0.10-251013-linux612.iso",
      "fileSizeBytes": 5798205850,
      "releaseDate": "2025-10-13T00:00:00Z"
    },
    {
      "id": "manjaro_250_xfce_x64",
      "name": "Manjaro 25.0 Xfce",
      "vendor": "Manjaro",
      "version": "25.0",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.manjaro.org/xfce/25.0.10/manjaro-xfce-25.0.10-251013-linux612.iso",
      "fileSizeBytes": 3630136320,
      "releaseDate": "2025-10-13T00:00:00Z"
    },
    {
      "id": "kali_20244_x64",
      "name": "Kali Linux 2024.4",
      "vendor": "Offensive Security",
      "version": "2024.4",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://cdimage.kali.org/kali-2024.4/kali-linux-2024.4-installer-amd64.iso",
      "fileSizeBytes": 4294967296,
      "releaseDate": "2024-12-11T00:00:00Z"
    },
    {
      "id": "rocky_95_x64",
      "name": "Rocky Linux 9.5",
      "vendor": "Rocky Enterprise Software Foundation",
      "version": "9.5",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.rockylinux.org/pub/rocky/9.5/isos/x86_64/Rocky-9.5-x86_64-dvd.iso",
      "fileSizeBytes": 11510087680,
      "releaseDate": "2024-11-18T00:00:00Z"
    },
    {
      "id": "rocky_95_minimal_x64",
      "name": "Rocky Linux 9.5 Minimal",
      "vendor": "Rocky Enterprise Software Foundation",
      "version": "9.5",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://download.rockylinux.org/pub/rocky/9.5/isos/x86_64/Rocky-9.5-x86_64-minimal.iso",
      "fileSizeBytes": 1896153088,
      "releaseDate": "2024-11-18T00:00:00Z"
    },
    {
      "id": "alma_95_x64",
      "name": "AlmaLinux 9.5",
      "vendor": "AlmaLinux OS Foundation",
      "version": "9.5",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://repo.almalinux.org/almalinux/9.5/isos/x86_64/AlmaLinux-9.5-x86_64-dvd.iso",
      "fileSizeBytes": 10737418240,
      "releaseDate": "2024-11-18T00:00:00Z"
    },
    {
      "id": "alma_95_minimal_x64",
      "name": "AlmaLinux 9.5 Minimal",
      "vendor": "AlmaLinux OS Foundation",
      "version": "9.5",
      "architecture": "x64",
      "category": "Linux",
      "directDownloadUrl": "https://repo.almalinux.org/almalinux/9.5/isos/x86_64/AlmaLinux-9.5-x86_64-minimal.iso",
      "fileSizeBytes": 2147483648,
      "releaseDate": "2024-11-18T00:00:00Z"
    },
    {
      "id": "freebsd_142_x64",
      "name": "FreeBSD 14.2",
      "vendor": "FreeBSD Project",
      "version": "14.2",
      "architecture": "x64",
      "category": "BSD",
      "directDownloadUrl": "https://download.freebsd.org/releases/amd64/amd64/ISO-IMAGES/14.2/FreeBSD-14.2-RELEASE-amd64-disc1.iso",
      "fileSizeBytes": 1073741824,
      "releaseDate": "2024-12-03T00:00:00Z"
    },
    {
      "id": "freebsd_141_x64",
      "name": "FreeBSD 14.1",
      "vendor": "FreeBSD Project",
      "version": "14.1",
      "architecture": "x64",
      "category": "BSD",
      "directDownloadUrl": "https://download.freebsd.org/releases/amd64/amd64/ISO-IMAGES/14.1/FreeBSD-14.1-RELEASE-amd64-disc1.iso",
      "fileSizeBytes": 1073741824,
      "releaseDate": "2024-06-04T00:00:00Z"
    },
    {
      "id": "openbsd_78_x64",
      "name": "OpenBSD 7.8",
      "vendor": "OpenBSD Project",
      "version": "7.8",
      "architecture": "x64",
      "category": "BSD",
      "directDownloadUrl": "https://cdn.openbsd.org/pub/OpenBSD/7.8/amd64/install78.iso",
      "fileSizeBytes": 629145600,
      "releaseDate": "2025-10-22T00:00:00Z"
    },
    {
      "id": "openbsd_76_x64",
      "name": "OpenBSD 7.6",
      "vendor": "OpenBSD Project",
      "version": "7.6",
      "architecture": "x64",
      "category": "BSD",
      "directDownloadUrl": "https://cdn.openbsd.org/pub/OpenBSD/7.6/amd64/install76.iso",
      "fileSizeBytes": 629145600,
      "releaseDate": "2024-10-08T00:00:00Z"
    },
    {
      "id": "steamos_36_recovery_x64",
      "name": "SteamOS 3.6 Recovery Image",
      "vendor": "Valve",
      "version": "3.6",
      "architecture": "x64",
      "category": "Gaming Linux",
      "directDownloadUrl": "https://steamdeck-images.steamos.cloud/recovery/",
      "fileSizeBytes": 2684354560,
      "releaseDate": "2024-10-22T00:00:00Z",
      "notes": "Steam Deck recovery/repair image - SteamOS not officially released for generic x86_64 PCs yet"
    },
    {
      "id": "holoiso_community_x64",
      "name": "HoloISO (Community SteamOS Port)",
      "vendor": "Community (Unofficial)",
      "version": "3.0+",
      "architecture": "x64",
      "category": "Gaming Linux",
      "downloadPageUrl": "https://github.com/holoiso-staging/releases",
      "fileSizeBytes": 3758096384,
      "releaseDate": "2024-01-22T00:00:00Z",
      "notes": "Unofficial community port of SteamOS 3.0 Holo for generic x86_64 machines - use with caution"
    }
  ]
}


======================================
FILE: Services\Burn\Strategies\FileSystemDeploymentStrategy.cs
======================================

using System;
using System.Security.Cryptography;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Domain.Drivers;
using ProUSB.Domain.Services;
using ProUSB.Infrastructure.DiskManagement;
using ProUSB.Services.Iso;
using ProUSB.Services.Logging;
using DiscUtils;

namespace ProUSB.Services.Burn.Strategies;

public class FileSystemDeploymentStrategy : IBurnStrategy {
    public BurnStrategy StrategyType => BurnStrategy.FileSystemCopy;
    private readonly IDriverFactory _f;
    private readonly IsoIntegrityVerifier _v;
    private readonly NativeDiskFormatter _dp;
    private readonly FileLogger _log;
    
    public FileSystemDeploymentStrategy(IDriverFactory f, IsoIntegrityVerifier v, NativeDiskFormatter d, FileLogger log) { 
        _f=f;_v=v;_dp=d;_log=log; 
    }

    private string? _mountedDriveLetter;

    public async Task ExecuteAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct) {
        _mountedDriveLetter = null;
        _log.Info("=== FILE SYSTEM DEPLOYMENT START ===");
        ct.ThrowIfCancellationRequested();
        _log.Info($"ISO: {c.SourceIso.FilePath}");
        _log.Info($"Device: {c.TargetDevice.FriendlyName} ({c.TargetDevice.DeviceId})");
        _log.Info($"Partition Scheme: {c.PartitionScheme}, FileSystem: {c.FileSystem}");
        
        _log.Info("Validating ISO file...");
        if(!File.Exists(c.SourceIso.FilePath)) {
            _log.Error($"ISO file not found: {c.SourceIso.FilePath}");
            throw new FileNotFoundException($"ISO file not found: {c.SourceIso.FilePath}");
        }
        
        var isoInfo = new FileInfo(c.SourceIso.FilePath);
        _log.Info($"ISO size: {isoInfo.Length} bytes ({isoInfo.Length/1024.0/1024.0:F2} MB)");
        
        if(!await _v.IsStructureValid(c.SourceIso.FilePath)) {
            _log.Error("ISO file failed validation check");
            throw new Exception("Invalid or corrupted ISO file");
        }
        _log.Info("ISO validation passed");
        
        _log.Info("Starting format operation...");
        p.Report(new WriteStatistics{Message="Formatting"});
        
        if (c.CustomLayout != null && c.CustomLayout.Any()) {
            _log.Info("Custom partition layout detected. Using FormatCustomAsync...");
            await _dp.FormatCustomAsync(c.TargetDevice.PhysicalIndex, c.CustomLayout, ct);
        } else {
            await _dp.FormatAsync(c.TargetDevice.PhysicalIndex, c.VolumeLabel, c.FileSystem, c.PartitionScheme, c.ClusterSize, c.QuickFormat, ct);
        }
        
        ct.ThrowIfCancellationRequested();
        _log.Info("Format completed successfully");
        
        p.Report(new WriteStatistics{Message="Mounting"});
        _log.Info("Mounting volume using advanced multi-API technique...");
        
        var advancedMounter = new ProUSB.Infrastructure.DiskManagement.AdvancedVolumeMounter(_log);
        
        long expectedOffset = DiskHelper.GetExpectedOffset(c.PartitionScheme);

        string? let = null;
        try {
            let = await advancedMounter.WaitForVolumeAsync(
                c.TargetDevice.PhysicalIndex, 
                expectedOffset,
                60,
                ct,
                wildcard: false);
            
            _log.Info($"Volume mounted successfully: {let}");
        } catch (MountFailedException ex) {
            _log.Error($"Advanced volume mounting timeout: {ex.Message}");
            _log.Info("Fallback: Trying legacy enumeration method...");
            
            await Task.Delay(2000, ct);
            var ls=await _f.EnumerateDevicesAsync(ct);
            var d=ls.FirstOrDefault(x=>x.DeviceId==c.TargetDevice.DeviceId);
            if(d?.MountPoints.Any()==true) { 
                let=d.MountPoints[0]; 
                _log.Info($"Legacy enumeration found volume: {let}");
            } else {
                throw new MountFailedException(
                    "USB drive formatted successfully but failed to mount after 60s using both " +
                    "advanced and legacy methods. Please manually assign a drive letter " +
                    "in Disk Management (diskmgmt.msc) or replug the USB drive.", ex);
            }
        }
        _mountedDriveLetter = let;

        p.Report(new WriteStatistics{Message="Extracting"});
        _log.Info("Opening ISO for extraction...");
        
        using var iso = File.OpenRead(c.SourceIso.FilePath);
        DiscUtils.DiscFileSystem r = DiscUtils.Udf.UdfReader.Detect(iso) ? new DiscUtils.Udf.UdfReader(iso) : new DiscUtils.Iso9660.CDReader(iso, true);
        _log.Info($"ISO filesystem type: {(DiscUtils.Udf.UdfReader.Detect(iso) ? "UDF" : "ISO9660")}");
        
        byte[] buf = new byte[4*1024*1024];
        
        _log.Info("Calculating total size...");
        long tot = isoInfo.Length;
        _log.Info($"Total ISO size: {tot} bytes ({tot/1024.0/1024.0:F2} MB)");
        
        long cur=0;
        int copiedFiles = 0;
        
        foreach(var f in r.GetFiles(r.Root.FullName,"*.*",SearchOption.AllDirectories)) {
            ct.ThrowIfCancellationRequested();
            var inf = r.GetFileInfo(f);
            string dst = Path.Combine(let+"\\", f.TrimStart('\\'));
            
            _log.Debug($"Copying: {inf.Name} ({inf.Length} bytes) -> {dst}");
            
            try {
                Directory.CreateDirectory(Path.GetDirectoryName(dst)!);
                
                bool isFat32 = c.FileSystem.Equals("FAT32", StringComparison.OrdinalIgnoreCase);
                if (isFat32 && inf.Length >= 4294967295) {
                    if (inf.Name.EndsWith(".wim", StringComparison.OrdinalIgnoreCase)) {
                        _log.Info($"Large WIM file detected ({inf.Name}) on FAT32. Initiating split operation...");
                        await SplitAndCopyWimAsync(inf, dst, p, ct);
                    } else {
                        throw new IOException($"File {inf.Name} is too large ({inf.Length} bytes) for FAT32 destination and is not a split-able WIM file.");
                    }
                } else {
                    using var si = inf.OpenRead(); 
                    using var so = File.Create(dst);
                    
                    int k; 
                    while((k=await si.ReadAsync(buf,0,buf.Length,ct))>0) {
                        await so.WriteAsync(buf,0,k,ct);
                        cur+=k;
                        double pct = Math.Min(99, (double)cur/tot*100);
                        p.Report(new WriteStatistics{PercentComplete=pct, Message=$"Copying {inf.Name}"});
                    }
                }
                copiedFiles++;
            }
            catch(Exception ex) {
                _log.Error($"Failed to copy file: {inf.Name}", ex);
                throw;
            }
        }
        _log.Info($"File extraction complete. Copied {copiedFiles} files");

        if (c.PersistenceSize > 0) {
            try {
                await CreatePersistenceFileAsync(let, c.PersistenceSize, p, ct);
            } catch (Exception ex) {
                _log.Error($"Failed to create persistence file: {ex.Message}");

            }
        }

        try {
            var patcher = new ProUSB.Domain.Services.IsoPatcher(_log);
            await patcher.PatchAsync(let, ct);
        } catch (Exception ex) {
            _log.Warn($"Linux ISO patching failed (non-fatal): {ex.Message}");
        }
        
        if(c.BypassWin11) { 
            _log.Info("Applying Windows 11 bypass...");
            p.Report(new WriteStatistics{Message="Patching"}); 
            await new Windows11BypassInjector(_log).InjectAsync(let, ct); 
            _log.Info("Windows 11 bypass applied");
        }

        p.Report(new WriteStatistics{Message="Success", PercentComplete=100});
        _log.Info("=== FILE SYSTEM DEPLOYMENT SUCCESS ===");
    }

    private async Task SplitAndCopyWimAsync(DiscFileInfo inf, string dst, IProgress<WriteStatistics> p, CancellationToken ct) {
        string tempFile = Path.GetTempFileName();
        try {
            _log.Info($"Extracting {inf.Name} to temporary location for splitting...");
            p.Report(new WriteStatistics{Message=$"Extracting {inf.Name} for splitting..."});
            
            using (var si = inf.OpenRead())
            using (var so = File.Create(tempFile)) {
                await si.CopyToAsync(so, ct);
            }
            
            string destSwm = Path.ChangeExtension(dst, ".swm");
            _log.Info($"Splitting WIM to {destSwm}...");
            p.Report(new WriteStatistics{Message="Splitting WIM file..."});
            
            var psi = new System.Diagnostics.ProcessStartInfo {
                FileName = "dism.exe",
                Arguments = $"/Split-Image /ImageFile:\"{tempFile}\" /SWMFile:\"{destSwm}\" /FileSize:3800",
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };
            
            using var proc = System.Diagnostics.Process.Start(psi);
            if (proc == null) throw new Exception("Failed to start DISM for splitting");
            
            await proc.WaitForExitAsync(ct);
            
            if (proc.ExitCode != 0) {
                string err = await proc.StandardError.ReadToEndAsync(ct);
                string outStr = await proc.StandardOutput.ReadToEndAsync(ct);
                throw new Exception($"DISM splitting failed: {err}\n{outStr}");
            }
            
            _log.Info("WIM splitting completed successfully");
        } finally {
            if (File.Exists(tempFile)) {
                File.Delete(tempFile);
            }
        }
    }

    public async Task VerifyAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct) {
        _log.Info("=== VERIFICATION PHASE START ===");
        p.Report(new WriteStatistics{Message="Verifying files...", PercentComplete=0});
        
        string? let = _mountedDriveLetter;
        if (string.IsNullOrEmpty(let)) {
            _log.Warn("Cached drive letter missing, attempting to enumerate...");
            var ls = await _f.EnumerateDevicesAsync(ct);
            var d = ls.FirstOrDefault(x => x.DeviceId == c.TargetDevice.DeviceId);
            if (d?.MountPoints.Any() == true) {
                let = d.MountPoints[0];
            } else {
                throw new Exception("Drive not mounted for verification");
            }
        }

        var verificationResult = await VerifyDeployment(let!, c.SourceIso.FilePath, ct);
        
        if (!verificationResult.Success) {
            _log.Error($"Verification failed: {verificationResult.ErrorMessage}");
            throw new Exception($"Verification failed: {verificationResult.ErrorMessage}");
        }
        
        _log.Info($"Verification passed: {verificationResult.FilesVerified} files OK");
        p.Report(new WriteStatistics{Message="Verified", PercentComplete=100});
    }

    private async Task<VerificationResult> VerifyDeployment(string usbRoot, string isoPath, CancellationToken ct)
    {
        try {
            var copiedFiles = GetFilesSafe(usbRoot);
            _log.Info($"Verification: Found {copiedFiles.Count} files on USB");
            
            if (copiedFiles.Count == 0) {
                return new VerificationResult { 
                    Success = false, 
                    ErrorMessage = "No files found on USB drive" 
                };
            }
            
            bool hasBootFiles = copiedFiles.Any(f => 
                Path.GetFileName(f).Contains("boot", StringComparison.OrdinalIgnoreCase) ||
                Path.GetFileName(f).Contains("efi", StringComparison.OrdinalIgnoreCase) ||
                f.EndsWith(".efi", StringComparison.OrdinalIgnoreCase));
            
            if (!hasBootFiles) {
                _log.Warn("No boot files detected - USB may not be bootable");
            }
            
            using var isoStream = File.OpenRead(isoPath);
            var reader = DiscUtils.Udf.UdfReader.Detect(isoStream) 
                ? (DiscUtils.DiscFileSystem)new DiscUtils.Udf.UdfReader(isoStream) 
                : new DiscUtils.Iso9660.CDReader(isoStream, true);
            
            var criticalFiles = new[] { "bootmgr", "bootmgr.efi", "boot.wim", "install.wim", "install.esd" };
            foreach (var critical in criticalFiles) {
                if (reader.FileExists($"\\{critical}") || reader.FileExists($"\\sources\\{critical}")) {
                    string expectedPath = Path.Combine(usbRoot, critical);
                    string sourcesPath = Path.Combine(usbRoot, "sources", critical);
                    
                    if (!File.Exists(expectedPath) && !File.Exists(sourcesPath)) {
                        _log.Warn($"Critical file missing: {critical}");
                    }
                }
            }
            
            long totalSize = copiedFiles.Sum(f => new FileInfo(f).Length);
            _log.Info($"Total copied size: {totalSize / 1024.0 / 1024.0:F2} MB");

            
            string md5Path = Path.Combine(usbRoot, "md5sum.txt");
            if (File.Exists(md5Path)) {
                _log.Info("Found md5sum.txt, performing integrity check...");
                int verifiedCount = await VerifyMd5Sums(md5Path, usbRoot, ct);
                _log.Info($"MD5 integrity check passed for {verifiedCount} files.");
            }
            
            return new VerificationResult { 
                Success = true, 
                FilesVerified = copiedFiles.Count,
                TotalSize = totalSize,
                HasBootFiles = hasBootFiles
            };
        }
        catch (Exception ex) {
            _log.Error("Verification exception", ex);
            return new VerificationResult { 
                Success = false, 
                ErrorMessage = ex.Message 
            };
        }
    }

    private async Task<int> VerifyMd5Sums(string md5Path, string rootDir, CancellationToken ct) {
        var lines = await File.ReadAllLinesAsync(md5Path, ct);
        int count = 0;
        using var md5 = MD5.Create();
        
        foreach (var line in lines) {
            if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#")) continue;
            
            var parts = line.Split(new[] { ' ', '*' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length < 2) continue;
            
            string expectedHash = parts[0];
            string filename = string.Join(" ", parts.Skip(1)).TrimStart('.', '/', '\\').Replace('/', Path.DirectorySeparatorChar);
            string fullPath = Path.Combine(rootDir, filename);
            
            if (!File.Exists(fullPath)) {
                _log.Warn($"Missing file listed in md5sum.txt: {filename}");
                continue;
            }
            
            using var stream = File.OpenRead(fullPath);
            var hashBytes = await md5.ComputeHashAsync(stream, ct);
            var actualHash = Convert.ToHexString(hashBytes);
            
            if (!actualHash.Equals(expectedHash, StringComparison.OrdinalIgnoreCase)) {
                throw new Exception($"MD5 mismatch for {filename}. Expected {expectedHash}, got {actualHash}");
            }
            count++;
        }
        return count;
    }

    private List<string> GetFilesSafe(string root) {
        var files = new List<string>();
        var dirs = new Stack<string>();
        dirs.Push(root);

        while (dirs.Count > 0) {
            string currentDir = dirs.Pop();
            try {
                foreach (var file in Directory.GetFiles(currentDir)) {
                    files.Add(file);
                }
                foreach (var dir in Directory.GetDirectories(currentDir)) {
                    var name = Path.GetFileName(dir);
                    if (name.Equals("System Volume Information", StringComparison.OrdinalIgnoreCase) ||
                        name.Equals("$RECYCLE.BIN", StringComparison.OrdinalIgnoreCase)) {
                        continue;
                    }
                    dirs.Push(dir);
                }
            } catch (UnauthorizedAccessException) {
                _log.Warn($"Skipping inaccessible directory: {currentDir}");
            } catch (Exception ex) {
                _log.Warn($"Error scanning directory {currentDir}: {ex.Message}");
            }
        }
        return files;
    }

    private async Task CreatePersistenceFileAsync(string driveLetter, int sizeMb, IProgress<WriteStatistics> p, CancellationToken ct) {
        _log.Info($"Creating persistence file ({sizeMb} MB)...");
        p.Report(new WriteStatistics{Message="Creating persistence..."});
        
        string path = Path.Combine(driveLetter, "casper-rw");
        long sizeBytes = (long)sizeMb * 1024 * 1024;

        using (var fs = new FileStream(path, FileMode.Create, FileAccess.ReadWrite, FileShare.None)) {
            fs.SetLength(sizeBytes);

            try {
                _log.Info("Attempting to format using WSL (mke2fs)...");
                string wslPath = ConvertToWslPath(path);
                
                var psi = new System.Diagnostics.ProcessStartInfo {
                    FileName = "wsl",
                    Arguments = $"mke2fs -t ext3 -F \"{wslPath}\"",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true
                };
                
                using var proc = System.Diagnostics.Process.Start(psi);
                if (proc == null) throw new Exception("Failed to start WSL");
                
                await proc.WaitForExitAsync(ct);
                
                if (proc.ExitCode != 0) {
                    string err = await proc.StandardError.ReadToEndAsync(ct);
                    _log.Warn($"WSL format failed (Exit {proc.ExitCode}): {err}. Persistence file created but NOT formatted.");
                } else {
                    _log.Info("Persistence file successfully formatted as Ext3 via WSL.");
                }
            } catch (Exception ex) {
                _log.Warn($"WSL format failed: {ex.Message}. Persistence file created but NOT formatted.");
            }
        }
    }

    private string ConvertToWslPath(string winPath) {

        if (string.IsNullOrEmpty(winPath) || winPath.Length < 2 || winPath[1] != ':') return winPath;
        char drive = char.ToLowerInvariant(winPath[0]);
        string path = winPath.Substring(2).Replace('\\', '/');
        return $"/mnt/{drive}{path}";
    }

    private record VerificationResult {
        public bool Success { get; init; }
        public string ErrorMessage { get; init; } = "";
        public int FilesVerified { get; init; }
        public long TotalSize { get; init; }
        public bool HasBootFiles { get; init; }
    }
}






======================================
FILE: Services\Burn\Strategies\RawPipelinedWriteStrategy.cs
======================================

using System;
using System.IO;
using System.Threading.Channels;
using System.Threading.Tasks;
using System.Threading;
using ProUSB.Domain;
using ProUSB.Domain.Drivers;
using ProUSB.Domain.Services;
namespace ProUSB.Services.Burn.Strategies;
public class RawPipelinedWriteStrategy : IBurnStrategy {
    public BurnStrategy StrategyType => BurnStrategy.RawSectorWrite;
    private readonly IDriverFactory _f;
    private const int CH = 4*1024*1024;
    public RawPipelinedWriteStrategy(IDriverFactory f)=>_f=f;
    public async Task ExecuteAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct) {
        using var d = await _f.OpenDriverAsync(c.TargetDevice.DeviceId, true, ct);
        if(new FileInfo(c.SourceIso.FilePath).Length > d.Capacity) throw new Exception("ISO > Device");
        await d.ExclusiveLockAsync(ct);
        try {
            var ch = Channel.CreateBounded<(byte[], int)>(3); var pl = Channel.CreateBounded<byte[]>(3);
            for(int i=0;i<3;i++) await pl.Writer.WriteAsync(new byte[CH], ct);
            long w=0, tot=new FileInfo(c.SourceIso.FilePath).Length;
            var sw=System.Diagnostics.Stopwatch.StartNew();
            var pr = Task.Run(async()=>{
                using var fs=new FileStream(c.SourceIso.FilePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan);
                try{
                    while(true){
                        var b=await pl.Reader.ReadAsync(ct); int r=await fs.ReadAsync(b,0,CH,ct);
                        if(r==0)break;
                        if(r%d.SectorSize!=0){ int al=((r+d.SectorSize-1)/d.SectorSize)*d.SectorSize; Array.Clear(b,r,al-r); r=al;}
                        await ch.Writer.WriteAsync((b,r),ct);
                    }
                } finally { ch.Writer.Complete(); }
            }, ct);
            while(await ch.Reader.WaitToReadAsync(ct)) {
                while(ch.Reader.TryRead(out var it)) {
                    await d.WriteSectorsAsync(w, it.Item1.AsSpan(0,it.Item2).ToArray(), ct);
                    w+=it.Item2; await pl.Writer.WriteAsync(it.Item1, ct);
                    if(sw.ElapsedMilliseconds>500) p.Report(new WriteStatistics{BytesWritten=w,PercentComplete=(double)w/tot*100,Message="Flash"});
                }
            }
            await pr;
            p.Report(new WriteStatistics{BytesWritten=w, PercentComplete=100, Message="Flash"});
        } finally { await d.UnlockAsync(ct); }
        p.Report(new WriteStatistics{Message="Done", PercentComplete=100});
    }
    public async Task VerifyAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct) {
        p.Report(new WriteStatistics{Message="Verifying...", PercentComplete=0});
        using var d = await _f.OpenDriverAsync(c.TargetDevice.DeviceId, false, ct);
        long len = new FileInfo(c.SourceIso.FilePath).Length;
        using var fs = new FileStream(c.SourceIso.FilePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan);
        
        byte[] isoBuf = new byte[4 * 1024 * 1024];
        long offset = 0;
        
        while (offset < len) {
            ct.ThrowIfCancellationRequested();
            int toRead = (int)Math.Min(isoBuf.Length, len - offset);
            int isoRead = await fs.ReadAsync(isoBuf, 0, toRead, ct);
            
            if (isoRead == 0) break;
            
            byte[] diskBuf = await d.ReadSectorsAsync(offset, isoRead, ct);
            
            if (!isoBuf.AsSpan(0, isoRead).SequenceEqual(diskBuf.AsSpan(0, isoRead))) {
                throw new Exception($"Verification failed at offset {offset}. Data mismatch.");
            }
            
            offset += isoRead;
            p.Report(new WriteStatistics{Message="Verifying...", PercentComplete=(double)offset/len*100});
        }
        p.Report(new WriteStatistics{Message="Verified", PercentComplete=100});
    }
}




======================================
FILE: Services\Burn\Strategies\Windows11BypassInjector.cs
======================================

using System.IO;
using System.Threading.Tasks;
using System.Threading;
using ProUSB.Services.Logging;
namespace ProUSB.Services.Burn.Strategies;
public class Windows11BypassInjector {
    private readonly FileLogger _log;
    
    public Windows11BypassInjector(FileLogger log) {
        _log = log;
    }
    
    public async Task InjectAsync(string r, CancellationToken ct) {
        _log.Info($"Injecting Windows 11 bypass to: {r}");
        string x = @"<?xml version=""1.0""?><unattend xmlns=""urn:schemas-microsoft-com:unattend"" xmlns:wcm=""http://schemas.microsoft.com/WmiConfig/2002/State""><settings pass=""windowsPE""><component name=""Microsoft-Windows-Setup"" processorArchitecture=""amd64"" publicKeyToken=""31bf3856ad364e35"" language=""neutral"" versionScope=""nonSxS""><RunSynchronous><RunSynchronousCommand wcm:action=""add""><Order>1</Order><Path>reg add HKLM\SYSTEM\Setup\LabConfig /v BypassTPMCheck /t REG_DWORD /d 1 /f</Path></RunSynchronousCommand><RunSynchronousCommand wcm:action=""add""><Order>2</Order><Path>reg add HKLM\SYSTEM\Setup\LabConfig /v BypassSecureBootCheck /t REG_DWORD /d 1 /f</Path></RunSynchronousCommand><RunSynchronousCommand wcm:action=""add""><Order>3</Order><Path>reg add HKLM\SYSTEM\Setup\LabConfig /v BypassRAMCheck /t REG_DWORD /d 1 /f</Path></RunSynchronousCommand></RunSynchronous></component></settings></unattend>";
        var path = Path.Combine(r, "autounattend.xml");
        await File.WriteAllTextAsync(path, x, ct);
        _log.Info($"Created autounattend.xml at: {path}");
    }
}





======================================
FILE: Services\Burn\MultiDeviceBurnOrchestrator.cs
======================================

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.Burn;

public class MultiDeviceBurnOrchestrator {
    private readonly ParallelBurnService _burnService;
    private readonly FileLogger _logger;
    private const int MaxConcurrentBurns = 3;
    
    public MultiDeviceBurnOrchestrator(ParallelBurnService burnService, FileLogger logger) {
        _burnService = burnService;
        _logger = logger;
    }
    
    public async Task BurnMultipleAsync(
        List<UsbDeviceInfo> devices,
        string isoPath,
        DeploymentConfiguration baseConfig,
        Action<string, double, string> progressCallback,
        CancellationToken ct
    ) {
        if(devices.Count == 0) {
            throw new ArgumentException("No devices provided", nameof(devices));
        }
        
        _logger.Info($"Starting multi-device burn for {devices.Count} device(s)");
        
        var results = new ConcurrentBag<BurnResult>();
        var semaphore = new SemaphoreSlim(MaxConcurrentBurns);
        
        var tasks = devices.Select(async device => {
            await semaphore.WaitAsync(ct);
            try {
                _logger.Info($"Starting burn for {device.FriendlyName}");
                progressCallback(device.DeviceId, 0, "Starting...");
                
                var config = new DeploymentConfiguration {
                    JobName = $"Burn-{device.DeviceId}",
                    TargetDevice = device,
                    SourceIso = baseConfig.SourceIso,
                    Strategy = baseConfig.Strategy,
                    PartitionScheme = baseConfig.PartitionScheme,
                    FileSystem = baseConfig.FileSystem,
                    ClusterSize = baseConfig.ClusterSize,
                    QuickFormat = baseConfig.QuickFormat,
                    BypassWin11 = baseConfig.BypassWin11,
                    PersistenceSize = baseConfig.PersistenceSize
                };
                
                var progress = new Progress<WriteStatistics>(stats => {
                    progressCallback(device.DeviceId, stats.PercentComplete, stats.Message);
                });
                
                await _burnService.BurnAsync(config, progress, ct);
                
                results.Add(new BurnResult {
                    Device = device,
                    Success = true,
                    Message = "Completed successfully"
                });
                
                progressCallback(device.DeviceId, 100, "✅ Complete");
                _logger.Info($"Burn completed successfully for {device.FriendlyName}");
            }
            catch(OperationCanceledException) {
                results.Add(new BurnResult {
                    Device = device,
                    Success = false,
                    Message = "Cancelled by user"
                });
                progressCallback(device.DeviceId, 0, "⚠️ Cancelled");
                _logger.Warn($"Burn cancelled for {device.FriendlyName}");
            }
            catch(Exception ex) {
                results.Add(new BurnResult {
                    Device = device,
                    Success = false,
                    Message = ex.Message
                });
                
                progressCallback(device.DeviceId, 0, $"❌ Failed");
                _logger.Error($"Burn failed for {device.FriendlyName}: {ex.Message}");
            }
            finally {
                semaphore.Release();
            }
        });
        
        await Task.WhenAll(tasks);
        
        LogSummary(results.ToList());
    }
    
    public async Task BurnBatchAsync(
        List<BurnJob> jobs,
        Action<string, double, string> progressCallback,
        CancellationToken ct
    ) {
        if(jobs.Count == 0) throw new ArgumentException("No jobs provided", nameof(jobs));

        _logger.Info($"Starting batch burn for {jobs.Count} job(s)");
        
        var results = new ConcurrentBag<BurnResult>();
        var semaphore = new SemaphoreSlim(MaxConcurrentBurns);

        var tasks = jobs.Select(async job => {
            await semaphore.WaitAsync(ct);
            try {
                _logger.Info($"Starting batch job for {job.Device.FriendlyName} with ISO {Path.GetFileName(job.IsoPath)}");
                progressCallback(job.Device.DeviceId, 0, "Starting...");

                var progress = new Progress<WriteStatistics>(stats => {
                    progressCallback(job.Device.DeviceId, stats.PercentComplete, stats.Message);
                });

                await _burnService.BurnAsync(job.Config, progress, ct);

                results.Add(new BurnResult {
                    Device = job.Device,
                    Success = true,
                    Message = "Completed successfully"
                });

                progressCallback(job.Device.DeviceId, 100, "✅ Complete");
                _logger.Info($"Batch job completed for {job.Device.FriendlyName}");
            }
            catch(OperationCanceledException) {
                results.Add(new BurnResult {
                    Device = job.Device,
                    Success = false,
                    Message = "Cancelled by user"
                });
                progressCallback(job.Device.DeviceId, 0, "⚠️ Cancelled");
            }
            catch(Exception ex) {
                results.Add(new BurnResult {
                    Device = job.Device,
                    Success = false,
                    Message = ex.Message
                });
                progressCallback(job.Device.DeviceId, 0, "❌ Failed");
                _logger.Error($"Batch job failed for {job.Device.FriendlyName}: {ex.Message}");
            }
            finally {
                semaphore.Release();
            }
        });

        await Task.WhenAll(tasks);
        LogSummary(results.ToList());
    }

    private void LogSummary(List<BurnResult> results) {
        var successful = results.Count(r => r.Success);
        var failed = results.Count(r => !r.Success);
        
        _logger.Info($"=== Burn Summary ===");
        _logger.Info($"Total: {results.Count} | Success: {successful} | Failed: {failed}");
        
        if(failed > 0) {
            _logger.Info("Failed devices:");
            foreach(var result in results.Where(r => !r.Success)) {
                _logger.Error($"  • {result.Device.FriendlyName}: {result.Message}");
            }
        }
    }
    
    public record BurnResult {
        public required UsbDeviceInfo Device { get; init; }
        public required bool Success { get; init; }
        public required string Message { get; init; }
    }
}





======================================
FILE: Services\Burn\ParallelBurnService.cs
======================================

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Domain.Services;
using ProUSB.Domain.Drivers;
using ProUSB.Infrastructure.DiskManagement;
using ProUSB.Services.Logging;

namespace ProUSB.Services.Burn;

public class ParallelBurnService {
    private readonly IEnumerable<IBurnStrategy> _s;
    private readonly ISafetyGuard _g;
    private readonly IDriverFactory _f;
    private readonly DriveSafetyValidator _safetyValidator;
    private readonly FileLogger _log;
    
    public ParallelBurnService(IEnumerable<IBurnStrategy> s, ISafetyGuard g, IDriverFactory f, FileLogger log) {
        _s = s;
        _g = g;
        _f = f;
        _log = log;
        _safetyValidator = new DriveSafetyValidator(log);
    }
    
    public async Task BurnAsync(DeploymentConfiguration c, IProgress<WriteStatistics> p, CancellationToken ct) {
        var list = await _f.EnumerateDevicesAsync(ct);
        var fresh = list.FirstOrDefault(x => x.DeviceId == c.TargetDevice.DeviceId) 
            ?? throw new Exception("Missing Device");

        var safetyViolations = _safetyValidator.ValidateDrive(fresh, c.SourceIso.FilePath);
        if (safetyViolations != DriveSafetyValidator.SafetyViolation.None) {
            string message = _safetyValidator.GetViolationMessage(safetyViolations);
            _log.Error(message);
            
            if (_safetyValidator.IsCritical(safetyViolations)) {
                throw new InvalidOperationException($"SAFETY VIOLATION: Cannot proceed.\n{message}");
            }
        }

        var r = _g.EvaluateRisk(fresh);
        if (r == DeviceRiskLevel.Critical || r == DeviceRiskLevel.SystemLockdown) 
            throw new Exception($"Risk Block: {r}");
        
        var e = _s.FirstOrDefault(x => x.StrategyType == c.Strategy) 
            ?? throw new Exception("Missing Engine");
        
        await e.ExecuteAsync(c, p, ct);
        await e.VerifyAsync(c, p, ct);
    }
}




======================================
FILE: Services\Crypto\ChecksumCalculator.cs
======================================

using System;
using System.IO;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Services.Logging;

namespace ProUSB.Services.Crypto;

public enum HashAlgorithmType {
    MD5,
    SHA1,
    SHA256
}

public record ChecksumResult {
    public string Hash { get; init; } = "";
    public HashAlgorithmType Algorithm { get; init; }
    public long BytesProcessed { get; init; }
    public TimeSpan Duration { get; init; }
}

public class ChecksumCalculator {
    private readonly FileLogger _log;

    public ChecksumCalculator(FileLogger log) {
        _log = log;
    }

    public async Task<ChecksumResult> CalculateAsync(
        string filePath, 
        HashAlgorithmType algorithm,
        IProgress<double>? progress,
        CancellationToken ct) {

        _log.Info($"Calculating {algorithm} checksum for: {filePath}");
        var startTime = DateTime.UtcNow;

        try {
            using var stream = File.OpenRead(filePath);
            using var hashAlgorithm = CreateHashAlgorithm(algorithm);

            long totalBytes = stream.Length;
            long bytesRead = 0;
            byte[] buffer = new byte[8192];
            int read;

            while ((read = await stream.ReadAsync(buffer, 0, buffer.Length, ct)) > 0) {
                hashAlgorithm.TransformBlock(buffer, 0, read, null, 0);
                bytesRead += read;

                progress?.Report((double)bytesRead / totalBytes * 100);
            }

            hashAlgorithm.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
            
            string hash = Convert.ToHexString(hashAlgorithm.Hash!).ToLowerInvariant();

            var duration = DateTime.UtcNow - startTime;
            _log.Info($"{algorithm} checksum: {hash} (calculated in {duration.TotalSeconds:F2}s)");

            return new ChecksumResult {
                Hash = hash,
                Algorithm = algorithm,
                BytesProcessed = bytesRead,
                Duration = duration
            };

        } catch (Exception ex) {
            _log.Error($"Checksum calculation failed: {ex.Message}", ex);
            throw;
        }
    }

    public async Task<bool> VerifyAsync(
        string filePath,
        string expectedHash,
        HashAlgorithmType algorithm,
        CancellationToken ct) {

        var result = await CalculateAsync(filePath, algorithm, null, ct);
        bool matches = string.Equals(result.Hash, expectedHash, StringComparison.OrdinalIgnoreCase);

        if (matches) {
            _log.Info("Checksum verification PASSED");
        } else {
            _log.Warn($"Checksum verification FAILED - Expected: {expectedHash}, Got: {result.Hash}");
        }

        return matches;
    }

    private HashAlgorithm CreateHashAlgorithm(HashAlgorithmType type) {
        return type switch {
            HashAlgorithmType.MD5 => MD5.Create(),
            HashAlgorithmType.SHA1 => SHA1.Create(),
            HashAlgorithmType.SHA256 => SHA256.Create(),
            _ => throw new ArgumentException($"Unsupported algorithm: {type}")
        };
    }
}





======================================
FILE: Services\DeviceManagement\DeviceNamingService.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;
using ProUSB.Infrastructure;

namespace ProUSB.Services.DeviceManagement;

public record DeviceNameMapping {
    public required string DeviceId { get; init; }
    public required string CustomName { get; init; }
    public DateTime LastUsed { get; init; } = DateTime.Now;
    public int UseCount { get; init; } = 0;
}

public class DeviceNamingService {
    private readonly string _mappingsPath;
    private readonly Dictionary<string, DeviceNameMapping> _mappings = [];

    public DeviceNamingService(PortablePathManager pathManager) {
        string dataDir = pathManager.GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        _mappingsPath = Path.Combine(dataDir, "device_names.json");
        _ = LoadMappingsAsync();
    }

    public string GetDeviceName(string deviceId, string defaultName) =>
        _mappings.TryGetValue(deviceId, out var mapping) ? mapping.CustomName : defaultName;

    public async Task SetDeviceNameAsync(string deviceId, string customName) {
        if (_mappings.TryGetValue(deviceId, out var existing)) {
            _mappings[deviceId] = existing with {
                CustomName = customName,
                LastUsed = DateTime.Now,
                UseCount = existing.UseCount + 1
            };
        } else {
            _mappings[deviceId] = new DeviceNameMapping {
                DeviceId = deviceId,
                CustomName = customName,
                LastUsed = DateTime.Now,
                UseCount = 1
            };
        }
        
        await SaveMappingsAsync();
    }

    public async Task RemoveDeviceNameAsync(string deviceId) {
        _mappings.Remove(deviceId);
        await SaveMappingsAsync();
    }

    public List<DeviceNameMapping> GetAllMappings() => [.. _mappings.Values];

    public List<DeviceNameMapping> GetRecentDevices(int limit = 10) =>
        [.. _mappings.Values.OrderByDescending(m => m.LastUsed).Take(limit)];

    private async Task LoadMappingsAsync() {
        try {
            if (File.Exists(_mappingsPath)) {
                var json = await File.ReadAllTextAsync(_mappingsPath);
                var loaded = JsonSerializer.Deserialize<List<DeviceNameMapping>>(json);
                if (loaded != null) {
                    foreach (var mapping in loaded) {
                        _mappings[mapping.DeviceId] = mapping;
                    }
                }
            }
        } catch { }
    }

    private async Task SaveMappingsAsync() {
        try {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(_mappings.Values, options);
            await File.WriteAllTextAsync(_mappingsPath, json);
        } catch { }
    }
}





======================================
FILE: Services\Diagnostics\BadBlockChecker.cs
======================================

using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Win32.SafeHandles;
using ProUSB.Domain;
using ProUSB.Infrastructure.DiskManagement.Native;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace ProUSB.Services.Diagnostics;

public class BadBlockChecker {
    private const int BlockSize = 512 * 1024;
    private const byte Pattern = 0x55;

    public async Task CheckDiskAsync(int diskIndex, IProgress<double> progress, CancellationToken ct) {
        string drivePath = $@"\\.\PhysicalDrive{diskIndex}";
        
        using var hDrive = NativeMethods.CreateFile(
            drivePath,
            NativeMethods.GENERIC_READ | NativeMethods.GENERIC_WRITE,
            NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE,
            IntPtr.Zero,
            NativeMethods.OPEN_EXISTING,
            NativeMethods.FILE_FLAG_NO_BUFFERING | NativeMethods.FILE_FLAG_WRITE_THROUGH,
            IntPtr.Zero);

        if (hDrive.IsInvalid) {
            throw new Win32Exception(Marshal.GetLastWin32Error(), "Failed to open disk for bad block check");
        }

        long diskSize = GetDiskSize(hDrive);
        long totalBlocks = diskSize / BlockSize;
        
        byte[] writeBuffer = new byte[BlockSize];
        for(int i=0; i<writeBuffer.Length; i++) writeBuffer[i] = Pattern;
        
        byte[] readBuffer = new byte[BlockSize];
        IntPtr writePtr = Marshal.AllocHGlobal(BlockSize);
        IntPtr readPtr = Marshal.AllocHGlobal(BlockSize);

        try {
            Marshal.Copy(writeBuffer, 0, writePtr, BlockSize);

            for (long i = 0; i < totalBlocks; i++) {
                ct.ThrowIfCancellationRequested();
                
                long offset = i * BlockSize;
                if (!NativeMethods.SetFilePointerEx(hDrive, offset, IntPtr.Zero, 0))
                    throw new Win32Exception(Marshal.GetLastWin32Error());

                if (!NativeMethods.WriteFile(hDrive, writePtr, (uint)BlockSize, out _, IntPtr.Zero))
                    throw new Win32Exception(Marshal.GetLastWin32Error(), $"Write failed at block {i}");

                progress?.Report((double)i / totalBlocks * 50.0);
            }

            for (long i = 0; i < totalBlocks; i++) {
                ct.ThrowIfCancellationRequested();
                
                long offset = i * BlockSize;
                if (!NativeMethods.SetFilePointerEx(hDrive, offset, IntPtr.Zero, 0))
                    throw new Win32Exception(Marshal.GetLastWin32Error());

                if (!NativeMethods.ReadFile(hDrive, readPtr, (uint)BlockSize, out uint read, IntPtr.Zero))
                    throw new Win32Exception(Marshal.GetLastWin32Error(), $"Read failed at block {i}");

                if (read != BlockSize) throw new Exception($"Incomplete read at block {i}");

                Marshal.Copy(readPtr, readBuffer, 0, BlockSize);
                
                for(int j=0; j<BlockSize; j++) {
                    if (readBuffer[j] != Pattern)
                        throw new Exception($"Bad block detected at offset {offset + j}");
                }

                progress?.Report(50.0 + ((double)i / totalBlocks * 50.0));
            }
        } finally {
            Marshal.FreeHGlobal(writePtr);
            Marshal.FreeHGlobal(readPtr);
        }
    }

    private long GetDiskSize(SafeFileHandle hDrive) {
        var geom = new NativeMethods.DISK_GEOMETRY_EX();
        int size = Marshal.SizeOf(geom);
        IntPtr ptr = Marshal.AllocHGlobal(size);
        try {
            if (!NativeMethods.DeviceIoControl(hDrive, NativeMethods.IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, IntPtr.Zero, 0, ptr, (uint)size, out _, IntPtr.Zero)) {
                throw new Win32Exception(Marshal.GetLastWin32Error());
            }
            geom = Marshal.PtrToStructure<NativeMethods.DISK_GEOMETRY_EX>(ptr);
            return geom.DiskSize;
        } finally {
            Marshal.FreeHGlobal(ptr);
        }
    }
}





======================================
FILE: Services\Diagnostics\SmartHealthChecker.cs
======================================

using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Services.Logging;
using ProUSB.Domain;

namespace ProUSB.Services.Diagnostics;

public enum DriveHealthStatus {
    Unknown,
    Healthy,
    Warning,
    Critical,
    Failing
}

public record SmartHealthReport {
    public DriveHealthStatus Status { get; init; }
    public int HealthScore { get; init; }
    public long ReallocatedSectorsCount { get; init; }
    public long CurrentPendingSectorCount { get; init; }
    public long UncorrectableSectorCount { get; init; }
    public int Temperature { get; init; }
    public string Message { get; init; } = "";
}

public class SmartHealthChecker {
    private readonly FileLogger _log;

    public SmartHealthChecker(FileLogger log, LogLevel minLevel = LogLevel.Info) {
        _log = log;
        _log.MinLevel = minLevel;
    }

    public async Task<SmartHealthReport> CheckDriveHealthAsync(int diskIndex, CancellationToken ct) {
        return await Task.Run(() => CheckDriveHealth(diskIndex), ct);
    }

    private SmartHealthReport CheckDriveHealth(int diskIndex) {
        _log.Info($"Checking SMART health for disk {diskIndex}...");

        try {
            using var hDrive = NativeMethods.CreateFile(
                $@"\\.\PhysicalDrive{diskIndex}",
                NativeMethods.GENERIC_READ | NativeMethods.GENERIC_WRITE,
                NativeMethods.FILE_SHARE_READ | NativeMethods.FILE_SHARE_WRITE,
                IntPtr.Zero,
                NativeMethods.OPEN_EXISTING,
                0,
                IntPtr.Zero);

            if (hDrive.IsInvalid) {
                _log.Warn("Cannot open drive for SMART check");
                return new SmartHealthReport {
                    Status = DriveHealthStatus.Unknown,
                    Message = "Unable to access drive for health check"
                };
            }

            var smartData = ReadSmartData(hDrive);
            if (smartData == null) {
                _log.Info("SMART not available for this drive");
                return new SmartHealthReport {
                    Status = DriveHealthStatus.Unknown,
                    Message = "SMART not supported on this device (likely USB flash drive)"
                };
            }

            var report = AnalyzeSmartData(smartData);
            _log.Info($"SMART health: {report.Status}, Score: {report.HealthScore}");
            return report;

        } catch (Exception ex) {
            _log.Error($"SMART check failed: {ex.Message}", ex);
            throw new SmartHealthException($"SMART check failed: {ex.Message}", ex);
        }
    }

    private byte[]? ReadSmartData(SafeFileHandle hDrive) {
        const uint IOCTL_ATA_PASS_THROUGH = 0x0004D02C;
        const uint ATA_FLAGS_DATA_IN = 0x02;

        var ataPassThrough = new ATA_PASS_THROUGH_EX {
            Length = (ushort)Marshal.SizeOf<ATA_PASS_THROUGH_EX>(),
            AtaFlags = (ushort)ATA_FLAGS_DATA_IN,
            DataTransferLength = 512,
            TimeOutValue = 3,
            DataBufferOffset = (IntPtr)Marshal.SizeOf<ATA_PASS_THROUGH_EX>(),
            CurrentTaskFile = new byte[8]
        };

        ataPassThrough.CurrentTaskFile[6] = 0xB0;
        ataPassThrough.CurrentTaskFile[1] = 0xD0;
        ataPassThrough.CurrentTaskFile[2] = 0x01;
        ataPassThrough.CurrentTaskFile[3] = 0x00;
        ataPassThrough.CurrentTaskFile[4] = 0x4F;
        ataPassThrough.CurrentTaskFile[5] = 0xC2;

        int bufferSize = Marshal.SizeOf<ATA_PASS_THROUGH_EX>() + 512;
        IntPtr buffer = Marshal.AllocHGlobal(bufferSize);

        try {
            Marshal.StructureToPtr(ataPassThrough, buffer, false);

            bool success = NativeMethods.DeviceIoControl(
                hDrive,
                IOCTL_ATA_PASS_THROUGH,
                buffer,
                (uint)bufferSize,
                buffer,
                (uint)bufferSize,
                out uint bytesReturned,
                IntPtr.Zero);

            if (!success) {
                return null;
            }

            byte[] smartData = new byte[512];
            IntPtr dataPtr = IntPtr.Add(buffer, Marshal.SizeOf<ATA_PASS_THROUGH_EX>());
            Marshal.Copy(dataPtr, smartData, 0, 512);

            return smartData;

        } finally {
            Marshal.FreeHGlobal(buffer);
        }
    }

    private SmartHealthReport AnalyzeSmartData(byte[] data) {
        long reallocated = 0;
        long pending = 0;
        long uncorrectable = 0;
        int temperature = 0;

        for (int i = 2; i < 362; i += 12) {
            byte id = data[i];
            ushort raw = BitConverter.ToUInt16(data, i + 5);

            switch (id) {
                case 5:
                    reallocated = raw;
                    break;
                case 196:
                    pending = raw;
                    break;
                case 198:
                case 197:
                    uncorrectable = raw;
                    break;
                case 194:
                    temperature = raw;
                    break;
            }
        }

        int healthScore = 100;
        var status = DriveHealthStatus.Healthy;
        string message = "Drive health is good";

        if (reallocated > 0) {
            healthScore -= (int)(reallocated * 5);
            status = DriveHealthStatus.Warning;
            message = $"Warning: {reallocated} reallocated sectors detected";
        }

        if (pending > 0) {
            healthScore -= (int)(pending * 10);
            status = DriveHealthStatus.Critical;
            message = $"Critical: {pending} pending sectors detected";
        }

        if (uncorrectable > 0) {
            healthScore -= (int)(uncorrectable * 15);
            status = DriveHealthStatus.Failing;
            message = $"Drive failing: {uncorrectable} uncorrectable errors";
        }

        if (temperature > 60) {
            healthScore -= (temperature - 60) * 2;
            if (status == DriveHealthStatus.Healthy) {
                status = DriveHealthStatus.Warning;
                message = $"Drive temperature high: {temperature}°C";
            }
        }

        healthScore = Math.Max(0, healthScore);

        return new SmartHealthReport {
            Status = status,
            HealthScore = healthScore,
            ReallocatedSectorsCount = reallocated,
            CurrentPendingSectorCount = pending,
            UncorrectableSectorCount = uncorrectable,
            Temperature = temperature,
            Message = message
        };
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct ATA_PASS_THROUGH_EX {
        public ushort Length;
        public ushort AtaFlags;
        public byte PathId;
        public byte TargetId;
        public byte Lun;
        public byte ReservedAsUchar;
        public uint DataTransferLength;
        public uint TimeOutValue;
        public uint ReservedAsUlong;
        public IntPtr DataBufferOffset;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] PreviousTaskFile;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] CurrentTaskFile;
    }

    private static class NativeMethods {
        public const uint GENERIC_READ = 0x80000000;
        public const uint GENERIC_WRITE = 0x40000000;
        public const uint FILE_SHARE_READ = 0x00000001;
        public const uint FILE_SHARE_WRITE = 0x00000002;
        public const uint OPEN_EXISTING = 3;

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern SafeFileHandle CreateFile(
            string lpFileName,
            uint dwDesiredAccess,
            uint dwShareMode,
            IntPtr lpSecurityAttributes,
            uint dwCreationDisposition,
            uint dwFlagsAndAttributes,
            IntPtr hTemplateFile);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool DeviceIoControl(
            SafeFileHandle hDevice,
            uint dwIoControlCode,
            IntPtr lpInBuffer,
            uint nInBufferSize,
            IntPtr lpOutBuffer,
            uint nOutBufferSize,
            out uint lpBytesReturned,
            IntPtr lpOverlapped);
    }
}





======================================
FILE: Services\Diagnostics\SmartHealthException.cs
======================================

using System;

namespace ProUSB.Services.Diagnostics;

public class SmartHealthException : Exception
{
    public SmartHealthException(string message) : base(message) { }
    public SmartHealthException(string message, Exception innerException) : base(message, innerException) { }
}




======================================
FILE: Services\History\BurnHistoryService.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Infrastructure;

namespace ProUSB.Services.History;

public record BurnHistoryEntry {
    public required DateTime Timestamp { get; init; }
    public required string DeviceName { get; init; }
    public required string DeviceId { get; init; }
    public required string IsoPath { get; init; }
    public required string Strategy { get; init; }
    public required bool Success { get; init; }
    public required long DurationMs { get; init; }
    public string? ErrorMessage { get; init; }
    public long? BytesWritten { get; init; }
}

public record BurnStatistics {
    public int TotalBurns { get; init; }
    public int SuccessfulBurns { get; init; }
    public int FailedBurns { get; init; }
    public double SuccessRate => TotalBurns > 0 ? (double)SuccessfulBurns / TotalBurns * 100 : 0;
    public long TotalDataWritten { get; init; }
    public TimeSpan TotalTime { get; init; }
    public string MostUsedDevice { get; init; } = "None";
    public string MostUsedStrategy { get; init; } = "None";
}

public class BurnHistoryService {
    private readonly string _historyPath;
    private readonly List<BurnHistoryEntry> _history = [];
    private const int MaxHistoryEntries = 1000;

    public BurnHistoryService(PortablePathManager pathManager) {
        string historyDir = pathManager.GetDataDirectory();
        Directory.CreateDirectory(historyDir);
        _historyPath = Path.Combine(historyDir, "burn_history.json");
        _ = LoadHistoryAsync();
    }

    public async Task AddEntryAsync(BurnHistoryEntry entry) {
        _history.Insert(0, entry);
        
        if (_history.Count > MaxHistoryEntries) {
            _history.RemoveAt(_history.Count - 1);
        }
        
        await SaveHistoryAsync();
    }

    public List<BurnHistoryEntry> GetHistory(int limit = 100) => 
        _history.Take(limit).ToList();

    public List<BurnHistoryEntry> GetHistoryForDevice(string deviceId, int limit = 50) => 
        _history.Where(e => e.DeviceId == deviceId).Take(limit).ToList();

    public List<BurnHistoryEntry> GetHistoryForIso(string isoPath, int limit = 50) => 
        _history.Where(e => e.IsoPath.Equals(isoPath, StringComparison.OrdinalIgnoreCase))
                .Take(limit)
                .ToList();

    public BurnStatistics GetStatistics() {
        if (_history.Count == 0) {
            return new BurnStatistics {
                TotalBurns = 0,
                SuccessfulBurns = 0,
                FailedBurns = 0,
                TotalDataWritten = 0,
                TotalTime = TimeSpan.Zero
            };
        }

        var successful = _history.Count(h => h.Success);
        var deviceGroups = _history.GroupBy(h => h.DeviceName).OrderByDescending(g => g.Count());
        var strategyGroups = _history.GroupBy(h => h.Strategy).OrderByDescending(g => g.Count());

        return new BurnStatistics {
            TotalBurns = _history.Count,
            SuccessfulBurns = successful,
            FailedBurns = _history.Count - successful,
            TotalDataWritten = _history.Sum(h => h.BytesWritten ?? 0),
            TotalTime = TimeSpan.FromMilliseconds(_history.Sum(h => h.DurationMs)),
            MostUsedDevice = deviceGroups.FirstOrDefault()?.Key ?? "None",
            MostUsedStrategy = strategyGroups.FirstOrDefault()?.Key ?? "None"
        };
    }

    public BurnHistoryEntry? GetLastSuccessfulBurnForDevice(string deviceId) =>
        _history.FirstOrDefault(e => e.DeviceId == deviceId && e.Success);

    public async Task ClearHistoryAsync() {
        _history.Clear();
        await SaveHistoryAsync();
    }

    private async Task LoadHistoryAsync() {
        try {
            if (File.Exists(_historyPath)) {
                var json = await File.ReadAllTextAsync(_historyPath);
                var loaded = JsonSerializer.Deserialize<List<BurnHistoryEntry>>(json);
                if (loaded != null) {
                    _history.AddRange(loaded.Take(MaxHistoryEntries));
                }
            }
        } catch { }
    }

    private async Task SaveHistoryAsync() {
        try {
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(_history, options);
            await File.WriteAllTextAsync(_historyPath, json);
        } catch { }
    }
}





======================================
FILE: Services\Iso\IsoAnalyzer.cs
======================================

using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DiscUtils;
using DiscUtils.Iso9660;
using DiscUtils.Udf;
using ProUSB.Services.Logging;

namespace ProUSB.Services.Iso;

public enum BootMode {
    Unknown,
    BiosOnly,
    UefiOnly,
    Hybrid
}

public enum OperatingSystem {
    Unknown,
    Windows,
    Linux,
    Other
}

public record IsoAnalysis {
    public BootMode BootMode { get; init; }
    public OperatingSystem OperatingSystem { get; init; }
    public string RecommendedPartitionScheme { get; init; } = "GPT";
    public string RecommendedFileSystem { get; init; } = "FAT32";
    public bool HasBootManager { get; init; }
    public bool HasEfiBootloader { get; init; }
    public bool IsBootable { get; init; }
    public string Details { get; init; } = "";
}

public class IsoAnalyzer {
    private readonly FileLogger _log;

    public IsoAnalyzer(FileLogger log) {
        _log = log;
    }

    public async Task<IsoAnalysis> AnalyzeIsoAsync(string isoPath, CancellationToken ct) {
        return await Task.Run(() => AnalyzeIso(isoPath), ct);
    }

    private IsoAnalysis AnalyzeIso(string isoPath) {
        _log.Info($"Analyzing ISO: {isoPath}");

        try {
            using var isoStream = File.OpenRead(isoPath);
            
            bool isUdf = UdfReader.Detect(isoStream);
            DiscFileSystem fs = isUdf 
                ? new UdfReader(isoStream) 
                : new CDReader(isoStream, true);

            bool hasBiosBootFiles = CheckBiosBootFiles(fs);
            bool hasUefiBootFiles = CheckUefiBootFiles(fs);
            var osType = DetectOperatingSystem(fs);

            var bootMode = DetermineBootMode(hasBiosBootFiles, hasUefiBootFiles);
            var isBootable = hasBiosBootFiles || hasUefiBootFiles;

            string recommendedScheme = bootMode switch {
                BootMode.UefiOnly => "GPT",
                BootMode.Hybrid => "GPT",
                _ => "MBR"
            };

            string recommendedFs = osType == OperatingSystem.Windows ? "NTFS" : "FAT32";

            string details = BuildAnalysisDetails(osType, bootMode, hasBiosBootFiles, hasUefiBootFiles);

            _log.Info($"ISO Analysis: OS={osType}, Boot={bootMode}, Scheme={recommendedScheme}");

            return new IsoAnalysis {
                BootMode = bootMode,
                OperatingSystem = osType,
                RecommendedPartitionScheme = recommendedScheme,
                RecommendedFileSystem = recommendedFs,
                HasBootManager = hasBiosBootFiles,
                HasEfiBootloader = hasUefiBootFiles,
                IsBootable = isBootable,
                Details = details
            };

        } catch (Exception ex) {
            _log.Error($"ISO analysis failed: {ex.Message}", ex);
            return new IsoAnalysis {
                BootMode = BootMode.Unknown,
                OperatingSystem = OperatingSystem.Unknown,
                Details = $"Analysis failed: {ex.Message}"
            };
        }
    }

    private bool CheckBiosBootFiles(DiscFileSystem fs) {
        string[] biosIndicators = {
            "\\bootmgr",
            "\\bootmgr.efi",
            "\\ntldr",
            "\\boot\\bcd",
            "\\isolinux\\isolinux.bin",
            "\\syslinux\\syslinux.bin",
            "\\boot\\grub\\i386-pc",
            "\\grldr"
        };

        foreach (var indicator in biosIndicators) {
            if (fs.FileExists(indicator) || fs.DirectoryExists(indicator)) {
                _log.Debug($"BIOS boot indicator found: {indicator}");
                return true;
            }
        }

        return false;
    }

    private bool CheckUefiBootFiles(DiscFileSystem fs) {
        string[] uefiIndicators = {
            "\\efi\\boot\\bootx64.efi",
            "\\efi\\boot\\bootia32.efi",
            "\\efi\\boot\\bootaa64.efi",
            "\\efi\\microsoft\\boot",
            "\\boot\\grub\\x86_64-efi"
        };

        foreach (var indicator in uefiIndicators) {
            if (fs.FileExists(indicator) || fs.DirectoryExists(indicator)) {
                _log.Debug($"UEFI boot indicator found: {indicator}");
                return true;
            }
        }

        return false;
    }

    private OperatingSystem DetectOperatingSystem(DiscFileSystem fs) {
        if (fs.FileExists("\\sources\\install.wim") || 
            fs.FileExists("\\sources\\install.esd") ||
            fs.FileExists("\\bootmgr")) {
            return OperatingSystem.Windows;
        }

        if (fs.FileExists("\\isolinux\\isolinux.bin") ||
            fs.FileExists("\\syslinux\\syslinux.bin") ||
            fs.DirectoryExists("\\casper") ||
            fs.DirectoryExists("\\live")) {
            return OperatingSystem.Linux;
        }

        return OperatingSystem.Other;
    }

    private BootMode DetermineBootMode(bool hasBios, bool hasUefi) {
        if (hasBios && hasUefi) return BootMode.Hybrid;
        if (hasUefi) return BootMode.UefiOnly;
        if (hasBios) return BootMode.BiosOnly;
        return BootMode.Unknown;
    }

    private string BuildAnalysisDetails(OperatingSystem os, BootMode boot, bool bios, bool uefi) {
        var parts = new System.Collections.Generic.List<string>();

        parts.Add($"Operating System: {os}");
        parts.Add($"Boot Mode: {boot}");
        
        if (bios) parts.Add("BIOS boot files detected");
        if (uefi) parts.Add("UEFI boot files detected");

        if (os == OperatingSystem.Windows) {
            parts.Add("Recommend NTFS for large file support");
        }

        if (boot == BootMode.Hybrid || boot == BootMode.UefiOnly) {
            parts.Add("GPT partition scheme required for UEFI");
        }

        return string.Join(". ", parts);
    }
}





======================================
FILE: Services\Iso\IsoIntegrityVerifier.cs
======================================

using System.IO;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.Threading;
using System;

namespace ProUSB.Services.Iso;
public class IsoIntegrityVerifier {
    public async Task<bool> IsStructureValid(string p) {
        try {
            using var f = File.OpenRead(p);
            if(f.Length<65536) return false;
            byte[] b=new byte[2048]; f.Seek(32768, SeekOrigin.Begin);
            await f.ReadExactlyAsync(b);
            
            bool isIso = b[1]=='C' && b[2]=='D' && b[3]=='0' && b[4]=='0' && b[5]=='1';
            if(isIso) return true;
            
            
            
            bool isUdf = b[1]=='B' && b[2]=='E' && b[3]=='A' && b[4]=='0' && b[5]=='1';
            return isUdf;
        } catch { return false; }
    }

    public async Task<bool> VerifyChecksumAsync(string filePath, string expectedSha256, CancellationToken ct) {
        try {
            using var stream = File.OpenRead(filePath);
            var hashBytes = await System.Security.Cryptography.SHA256.HashDataAsync(stream, ct);
            var actualHash = System.Convert.ToHexString(hashBytes);
            return actualHash.Equals(expectedSha256, StringComparison.OrdinalIgnoreCase);
        } catch { return false; }
    }
}




======================================
FILE: Services\IsoCreation\IsoCreationService.cs
======================================

using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.IsoCreation;

public class IsoCreationService {
    private readonly FileLogger _logger;
    
    public IsoCreationService(FileLogger logger) {
        _logger = logger;
    }
    
    public async Task<IsoCreationResult> CreateIsoFromDeviceAsync(
        UsbDeviceInfo device,
        string outputPath,
        IsoCreationMode mode,
        IProgress<IsoCreationProgress> progress,
        CancellationToken ct
    ) {
        _logger.Info($"Creating ISO from {device.FriendlyName}");
        _logger.Info($"Output: {outputPath}");
        _logger.Info($"Mode: {mode}");
        _logger.Info($"Device size: {FormatBytes(device.TotalSize)}");
        
        return mode switch {
            IsoCreationMode.RawCopy => await CreateRawIsoAsync(device, outputPath, progress, ct),
            _ => throw new ArgumentException($"Unsupported creation mode: {mode}")
        };
    }
    
    private async Task<IsoCreationResult> CreateRawIsoAsync(
        UsbDeviceInfo device,
        string outputPath,
        IProgress<IsoCreationProgress> progress,
        CancellationToken ct
    ) {
        var startTime = DateTime.Now;
        long totalBytes = device.TotalSize;
        long copiedBytes = 0;
        
        var physicalPath = $"\\\\.\\PhysicalDrive{device.PhysicalIndex}";
        
        _logger.Info($"Opening physical device: {physicalPath}");
        
        var handle = CreateFile(
            physicalPath,
            FileAccess.Read,
            FileShare.ReadWrite,
            IntPtr.Zero,
            FileMode.Open,
            0,
            IntPtr.Zero
        );
        
        if(handle.IsInvalid) {
            var error = $"Cannot open device {physicalPath}";
            _logger.Error(error);
            return new IsoCreationResult {
                Success = false,
                ErrorMessage = error
            };
        }
        
        try {
            using var source = new FileStream(handle, FileAccess.Read);
            using var dest = File.Create(outputPath);
            
            var buffer = new byte[1024 * 1024];
            int bytesRead;
            var lastUpdate = DateTime.Now;
            
            _logger.Info("Starting raw sector copy...");
            
            while((bytesRead = await source.ReadAsync(buffer.AsMemory(0, buffer.Length), ct)) > 0) {
                await dest.WriteAsync(buffer.AsMemory(0, bytesRead), ct);
                copiedBytes += bytesRead;
                
                var now = DateTime.Now;
                if((now - lastUpdate).TotalMilliseconds >= 500 || copiedBytes == totalBytes) {
                    var percent = (double)copiedBytes / totalBytes * 100;
                    var elapsed = now - startTime;
                    var speed = elapsed.TotalSeconds > 0 ? copiedBytes / elapsed.TotalSeconds : 0;
                    
                    progress?.Report(new IsoCreationProgress {
                        PercentComplete = percent,
                        BytesCopied = copiedBytes,
                        TotalBytes = totalBytes,
                        SpeedBytesPerSecond = speed,
                        Message = $"Copying... {FormatBytes(copiedBytes)}/{FormatBytes(totalBytes)} @ {FormatBytes((long)speed)}/s"
                    });
                    
                    lastUpdate = now;
                }
            }
            
            var duration = DateTime.Now - startTime;
            _logger.Info($"ISO creation completed in {duration.TotalSeconds:F1}s");
            _logger.Info($"Total size: {FormatBytes(copiedBytes)}");
            
            return new IsoCreationResult {
                Success = true,
                OutputPath = outputPath,
                FileSizeBytes = copiedBytes,
                CreationMode = IsoCreationMode.RawCopy,
                Duration = duration
            };
        }
        catch(Exception ex) {
            _logger.Error($"ISO creation failed: {ex.Message}");
            
            if(File.Exists(outputPath)) {
                try {
                    File.Delete(outputPath);
                    _logger.Info("Deleted incomplete ISO file");
                }
                catch {
                    _logger.Warn("Could not delete incomplete ISO file");
                }
            }
            
            return new IsoCreationResult {
                Success = false,
                ErrorMessage = ex.Message
            };
        }
        finally {
            handle.Close();
        }
    }
    
    private string FormatBytes(long bytes) {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1) {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
    
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern SafeFileHandle CreateFile(
        string lpFileName,
        FileAccess dwDesiredAccess,
        FileShare dwShareMode,
        IntPtr lpSecurityAttributes,
        FileMode dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile
    );
}





======================================
FILE: Services\IsoDownload\IsoDownloadService.cs
======================================

using System;
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.IsoDownload;

public class IsoDownloadService {
    private readonly FileLogger _logger;
    private readonly HttpClient _httpClient;

    public IsoDownloadService(FileLogger logger) {
        _logger = logger;
        _httpClient = new HttpClient {
            Timeout = Timeout.InfiniteTimeSpan
        };
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "ProUSBMediaSuite/1.0");
    }

    public async Task<bool> DownloadIsoAsync(
        OsInfo os,
        string outputPath,
        IProgress<DownloadProgress> progress,
        CancellationToken ct
    ) {
        try {
            if (string.IsNullOrEmpty(os.DirectDownloadUrl)) {
                _logger.Info($"No direct download available for {os.Name}, opening download page");
                OpenDownloadPage(os.DownloadPageUrl!);
                return false;
            }

            _logger.Info($"Starting download: {os.Name} to {outputPath}");

            using var response = await _httpClient.GetAsync(
                os.DirectDownloadUrl,
                HttpCompletionOption.ResponseHeadersRead,
                ct
            );

            response.EnsureSuccessStatusCode();

            var totalBytes = response.Content.Headers.ContentLength ?? os.FileSizeBytes ?? 0;
            var buffer = new byte[81920]; 
            long bytesDownloaded = 0;
            var stopwatch = Stopwatch.StartNew();
            var lastUpdate = DateTime.Now;

            await using var contentStream = await response.Content.ReadAsStreamAsync(ct);
            await using var fileStream = File.Create(outputPath);

            int bytesRead;
            while ((bytesRead = await contentStream.ReadAsync(buffer, ct)) > 0) {
                await fileStream.WriteAsync(buffer.AsMemory(0, bytesRead), ct);
                bytesDownloaded += bytesRead;

                
                if ((DateTime.Now - lastUpdate).TotalMilliseconds >= 200) {
                    var speedBps = bytesDownloaded / stopwatch.Elapsed.TotalSeconds;
                    var remaining = totalBytes > 0 && speedBps > 0
                        ? TimeSpan.FromSeconds((totalBytes - bytesDownloaded) / speedBps)
                        : TimeSpan.Zero;

                    progress.Report(new DownloadProgress {
                        PercentComplete = totalBytes > 0 ? (double)bytesDownloaded / totalBytes * 100 : 0,
                        BytesDownloaded = bytesDownloaded,
                        TotalBytes = totalBytes,
                        SpeedMBps = speedBps / 1_048_576,
                        TimeRemaining = remaining,
                        Status = $"Downloading... {FormatBytes(bytesDownloaded)} / {FormatBytes(totalBytes)}"
                    });

                    lastUpdate = DateTime.Now;
                }
            }

            _logger.Info($"Download complete: {outputPath} ({FormatBytes(bytesDownloaded)})");

            
            if (!string.IsNullOrEmpty(os.Sha256Checksum)) {
                progress.Report(new DownloadProgress {
                    PercentComplete = 100,
                    BytesDownloaded = bytesDownloaded,
                    TotalBytes = totalBytes,
                    SpeedMBps = 0,
                    TimeRemaining = TimeSpan.Zero,
                    Status = "Verifying checksum..."
                });

                var isValid = await VerifyChecksumAsync(outputPath, os.Sha256Checksum, ct);
                if (!isValid) {
                    _logger.Error($"Checksum verification failed for {outputPath}");
                    File.Delete(outputPath);
                    throw new Exception("Checksum verification failed. Downloaded file may be corrupted.");
                }

                _logger.Info($"Checksum verification passed for {outputPath}");
            }

            progress.Report(new DownloadProgress {
                PercentComplete = 100,
                BytesDownloaded = bytesDownloaded,
                TotalBytes = totalBytes,
                SpeedMBps = 0,
                TimeRemaining = TimeSpan.Zero,
                Status = "Complete"
            });

            return true;

        } catch (OperationCanceledException) {
            _logger.Info($"Download cancelled: {os.Name}");
            if (File.Exists(outputPath)) {
                File.Delete(outputPath);
            }
            throw;
        } catch (Exception ex) {
            _logger.Error($"Download failed for {os.Name}: {ex.Message}", ex);
            if (File.Exists(outputPath)) {
                File.Delete(outputPath);
            }
            throw;
        }
    }

    public void OpenDownloadPage(string url) {
        try {
            Process.Start(new ProcessStartInfo {
                FileName = url,
                UseShellExecute = true
            });
            _logger.Info($"Opened download page: {url}");
        } catch (Exception ex) {
            _logger.Error($"Failed to open download page: {ex.Message}", ex);
        }
    }

    private async Task<bool> VerifyChecksumAsync(string filePath, string expectedSha256, CancellationToken ct) {
        try {
            await using var stream = File.OpenRead(filePath);
            var hashBytes = await SHA256.HashDataAsync(stream, ct);
            var actualHash = Convert.ToHexString(hashBytes);
            
            return actualHash.Equals(expectedSha256, StringComparison.OrdinalIgnoreCase);
        } catch (Exception ex) {
            _logger.Error($"Checksum verification error: {ex.Message}", ex);
            return false;
        }
    }

    private string FormatBytes(long bytes) {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1) {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}






======================================
FILE: Services\IsoDownload\OsCatalogService.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.IsoDownload;

public class OsCatalogService {
    private readonly FileLogger _logger;
    private OsCatalog? _catalog;
    private readonly JsonSerializerOptions _jsonOptions;

    public OsCatalogService(FileLogger logger) {
        _logger = logger;
        _jsonOptions = new JsonSerializerOptions {
            PropertyNameCaseInsensitive = true,
            AllowTrailingCommas = true
        };
    }

    public async Task<List<OsInfo>> GetAllOperatingSystemsAsync() {
        if (_catalog == null) {
            await LoadCatalogAsync();
        }
        return _catalog?.OperatingSystems ?? new List<OsInfo>();
    }

    public async Task<List<OsInfo>> GetOperatingSystemsByCategoryAsync(string category) {
        var allOS = await GetAllOperatingSystemsAsync();
        return allOS.Where(os => os.Category.Equals(category, StringComparison.OrdinalIgnoreCase)).ToList();
    }

    public async Task<List<OsInfo>> SearchOperatingSystemsAsync(string query) {
        var allOS = await GetAllOperatingSystemsAsync();
        return allOS.Where(os => 
            os.Name.Contains(query, StringComparison.OrdinalIgnoreCase) ||
            os.Vendor.Contains(query, StringComparison.OrdinalIgnoreCase) ||
            os.Version.Contains(query, StringComparison.OrdinalIgnoreCase)
        ).ToList();
    }

    public async Task<OsInfo?> GetOperatingSystemByIdAsync(string id) {
        var allOS = await GetAllOperatingSystemsAsync();
        return allOS.FirstOrDefault(os => os.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
    }

    public List<string> GetCategories() {
        return new List<string> { "All", "Windows", "Linux", "BSD" };
    }

    private async Task LoadCatalogAsync() {
        try {
            var assembly = Assembly.GetExecutingAssembly();
            var resourceName = "ProUSBMediaSuite.Resources.os_catalog.json";

            await using var stream = assembly.GetManifestResourceStream(resourceName);
            
            if (stream == null) {
                
                var catalogPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "os_catalog.json");
                if (File.Exists(catalogPath)) {
                    await using var fileStream = File.OpenRead(catalogPath);
                    _catalog = await JsonSerializer.DeserializeAsync<OsCatalog>(fileStream, _jsonOptions);
                } else {
                    _logger.Error($"OS catalog not found: {resourceName} or {catalogPath}");
                    _catalog = new OsCatalog { OperatingSystems = new List<OsInfo>() };
                    return;
                }
            } else {
                _catalog = await JsonSerializer.DeserializeAsync<OsCatalog>(stream, _jsonOptions);
            }

            _logger.Info($"Loaded OS catalog with {_catalog?.OperatingSystems.Count ?? 0} operating systems");
        } catch (Exception ex) {
            _logger.Error($"Failed to load OS catalog: {ex.Message}", ex);
            _catalog = new OsCatalog { OperatingSystems = new List<OsInfo>() };
        }
    }
}






======================================
FILE: Services\IsoManagement\IsoLibraryService.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Infrastructure;
using ProUSB.Services.Iso;

namespace ProUSB.Services.IsoManagement;

public record IsoLibraryEntry {
    public required string FilePath { get; init; }
    public required string FileName { get; init; }
    public required long SizeBytes { get; init; }
    public required DateTime LastModified { get; init; }
    public DateTime LastScanned { get; init; } = DateTime.Now;
    public string? DetectedOs { get; init; }
    public string? DetectedVersion { get; init; }
    public bool IsBootable { get; init; }
    public string? Sha256Hash { get; init; }
    public List<string> Tags { get; init; } = [];
    public int UseCount { get; init; } = 0;
    public DateTime? LastUsed { get; init; }
}

public record QuickBurnPreset {
    public required string Name { get; init; }
    public required string IsoPath { get; init; }
    public required string ProfileName { get; init; }
    public string? DeviceId { get; init; }
}

public class IsoLibraryService {
    private readonly string _libraryPath;
    private readonly IsoIntegrityVerifier _verifier;
    private readonly List<IsoLibraryEntry> _library = [];
    private readonly List<QuickBurnPreset> _presets = [];

    public IsoLibraryService(PortablePathManager pathManager, IsoIntegrityVerifier verifier) {
        _verifier = verifier;
        string dataDir = pathManager.GetDataDirectory();
        Directory.CreateDirectory(dataDir);
        _libraryPath = Path.Combine(dataDir, "iso_library.json");
        _ = LoadLibraryAsync();
    }

    public async Task ScanDirectoryAsync(string directoryPath, CancellationToken ct = default) {
        if (!Directory.Exists(directoryPath)) return;

        var isoFiles = Directory.GetFiles(directoryPath, "*.iso", SearchOption.AllDirectories);

        foreach (var isoPath in isoFiles) {
            ct.ThrowIfCancellationRequested();
            
            try {
                var fileInfo = new FileInfo(isoPath);
                var existing = _library.FirstOrDefault(e => e.FilePath.Equals(isoPath, StringComparison.OrdinalIgnoreCase));

                if (existing != null && existing.LastModified == fileInfo.LastWriteTime) {
                    continue;
                }

                var isValid = await _verifier.IsStructureValid(isoPath);
                var (os, version) = DetectOsInfo(fileInfo.Name);

                var entry = new IsoLibraryEntry {
                    FilePath = isoPath,
                    FileName = fileInfo.Name,
                    SizeBytes = fileInfo.Length,
                    LastModified = fileInfo.LastWriteTime,
                    LastScanned = DateTime.Now,
                    DetectedOs = os,
                    DetectedVersion = version,
                    IsBootable = isValid,
                    Tags = GenerateTags(os),
                    UseCount = existing?.UseCount ?? 0,
                    LastUsed = existing?.LastUsed
                };

                if (existing != null) {
                    _library.Remove(existing);
                }
                _library.Add(entry);

            } catch { }
        }

        await SaveLibraryAsync();
    }

    public List<IsoLibraryEntry> GetAllIsos() => [.. _library.OrderByDescending(e => e.LastUsed ?? DateTime.MinValue)];

    public List<IsoLibraryEntry> SearchIsos(string query) {
        if (string.IsNullOrWhiteSpace(query)) return GetAllIsos();

        var lowerQuery = query.ToLowerInvariant();
        return _library
            .Where(e =>
                e.FileName.ToLowerInvariant().Contains(lowerQuery) ||
                e.DetectedOs?.ToLowerInvariant().Contains(lowerQuery) == true ||
                e.Tags.Any(t => t.ToLowerInvariant().Contains(lowerQuery)))
            .ToList();
    }

    public List<IsoLibraryEntry> FilterByTag(string tag) =>
        _library.Where(e => e.Tags.Contains(tag, StringComparer.OrdinalIgnoreCase)).ToList();

    public async Task UpdateUseCountAsync(string isoPath) {
        var entry = _library.FirstOrDefault(e => e.FilePath.Equals(isoPath, StringComparison.OrdinalIgnoreCase));
        if (entry != null) {
            _library.Remove(entry);
            _library.Add(entry with { UseCount = entry.UseCount + 1, LastUsed = DateTime.Now });
            await SaveLibraryAsync();
        }
    }

    public async Task<QuickBurnPreset?> AddPresetAsync(string name, string isoPath, string profileName, string? deviceId = null) {
        var preset = new QuickBurnPreset {
            Name = name,
            IsoPath = isoPath,
            ProfileName = profileName,
            DeviceId = deviceId
        };
        _presets.Add(preset);
        await SaveLibraryAsync();
        return preset;
    }

    public List<QuickBurnPreset> GetPresets() => [.. _presets];

    private (string? Os, string? Version) DetectOsInfo(string fileName) {
        var lower = fileName.ToLowerInvariant();

        if (lower.Contains("ubuntu")) return ("Ubuntu", ExtractVersion(fileName, "ubuntu"));
        if (lower.Contains("fedora")) return ("Fedora", ExtractVersion(fileName, "fedora"));
        if (lower.Contains("debian")) return ("Debian", ExtractVersion(fileName, "debian"));
        if (lower.Contains("arch")) return ("Arch Linux", null);
        if (lower.Contains("manjaro")) return ("Manjaro", null);
        if (lower.Contains("mint")) return ("Linux Mint", ExtractVersion(fileName, "mint"));
        if (lower.Contains("kali")) return ("Kali Linux", ExtractVersion(fileName, "kali"));
        if (lower.Contains("windows")) return ("Windows", ExtractWindowsVersion(fileName));
        if (lower.Contains("win11")) return ("Windows", "11");
        if (lower.Contains("win10")) return ("Windows", "10");

        return (null, null);
    }

    private string? ExtractVersion(string fileName, string osName) {
        var index = fileName.ToLowerInvariant().IndexOf(osName);
        if (index >= 0) {
            var afterOs = fileName.Substring(index + osName.Length);
            var versionMatch = System.Text.RegularExpressions.Regex.Match(afterOs, @"[\d\.]+");
            return versionMatch.Success ? versionMatch.Value : null;
        }
        return null;
    }

    private string? ExtractWindowsVersion(string fileName) {
        if (fileName.Contains("11")) return "11";
        if (fileName.Contains("10")) return "10";
        if (fileName.Contains("2022")) return "Server 2022";
        if (fileName.Contains("2019")) return "Server 2019";
        return null;
    }

    private List<string> GenerateTags(string? os) {
        List<string> tags = [];
        
        if (os != null) {
            tags.Add(os);
            
            if (os.Contains("Ubuntu") || os.Contains("Debian") || os.Contains("Mint")) {
                tags.Add("Debian-based");
            }
            if (os.Contains("Fedora") || os.Contains("RHEL")) {
                tags.Add("RPM-based");
            }
            if (os.Contains("Arch") || os.Contains("Manjaro")) {
                tags.Add("Arch-based");
            }
            if (os.Contains("Windows")) {
                tags.Add("Windows");
            } else {
                tags.Add("Linux");
            }
        }

        return tags;
    }

    private async Task LoadLibraryAsync() {
        try {
            if (File.Exists(_libraryPath)) {
                var json = await File.ReadAllTextAsync(_libraryPath);
                var data = JsonSerializer.Deserialize<LibraryData>(json);
                if (data != null) {
                    _library.AddRange(data.Entries ?? []);
                    _presets.AddRange(data.Presets ?? []);
                }
            }
        } catch { }
    }

    private async Task SaveLibraryAsync() {
        try {
            var data = new LibraryData {
                Entries = [.. _library],
                Presets = [.. _presets]
            };
            var options = new JsonSerializerOptions { WriteIndented = true };
            var json = JsonSerializer.Serialize(data, options);
            await File.WriteAllTextAsync(_libraryPath, json);
        } catch { }
    }

    private record LibraryData {
        public List<IsoLibraryEntry> Entries { get; init; } = [];
        public List<QuickBurnPreset> Presets { get; init; } = [];
    }
}





======================================
FILE: Services\Logging\FileLogger.cs
======================================

using System;
using System.Threading;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using System.Collections.Generic;
using ProUSB.Domain;
using ProUSB.Infrastructure;

namespace ProUSB.Services.Logging;

public class FileLogger {
    private readonly string _logPath;
    private readonly Lock _lock = new();
    private readonly long _maxBytes = 10 * 1024 * 1024;
    private readonly ObservableCollection<LogEntry> _logEntries = new();
    private readonly int _maxLogEntries = 10000;

    public ReadOnlyObservableCollection<LogEntry> LogEntries { get; }

    private LogLevel _minLevel = LogLevel.Info;
    public LogLevel MinLevel {
        get => _minLevel;
        set => _minLevel = value >= LogLevel.Debug && value <= LogLevel.Error ? value : LogLevel.Info;
    }

    public FileLogger(PortablePathManager pathManager) {
        string logDir = pathManager.GetLogsDirectory();
        Directory.CreateDirectory(logDir);
        _logPath = Path.Combine(logDir, "burn_debug.log");
        LogEntries = new ReadOnlyObservableCollection<LogEntry>(_logEntries);
        Info($"=== ProUSBMediaSuite Logging Started (Portable: {pathManager.IsPortableMode()}) ===");
    }

    private void Write(LogLevel level, string message, Exception? ex = null) {
        if(level < MinLevel) return;

        var entry = new LogEntry {
            Timestamp = DateTime.Now,
            Level = level,
            Message = ex != null ? $"{message}\n    Exception: {ex.GetType().Name}: {ex.Message}" : message,
            Source = "ProUSBMediaSuite"
        };

        _logEntries.Add(entry);

        if(_logEntries.Count > _maxLogEntries) {
            _logEntries.RemoveAt(0);
        }

        WriteToFile(entry, ex);
    }

    private void WriteToFile(LogEntry entry, Exception? ex = null) {
        lock(_lock) {
            try {
                if(File.Exists(_logPath) && new FileInfo(_logPath).Length > _maxBytes) {
                    var archived = Path.Combine(
                        Path.GetDirectoryName(Path.GetFullPath(_logPath))!,
                        Path.GetFileNameWithoutExtension(_logPath) + $"-{DateTime.UtcNow:yyyyMMddHHmmss}.log"
                    );
                    File.Move(_logPath, archived);
                }

                var logLine = entry.GetFormattedEntry();
                if(ex != null) {
                    logLine += $"\n    StackTrace: {ex.StackTrace}";
                }
                File.AppendAllText(_logPath, logLine + Environment.NewLine);
            } catch { }
        }
    }

    public void Debug(string message) => Write(LogLevel.Debug, message);
    public void Info(string message) => Write(LogLevel.Info, message);
    public void Warn(string message) => Write(LogLevel.Warn, message);
    public void Error(string message, Exception? ex = null) => Write(LogLevel.Error, message, ex);

    public List<LogEntry> FilterByLevel(LogLevel level) {
        return _logEntries.Where(e => e.Level == level).ToList();
    }

    public List<LogEntry> FilterByLevels(bool showInfo, bool showWarn, bool showError, bool showDebug) {
        return _logEntries
            .Where(e =>
                (showInfo && e.Level == LogLevel.Info) ||
                (showWarn && e.Level == LogLevel.Warn) ||
                (showError && e.Level == LogLevel.Error) ||
                (showDebug && e.Level == LogLevel.Debug)
            )
            .ToList();
    }

    public List<LogEntry> Search(string query) {
        if(string.IsNullOrWhiteSpace(query)) return _logEntries.ToList();

        var lowerQuery = query.ToLowerInvariant();
        return _logEntries
            .Where(e => e.Message.ToLowerInvariant().Contains(lowerQuery))
            .ToList();
    }

    public List<LogEntry> FilterAndSearch(bool showInfo, bool showWarn, bool showError, bool showDebug, string query) {
        var filtered = FilterByLevels(showInfo, showWarn, showError, showDebug);

        if(string.IsNullOrWhiteSpace(query)) return filtered;

        var lowerQuery = query.ToLowerInvariant();
        return filtered
            .Where(e => e.Message.ToLowerInvariant().Contains(lowerQuery))
            .ToList();
    }

    public async Task ExportToTextAsync(string filePath) {
        var lines = _logEntries.Select(e => e.GetFormattedEntry());
        await File.WriteAllLinesAsync(filePath, lines);
    }

    public async Task ExportToCsvAsync(string filePath) {
        List<string> lines = ["Timestamp,Level,Message"];
        lines.AddRange(_logEntries.Select(e => e.GetCsvEntry()));
        await File.WriteAllLinesAsync(filePath, lines);
    }

    public async Task ExportToJsonAsync(string filePath) {
        var options = new JsonSerializerOptions { WriteIndented = true };
        await using var stream = File.Create(filePath);
        await JsonSerializer.SerializeAsync(stream, _logEntries, options);
    }

    public void ClearLogs() {
        _logEntries.Clear();
    }
}





======================================
FILE: Services\Profiles\ProfileManager.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using ProUSB.Domain;
using ProUSB.Services.Logging;
using ProUSB.Infrastructure;

namespace ProUSB.Services.Profiles;

public class ProfileManager {
    private readonly FileLogger _logger;
    private readonly string _profilesDirectory;
    private readonly JsonSerializerOptions _jsonOptions;
    
    public ProfileManager(FileLogger logger, PortablePathManager pathManager) {
        _logger = logger;
        
        _profilesDirectory = pathManager.GetProfilesDirectory();
        
        if(!Directory.Exists(_profilesDirectory)) {
            Directory.CreateDirectory(_profilesDirectory);
            _logger.Info($"Created profiles directory: {_profilesDirectory}");
        }
        
        _jsonOptions = new JsonSerializerOptions {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            AllowTrailingCommas = false
        };
        
        EnsureDefaultProfiles();
    }
    
    public async Task<List<BurnProfile>> GetAllProfilesAsync() {
        var profiles = new List<BurnProfile>();
        
        try {
            var files = Directory.GetFiles(_profilesDirectory, "*.json");
            
            foreach(var file in files) {
                try {
                    await using var fileStream = File.OpenRead(file);
                    
                    var profile = await JsonSerializer.DeserializeAsync<BurnProfile>(
                        fileStream,
                        _jsonOptions
                    );
                    
                    if(profile != null) {
                        profiles.Add(profile);
                    }
                }
                catch(JsonException ex) {
                    _logger.Warn($"Invalid JSON in {Path.GetFileName(file)}: {ex.Message}");
                }
            }
            
            _logger.Info($"Loaded {profiles.Count} profile(s)");
        }
        catch(Exception ex) {
            _logger.Error($"Error loading profiles: {ex.Message}");
        }
        
        return profiles.OrderBy(p => p.IsDefault ? 0 : 1).ThenBy(p => p.Name).ToList();
    }
    
    public List<BurnProfile> GetAllProfiles() {
        return GetAllProfilesAsync().GetAwaiter().GetResult();
    }
    
    public async Task SaveProfileAsync(BurnProfile profile) {
        try {
            var fileName = SanitizeFileName(profile.Name) + ".json";
            var filePath = Path.Combine(_profilesDirectory, fileName);
            
            await using var fileStream = File.Create(filePath);
            await JsonSerializer.SerializeAsync(fileStream, profile, _jsonOptions);
            
            _logger.Info($"Saved profile: {profile.Name}");
        }
        catch(Exception ex) {
            _logger.Error($"Failed to save profile {profile.Name}: {ex.Message}");
            throw;
        }
    }
    
    public void SaveProfile(BurnProfile profile) {
        SaveProfileAsync(profile).GetAwaiter().GetResult();
    }
    
    public void DeleteProfile(string profileName) {
        try {
            var fileName = SanitizeFileName(profileName) + ".json";
            var filePath = Path.Combine(_profilesDirectory, fileName);
            
            if(File.Exists(filePath)) {
                File.Delete(filePath);
                _logger.Info($"Deleted profile: {profileName}");
            }
        }
        catch(Exception ex) {
            _logger.Error($"Failed to delete profile {profileName}: {ex.Message}");
            throw;
        }
    }
    
    private void EnsureDefaultProfiles() {
        var profiles = GetAllProfiles();
        
        if(profiles.Any(p => p.IsDefault)) {
            return;
        }
        
        _logger.Info("Creating default profiles...");
        
        var defaults = new[] {
            new BurnProfile {
                Name = "Windows 11 UEFI (Small)",
                Description = "Windows 11 UEFI with install.wim < 4GB (GPT + FAT32)",
                PartitionScheme = "gpt",
                FileSystem = "fat32",
                ClusterSize = 0,
                QuickFormat = true,
                BypassWin11 = true,
                IsDefault = true
            },
            new BurnProfile {
                Name = "Windows 11 UEFI (Large)",
                Description = "Windows 11 UEFI with install.wim > 4GB (GPT + NTFS)",
                PartitionScheme = "gpt",
                FileSystem = "ntfs",
                ClusterSize = 0,
                QuickFormat = true,
                BypassWin11 = true,
                IsDefault = true
            },
            new BurnProfile {
                Name = "Windows 10 Legacy",
                Description = "Windows 10 for Legacy BIOS (MBR + NTFS)",
                PartitionScheme = "mbr",
                FileSystem = "ntfs",
                ClusterSize = 0,
                QuickFormat = true,
                BypassWin11 = false,
                IsDefault = true
            },
            new BurnProfile {
                Name = "Linux Live USB",
                Description = "Generic Linux live USB (GPT + FAT32)",
                PartitionScheme = "gpt",
                FileSystem = "fat32",
                ClusterSize = 0,
                QuickFormat = true,
                IsDefault = true
            },
            new BurnProfile {
                Name = "Generic FAT32",
                Description = "Universal compatibility (MBR + FAT32)",
                PartitionScheme = "mbr",
                FileSystem = "fat32",
                ClusterSize = 0,
                QuickFormat = true,
                IsDefault = true
            }
        };
        
        foreach(var profile in defaults) {
            SaveProfile(profile);
        }
        
        _logger.Info($"Created {defaults.Length} default profiles");
    }
    
    private string SanitizeFileName(string name) {
        var invalid = Path.GetInvalidFileNameChars();
        return string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
    }
}





======================================
FILE: Services\Progress\ProgressTracker.cs
======================================

using System;
using System.Diagnostics;
using ProUSB.Domain;

namespace ProUSB.Services.Progress;

public class ProgressTracker {
    private readonly Stopwatch _stopwatch = new();
    private readonly RollingAverage _speedCalc = new(10);
    private long _totalBytes;
    private long _lastBytes;
    private DateTime _lastUpdate = DateTime.UtcNow;

    public void Start(long totalBytes) {
        _totalBytes = totalBytes;
        _lastBytes = 0;
        _stopwatch.Restart();
        _lastUpdate = DateTime.UtcNow;
    }

    public WriteStatistics Update(long currentBytes, string message) {
        var now = DateTime.UtcNow;
        var deltaTime = (now - _lastUpdate).TotalSeconds;
        var deltaBytes = currentBytes - _lastBytes;

        double speedMBps = 0;
        if (deltaTime > 0.1) {
            speedMBps = (deltaBytes / deltaTime) / (1024.0 * 1024.0);
            _speedCalc.AddSample(speedMBps);
            _lastUpdate = now;
            _lastBytes = currentBytes;
        }

        var avgSpeed = _speedCalc.GetAverage();
        var percentComplete = _totalBytes > 0 ? (currentBytes * 100.0 / _totalBytes) : 0;
        
        TimeSpan timeRemaining = TimeSpan.Zero;
        if (avgSpeed > 0 && currentBytes < _totalBytes) {
            var remainingBytes = _totalBytes - currentBytes;
            var secondsRemaining = (remainingBytes / (1024.0 * 1024.0)) / avgSpeed;
            timeRemaining = TimeSpan.FromSeconds(secondsRemaining);
        }

        return new WriteStatistics {
            BytesWritten = currentBytes,
            PercentComplete = percentComplete,
            Message = message,
            SpeedMBps = avgSpeed,
            TimeElapsed = _stopwatch.Elapsed,
            TimeRemaining = timeRemaining
        };
    }

    public void Stop() {
        _stopwatch.Stop();
    }
}

public class RollingAverage {
    private readonly double[] _samples;
    private int _index;
    private int _count;

    public RollingAverage(int windowSize) {
        _samples = new double[windowSize];
    }

    public void AddSample(double value) {
        _samples[_index] = value;
        _index = (_index + 1) % _samples.Length;
        if (_count < _samples.Length) _count++;
    }

    public double GetAverage() {
        if (_count == 0) return 0;
        
        double sum = 0;
        for (int i = 0; i < _count; i++) {
            sum += _samples[i];
        }
        return sum / _count;
    }
}





======================================
FILE: Services\PxeBoot\PxeBootImageService.cs
======================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DiscUtils;
using DiscUtils.Iso9660;
using DiscUtils.Udf;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.PxeBoot;

public class PxeBootImageService {
    private readonly FileLogger _log;

    public PxeBootImageService(FileLogger log) {
        _log = log;
    }

    public async Task<PxeBootResult> CreatePxeBootImageAsync(
        PxeBootConfiguration config,
        IProgress<PxeCreationProgress> progress,
        CancellationToken ct
    ) {
        var sw = System.Diagnostics.Stopwatch.StartNew();
        var warnings = new List<string>();
        var filesCreated = new List<PxeFileMapping>();

        try {
            _log.Info($"Starting PXE boot image creation from {config.IsoPath}");
            progress.Report(new PxeCreationProgress {
                PercentComplete = 0,
                Message = "Opening ISO file...",
                CurrentFile = "",
                BytesProcessed = 0,
                TotalBytes = 0
            });

            if (!File.Exists(config.IsoPath)) {
                throw new FileNotFoundException($"ISO file not found: {config.IsoPath}");
            }

            Directory.CreateDirectory(config.OutputDirectory);

            using var isoStream = File.OpenRead(config.IsoPath);
            var fs = UdfReader.Detect(isoStream)
                ? (DiscFileSystem)new UdfReader(isoStream)
                : new CDReader(isoStream, true);

            var bootType = config.BootType == PxeBootType.Generic
                ? DetectBootType(fs)
                : config.BootType;

            _log.Info($"Detected boot type: {bootType}");

            progress.Report(new PxeCreationProgress {
                PercentComplete = 10,
                Message = $"Extracting {bootType} boot files...",
                CurrentFile = "",
                BytesProcessed = 0,
                TotalBytes = 0
            });

            if (bootType == PxeBootType.Windows) {
                filesCreated.AddRange(await ExtractWindowsPxeFilesAsync(fs, config, progress, ct));
            } else {
                filesCreated.AddRange(await ExtractLinuxPxeFilesAsync(fs, config, progress, ct));
            }

            if (config.GenerateBiosConfig) {
                await GeneratePxeLinuxConfigAsync(config.OutputDirectory, bootType, ct);
                _log.Info("Generated BIOS (PXELINUX) configuration");
            }

            if (config.GenerateUefiConfig && bootType == PxeBootType.Linux) {
                await GenerateGrubConfigAsync(config.OutputDirectory, ct);
                _log.Info("Generated UEFI (GRUB2) configuration");
            }

            await CopyPxeToolsAsync(config.OutputDirectory, bootType, ct);
            await GenerateIpxeConfigAsync(config.OutputDirectory, bootType, ct);

            progress.Report(new PxeCreationProgress {
                PercentComplete = 100,
                Message = "PXE boot image created successfully",
                CurrentFile = "",
                BytesProcessed = 0,
                TotalBytes = 0
            });

            sw.Stop();
            _log.Info($"PXE boot image creation completed in {sw.Elapsed.TotalSeconds:F1}s");

            return new PxeBootResult {
                Success = true,
                FilesCreated = filesCreated,
                Warnings = warnings,
                Duration = sw.Elapsed
            };

        } catch (Exception ex) {
            _log.Error($"PXE boot image creation failed: {ex.Message}", ex);
            return new PxeBootResult {
                Success = false,
                FilesCreated = filesCreated,
                Warnings = warnings,
                ErrorMessage = ex.Message,
                Duration = sw.Elapsed
            };
        }
    }

    private async Task CopyPxeToolsAsync(string outputDir, PxeBootType bootType, CancellationToken ct) {
        var toolsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Resources", "pxe-tools");
        if (!Directory.Exists(toolsDir)) {
            _log.Warn($"PXE tools directory not found at {toolsDir}. Skipping tool copy.");
            return;
        }

        
        if (bootType == PxeBootType.Windows) {
            var wimbootSrc = Path.Combine(toolsDir, "ipxe", "wimboot");
            if (File.Exists(wimbootSrc)) {
                File.Copy(wimbootSrc, Path.Combine(outputDir, "wimboot"), true);
                _log.Info("Copied wimboot");
            }
        }

        
        var ipxeSrc = Path.Combine(toolsDir, "ipxe", "ipxe.efi");
        if (File.Exists(ipxeSrc)) {
            File.Copy(ipxeSrc, Path.Combine(outputDir, "ipxe.efi"), true);
            _log.Info("Copied ipxe.efi");
        }
        
        var memtestSrc = Path.Combine(toolsDir, "efi", "memtest", "memtest.efi");
        if (File.Exists(memtestSrc)) {
            Directory.CreateDirectory(Path.Combine(outputDir, "tools"));
            File.Copy(memtestSrc, Path.Combine(outputDir, "tools", "memtest.efi"), true);
            _log.Info("Copied memtest.efi");
        }

        
        var biosDir = Path.Combine(toolsDir, "bios");
        if (Directory.Exists(biosDir)) {
            var biosFiles = new[] { "pxelinux.0", "ldlinux.c32", "menu.c32", "libutil.c32", "libmenu.c32" };
            foreach (var file in biosFiles) {
                var src = Path.Combine(biosDir, file);
                
                
                
                
                
                if (!File.Exists(src)) {
                    var found = Directory.GetFiles(toolsDir, file, SearchOption.AllDirectories).FirstOrDefault();
                    if (found != null) src = found;
                }

                if (File.Exists(src)) {
                    File.Copy(src, Path.Combine(outputDir, file), true);
                    _log.Info($"Copied {file}");
                } else {
                    _log.Warn($"Could not find BIOS tool: {file}");
                }
            }
        }
    }

    private async Task GenerateIpxeConfigAsync(string outputDir, PxeBootType bootType, CancellationToken ct) {
        var ipxePath = Path.Combine(outputDir, "boot.ipxe");
        string content;

        if (bootType == PxeBootType.Windows) {
            content = @"#!ipxe
kernel wimboot
initrd windows/bootmgr.efi bootmgr.efi
initrd windows/Boot/BCD BCD
initrd windows/Boot/boot.sdi boot.sdi
initrd windows/sources/boot.wim boot.wim
boot";
        } else {
            content = @"#!ipxe
kernel linux/vmlinuz boot=live quiet splash
initrd linux/initrd.img
boot";
        }

        await File.WriteAllTextAsync(ipxePath, content, ct);
        _log.Info($"Generated iPXE config: {ipxePath}");
    }

    private PxeBootType DetectBootType(DiscFileSystem fs) {
        if (fs.FileExists("\\sources\\boot.wim") || fs.FileExists("\\bootmgr.efi")) {
            return PxeBootType.Windows;
        }

        if (fs.DirectoryExists("\\casper") || fs.DirectoryExists("\\live") ||
            fs.FileExists("\\isolinux\\isolinux.bin")) {
            return PxeBootType.Linux;
        }

        _log.Warn("Could not detect boot type, defaulting to Linux");
        return PxeBootType.Linux;
    }

    private async Task<List<PxeFileMapping>> ExtractWindowsPxeFilesAsync(
        DiscFileSystem fs,
        PxeBootConfiguration config,
        IProgress<PxeCreationProgress> progress,
        CancellationToken ct
    ) {
        var files = new List<PxeFileMapping>();
        var windowsDir = Path.Combine(config.OutputDirectory, "windows");
        Directory.CreateDirectory(windowsDir);

        var filesToExtract = new Dictionary<string, string> {
            [@"\sources\boot.wim"] = Path.Combine(windowsDir, "sources", "boot.wim"),
            [@"\bootmgr.efi"] = Path.Combine(windowsDir, "bootmgr.efi"),
            [@"\Boot\BCD"] = Path.Combine(windowsDir, "Boot", "BCD"),
            [@"\Boot\boot.sdi"] = Path.Combine(windowsDir, "Boot", "boot.sdi")
        };

        int current = 0;
        foreach (var (isoPath, destPath) in filesToExtract) {
            ct.ThrowIfCancellationRequested();

            if (!fs.FileExists(isoPath)) {
                _log.Warn($"Windows PXE file not found in ISO: {isoPath}");
                continue;
            }

            Directory.CreateDirectory(Path.GetDirectoryName(destPath)!);

            var fileInfo = fs.GetFileInfo(isoPath);
            _log.Info($"Extracting {isoPath} ({fileInfo.Length} bytes)");

            progress.Report(new PxeCreationProgress {
                PercentComplete = 10 + (current * 60 / filesToExtract.Count),
                Message = $"Extracting {Path.GetFileName(isoPath)}...",
                CurrentFile = isoPath,
                BytesProcessed = 0,
                TotalBytes = fileInfo.Length
            });

            using var sourceStream = fileInfo.OpenRead();
            using var destStream = File.Create(destPath);
            await sourceStream.CopyToAsync(destStream, ct);

            files.Add(new PxeFileMapping {
                SourcePath = isoPath,
                DestinationPath = destPath,
                Description = $"Windows boot file: {Path.GetFileName(isoPath)}",
                FileSize = fileInfo.Length
            });

            current++;
        }

        return files;
    }

    private async Task<List<PxeFileMapping>> ExtractLinuxPxeFilesAsync(
        DiscFileSystem fs,
        PxeBootConfiguration config,
        IProgress<PxeCreationProgress> progress,
        CancellationToken ct
    ) {
        var files = new List<PxeFileMapping>();
        var linuxDir = Path.Combine(config.OutputDirectory, "linux");
        Directory.CreateDirectory(linuxDir);

        var kernelPaths = new[] {
            @"\casper\vmlinuz",
            @"\live\vmlinuz",
            @"\isolinux\vmlinuz",
            @"\boot\vmlinuz"
        };

        var initrdPaths = new[] {
            @"\casper\initrd",
            @"\casper\initrd.lz",
            @"\live\initrd.img",
            @"\isolinux\initrd.img",
            @"\boot\initrd.img"
        };

        string? kernelPath = kernelPaths.FirstOrDefault(fs.FileExists);
        string? initrdPath = initrdPaths.FirstOrDefault(fs.FileExists);

        if (kernelPath == null) {
            throw new FileNotFoundException("Could not find Linux kernel (vmlinuz) in ISO");
        }

        if (initrdPath == null) {
            throw new FileNotFoundException("Could not find Linux initrd in ISO");
        }

        await ExtractFileAsync(fs, kernelPath, Path.Combine(linuxDir, "vmlinuz"), files, progress, ct);
        await ExtractFileAsync(fs, initrdPath, Path.Combine(linuxDir, "initrd.img"), files, progress, ct);

        return files;
    }

    private async Task ExtractFileAsync(
        DiscFileSystem fs,
        string sourcePath,
        string destPath,
        List<PxeFileMapping> files,
        IProgress<PxeCreationProgress> progress,
        CancellationToken ct
    ) {
        var fileInfo = fs.GetFileInfo(sourcePath);
        _log.Info($"Extracting {sourcePath} ({fileInfo.Length} bytes)");

        progress.Report(new PxeCreationProgress {
            PercentComplete = 50,
            Message = $"Extracting {Path.GetFileName(sourcePath)}...",
            CurrentFile = sourcePath,
            BytesProcessed = 0,
            TotalBytes = fileInfo.Length
        });

        using var sourceStream = fileInfo.OpenRead();
        using var destStream = File.Create(destPath);
        await sourceStream.CopyToAsync(destStream, ct);

        files.Add(new PxeFileMapping {
            SourcePath = sourcePath,
            DestinationPath = destPath,
            Description = $"Linux boot file: {Path.GetFileName(sourcePath)}",
            FileSize = fileInfo.Length
        });
    }

    private async Task GeneratePxeLinuxConfigAsync(string outputDir, PxeBootType bootType, CancellationToken ct) {
        var pxelinuxCfgDir = Path.Combine(outputDir, "pxelinux.cfg");
        Directory.CreateDirectory(pxelinuxCfgDir);

        var defaultConfigPath = Path.Combine(pxelinuxCfgDir, "default");

        string configContent = bootType == PxeBootType.Windows
            ? GenerateWindowsPxeLinuxConfig()
            : GenerateLinuxPxeLinuxConfig();

        await File.WriteAllTextAsync(defaultConfigPath, configContent, ct);
        _log.Info($"Generated PXELINUX config: {defaultConfigPath}");
    }

    private string GenerateWindowsPxeLinuxConfig() {
        return @"DEFAULT menu.c32
PROMPT 0
TIMEOUT 300

MENU TITLE Windows PXE Boot Menu

LABEL windows
    MENU LABEL Boot Windows PE
    KERNEL pxeboot.0
    APPEND bootfile=bootmgr.efi
";
    }

    private string GenerateLinuxPxeLinuxConfig() {
        return @"DEFAULT menu.c32
PROMPT 0
TIMEOUT 300

MENU TITLE Linux PXE Boot Menu

LABEL linux
    MENU LABEL Boot Linux
    KERNEL linux/vmlinuz
    APPEND initrd=linux/initrd.img boot=live quiet splash
";
    }

    private async Task GenerateGrubConfigAsync(string outputDir, CancellationToken ct) {
        var grubDir = Path.Combine(outputDir, "grub");
        Directory.CreateDirectory(grubDir);

        var grubCfgPath = Path.Combine(grubDir, "grub.cfg");

        string grubConfig = @"set timeout=30
set default=0

menuentry ""Boot Linux (UEFI)"" {
    linux /linux/vmlinuz boot=live quiet splash
    initrd /linux/initrd.img
}
";

        await File.WriteAllTextAsync(grubCfgPath, grubConfig, ct);
        _log.Info($"Generated GRUB2 config: {grubCfgPath}");
    }
}






======================================
FILE: Services\Security\StandardSafetyGuard.cs
======================================

using ProUSB.Domain;
using ProUSB.Domain.Services;
using ProUSB.Infrastructure.DeviceDetection;
using System;
using System.IO;
using System.Linq;

namespace ProUSB.Services.Security;

public class StandardSafetyGuard : ISafetyGuard {
    public DeviceRiskLevel EvaluateRisk(UsbDeviceInfo d) {
        if (!string.Equals(d.BusType, "USB", StringComparison.OrdinalIgnoreCase))
            return DeviceRiskLevel.Critical;

        var deviceType = DeviceSignatureDatabase.DetectDeviceType(d.VendorId, d.ProductId);
        
        if (deviceType == DeviceType.ExternalHdd)
            return DeviceRiskLevel.Critical;
        
        if (deviceType == DeviceType.CardReader && d.TotalSize > 512L * 1024 * 1024 * 1024)
            return DeviceRiskLevel.Critical;

        string? sysRoot = Path.GetPathRoot(Environment.GetFolderPath(Environment.SpecialFolder.System));
        if (!string.IsNullOrEmpty(sysRoot) && d.MountPoints?.Any(m => m.StartsWith(sysRoot, StringComparison.OrdinalIgnoreCase)) == true)
            return DeviceRiskLevel.SystemLockdown;

        try {
            var systemDiskSize = new DriveInfo(sysRoot!).TotalSize;
            if (Math.Abs(systemDiskSize - d.TotalSize) < (1024L * 1024 * 512))
                return DeviceRiskLevel.Critical;
        } catch { }

        string[] cardReaderIndicators = { "card reader", "cardreader", "sd/mmc", "multi-card" };
        if (cardReaderIndicators.Any(indicator => 
            (d.DeviceId?.Contains(indicator, StringComparison.OrdinalIgnoreCase) ?? false) ||
            (d.FriendlyName?.Contains(indicator, StringComparison.OrdinalIgnoreCase) ?? false)))
        {
            if (d.TotalSize > 512L * 1024 * 1024 * 1024)
                return DeviceRiskLevel.Critical;
        }

        if (d.TotalSize > 2L * 1024 * 1024 * 1024 * 1024)
            return DeviceRiskLevel.Critical;

        return DeviceRiskLevel.Safe;
    }
}




======================================
FILE: Services\Verification\BootVerificationService.cs
======================================

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using ProUSB.Domain;
using ProUSB.Services.Logging;

namespace ProUSB.Services.Verification;

public class BootVerificationService {
    private readonly FileLogger _logger;
    
    public BootVerificationService(FileLogger logger) {
        _logger = logger;
    }
    
    public async Task<BootVerificationResult> VerifyDeviceAsync(UsbDeviceInfo device, CancellationToken ct) {
        _logger.Info($"Starting bootability verification for {device.FriendlyName}");
        
        var result = new BootVerificationResult {
            DeviceName = device.FriendlyName,
            DeviceId = device.DeviceId
        };
        
        try {
            var physicalPath = $"\\\\.\\PhysicalDrive{device.PhysicalIndex}";
            
            var bootSector = await ReadBootSectorAsync(physicalPath, ct);
            
            result.HasValidMBRSignature = CheckMBRSignature(bootSector);
            result.Details.Add($"MBR Signature: {(result.HasValidMBRSignature ? "Valid (0x55AA)" : "Invalid")}");
            
            result.HasActivePartition = CheckActivePartitionFlag(bootSector);
            result.Details.Add($"Active Partition: {(result.HasActivePartition ? "Present" : "None")}");
            
            result.IsGPT = await CheckGPTSignatureAsync(physicalPath, ct);
            result.Details.Add($"Partition Style: {(result.IsGPT ? "GPT" : "MBR")}");
            
            if(result.IsGPT) {
                result.HasESP = CheckESPPartition(device);
                if(result.HasESP) {
                    result.Details.Add("EFI System Partition: Found");
                }
            }
            
            result.DetectedBootloader = await DetectBootloaderAsync(device, ct);
            result.Details.Add($"Bootloader: {result.DetectedBootloader}");
            
            DetermineBootability(result);
            
            _logger.Info($"Verification complete: {result.GetSummary()}");
        }
        catch(Exception ex) {
            _logger.Error($"Verification failed: {ex.Message}");
            result.Warnings.Add($"Verification error: {ex.Message}");
        }
        
        return result;
    }
    
    private bool CheckMBRSignature(byte[] bootSector) {
        if(bootSector == null || bootSector.Length < 512) return false;
        return bootSector[510] == 0x55 && bootSector[511] == 0xAA;
    }
    
    private bool CheckActivePartitionFlag(byte[] bootSector) {
        if(bootSector == null || bootSector.Length < 512) return false;
        
        for(int i = 0; i < 4; i++) {
            int offset = 446 + (i * 16);
            if(bootSector[offset] == 0x80) {
                return true;
            }
        }
        return false;
    }
    
    private async Task<bool> CheckGPTSignatureAsync(string physicalPath, CancellationToken ct) {
        try {
            var gptHeader = await ReadSectorAsync(physicalPath, 1, ct);
            if(gptHeader.Length >= 8) {
                var signature = Encoding.ASCII.GetString(gptHeader, 0, 8);
                return signature == "EFI PART";
            }
        }
        catch {
            return false;
        }
        return false;
    }
    
    private bool CheckESPPartition(UsbDeviceInfo device) {
        try {
            if(device.MountPoints.Count > 0) {
                foreach(var mountPoint in device.MountPoints) {
                    var efiPath = Path.Combine(mountPoint, "EFI", "BOOT");
                    if(Directory.Exists(efiPath)) {
                        return true;
                    }
                }
            }
        }
        catch {
            return false;
        }
        return false;
    }
    
    private async Task<BootloaderType> DetectBootloaderAsync(UsbDeviceInfo device, CancellationToken ct) {
        await Task.CompletedTask;
        
        try {
            if(device.MountPoints.Count == 0) {
                return BootloaderType.Unknown;
            }
            
            foreach(var mountPoint in device.MountPoints) {
                if(CheckWindowsBootloader(mountPoint)) return BootloaderType.WindowsBoot;
                if(CheckGRUBBootloader(mountPoint)) return BootloaderType.GRUB;
                if(CheckSyslinuxBootloader(mountPoint)) return BootloaderType.Syslinux;
                if(CheckUEFIBootloader(mountPoint)) return BootloaderType.UEFIGeneric;
            }
        }
        catch {
            return BootloaderType.Unknown;
        }
        
        return BootloaderType.None;
    }
    
    private bool CheckWindowsBootloader(string volume) {
        try {
            if(File.Exists(Path.Combine(volume, "bootmgr"))) return true;
            if(Directory.Exists(Path.Combine(volume, "Boot"))) return true;
            if(Directory.Exists(Path.Combine(volume, "EFI", "Microsoft", "Boot"))) return true;
        }
        catch { }
        return false;
    }
    
    private bool CheckGRUBBootloader(string volume) {
        try {
            if(Directory.Exists(Path.Combine(volume, "boot", "grub"))) return true;
            if(Directory.Exists(Path.Combine(volume, "grub"))) return true;
            if(File.Exists(Path.Combine(volume, "EFI", "BOOT", "grubx64.efi"))) return true;
        }
        catch { }
        return false;
    }
    
    private bool CheckSyslinuxBootloader(string volume) {
        try {
            if(File.Exists(Path.Combine(volume, "syslinux.cfg"))) return true;
            if(File.Exists(Path.Combine(volume, "isolinux.cfg"))) return true;
            if(File.Exists(Path.Combine(volume, "ldlinux.sys"))) return true;
        }
        catch { }
        return false;
    }
    
    private bool CheckUEFIBootloader(string volume) {
        try {
            var efiBootPath = Path.Combine(volume, "EFI", "BOOT");
            if(Directory.Exists(efiBootPath)) {
                var efiFiles = Directory.GetFiles(efiBootPath, "*.efi");
                return efiFiles.Length > 0;
            }
        }
        catch { }
        return false;
    }
    
    private void DetermineBootability(BootVerificationResult result) {
        if(result.IsGPT && result.HasESP && result.DetectedBootloader != BootloaderType.None) {
            result.IsBootable = true;
            result.BootMode = result.HasValidMBRSignature && result.HasActivePartition 
                ? BootMode.Hybrid 
                : BootMode.UEFI;
            return;
        }
        
        if(result.HasValidMBRSignature && result.HasActivePartition && result.DetectedBootloader != BootloaderType.None) {
            result.IsBootable = true;
            result.BootMode = BootMode.Legacy;
            return;
        }
        
        result.IsBootable = false;
        result.BootMode = BootMode.Unknown;
        
        if(!result.HasValidMBRSignature) {
            result.Warnings.Add("Invalid MBR signature");
        }
        if(!result.HasActivePartition && !result.IsGPT) {
            result.Warnings.Add("No active partition");
        }
        if(result.DetectedBootloader == BootloaderType.None) {
            result.Warnings.Add("No bootloader detected");
        }
    }
    
    private async Task<byte[]> ReadBootSectorAsync(string physicalPath, CancellationToken ct) {
        return await ReadSectorAsync(physicalPath, 0, ct);
    }
    
    private async Task<byte[]> ReadSectorAsync(string physicalPath, long sectorNumber, CancellationToken ct) {
        const int SECTOR_SIZE = 512;
        var buffer = new byte[SECTOR_SIZE];
        
        var handle = CreateFile(
            physicalPath,
            FileAccess.Read,
            FileShare.ReadWrite,
            IntPtr.Zero,
            FileMode.Open,
            0,
            IntPtr.Zero
        );
        
        if(handle.IsInvalid) {
            throw new IOException($"Cannot open device {physicalPath}");
        }
        
        try {
            using(var stream = new FileStream(handle, FileAccess.Read)) {
                stream.Seek(sectorNumber * SECTOR_SIZE, SeekOrigin.Begin);
                int bytesRead = await stream.ReadAsync(buffer.AsMemory(0, SECTOR_SIZE), ct);
                if(bytesRead < SECTOR_SIZE) {
                    Array.Resize(ref buffer, bytesRead);
                }
            }
        }
        finally {
            handle.Close();
        }
        
        return buffer;
    }
    
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern SafeFileHandle CreateFile(
        string lpFileName,
        FileAccess dwDesiredAccess,
        FileShare dwShareMode,
        IntPtr lpSecurityAttributes,
        FileMode dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile
    );
}





======================================
FILE: Services\IUsbBurnerService.cs
======================================

namespace ProUSB.Services;

public interface IUsbBurnerService
{
    Task BurnIsoAsync(string isoPath, string driveLetter, string fileSystem, string partitionScheme, int persistenceSizeMB, IProgress<double> progress, CancellationToken cancellationToken = default);
}



======================================
FILE: Services\UsbBurnerService.cs
======================================

using System.Diagnostics;
using ProUSB.Infrastructure.DiskManagement;
using ProUSB.Services.Logging;
using ProUSB.Domain;

namespace ProUSB.Services;

public class UsbBurnerService : IUsbBurnerService
{
    private readonly NativeDiskFormatter _formatter;
    private readonly FileLogger _logger;

    public UsbBurnerService(NativeDiskFormatter formatter, FileLogger logger)
    {
        _formatter = formatter;
        _logger = logger;
    }

    public async Task BurnIsoAsync(string isoPath, string driveLetter, string fileSystem, string partitionScheme, int persistenceSizeMB, IProgress<double> progress, CancellationToken cancellationToken = default)
    {
        if (!File.Exists(isoPath))
            throw new FileNotFoundException($"ISO file not found: {isoPath}");

        int diskIndex = GetDiskIndexFromDriveLetter(driveLetter);
        _logger.Info($"Starting burn process for {isoPath} to Disk {diskIndex} (Persistence: {persistenceSizeMB} MB)");

        try
        {
            if (persistenceSizeMB > 0)
            {
                // Custom layout with Persistence
                var partitions = new List<PartitionDefinition>();
                
                // Boot Partition (FAT32) - Takes remaining space
                // We put Persistence at the end usually, but NativeDiskFormatter expects ordered list.
                // Let's put Boot first, Persistence second.
                
                // Calculate sizes
                // NativeDiskFormatter handles SizeMB=0 as "Rest of disk"
                // So Partition 1 (Boot) should be 0? No, usually Persistence is fixed size.
                // So Partition 1 (Boot) = 0 (Rest), Partition 2 (Persistence) = Fixed?
                // NativeDiskFormatter logic:
                // if (def.SizeMB == 0 || i == partitions.Count - 1 && def.SizeMB == 0) -> Rest of disk.
                
                // If we want Persistence at the end, we should define Boot first.
                // But if Boot is "Rest", it takes everything.
                // So we must define Boot size? No, ISO size varies.
                // Better: Partition 1 (Persistence) = Fixed, Partition 2 (Boot) = Rest?
                // But Boot partition usually needs to be first for compatibility.
                
                // So: Partition 1 (Boot) = Total - Persistence.
                // But we don't know Total easily here without querying.
                // NativeDiskFormatter queries it.
                
                // Let's rely on NativeDiskFormatter to handle "Rest".
                // If we define Partition 1 as Size=0, it takes all.
                // We need to change NativeDiskFormatter to support "Rest" for non-last partition?
                // Or just define Persistence first?
                // Windows only mounts the first partition on removable drives (historically).
                // Modern Windows mounts all.
                // Linux looks for casper-rw label.
                
                // Let's try: Partition 1 (Boot) = 0 (Rest - Persistence)?
                // NativeDiskFormatter logic is simple loop.
                
                // Let's assume we can put Persistence first? No, Boot should be first.
                
                // I'll modify NativeDiskFormatter logic later if needed, but for now let's assume we can't easily do "Rest" for first partition.
                // So I will query disk size here? No, I don't have the handle.
                
                // Let's just use a fixed size for Boot if possible? No.
                
                // Wait, NativeDiskFormatter.CreateCustomPartitionLayout:
                // if (def.SizeMB == 0 || i == partitions.Count - 1 && def.SizeMB == 0) sizeBytes = diskSize - currentOffset ...
                
                // So if I have 2 partitions:
                // 1. Boot (Size=0) -> Takes everything.
                // 2. Persistence -> No space left.
                
                // So I MUST specify size for Partition 1 if I want Partition 2.
                // But I don't know the disk size.
                
                // Workaround: Put Persistence FIRST?
                // 1. Persistence (Ext4, Fixed Size)
                // 2. Boot (FAT32, Rest)
                // This works for Linux (it searches all partitions).
                // Does it work for BIOS/UEFI?
                // UEFI looks for EFI System Partition.
                // If Partition 1 is Ext4, UEFI might skip it?
                // Usually UEFI scans all FAT partitions.
                // So if Partition 2 is FAT32, it should work.
                
                partitions.Add(new PartitionDefinition 
                { 
                    Label = "casper-rw", 
                    FileSystem = "ext4", 
                    SizeMB = persistenceSizeMB,
                    IsBootable = false
                });
                
                partitions.Add(new PartitionDefinition 
                { 
                    Label = "BOOT", 
                    FileSystem = "FAT32", 
                    SizeMB = 0, // Rest of disk
                    IsBootable = true
                });

                await _formatter.FormatCustomAsync(diskIndex, partitions, cancellationToken).ConfigureAwait(false);
            }
            else
            {
                // Standard single partition
                await _formatter.FormatAsync(diskIndex, "BOOT", "FAT32", partitionScheme, 4096, true, cancellationToken).ConfigureAwait(false);
            }

            // Copy ISO content
            progress.Report(50);
            await ExtractIsoAsync(isoPath, driveLetter, progress, cancellationToken).ConfigureAwait(false);
            
            progress.Report(100);
        }
        catch (Exception ex)
        {
            _logger.Error($"Burn failed: {ex.Message}", ex);
            throw;
        }
    }

    private int GetDiskIndexFromDriveLetter(string driveLetter)
    {
        // Simple heuristic or WMI query
        // For now, assuming driveLetter is like "E:\"
        // We can use WMI to get DiskIndex.
        // Or just parse if it was passed as "PhysicalDriveX" (but signature says driveLetter).
        // The UI passes "E:\".
        
        // Using WMI to map DriveLetter to DiskIndex
        try 
        {
            var drive = driveLetter.TrimEnd('\\');
            using var searcher = new System.Management.ManagementObjectSearcher($"SELECT Index FROM Win32_DiskPartition WHERE DeviceID IN (SELECT Dependent FROM Win32_LogicalDiskToPartition WHERE Antecedent = (SELECT Name FROM Win32_LogicalDisk WHERE DeviceID = '{drive}'))");
            foreach (var mo in searcher.Get())
            {
                // This returns DiskIndex but partition specific?
                // Win32_DiskPartition.Index is Partition index? No, DiskIndex is in Win32_DiskDrive.
                // Wait, Win32_DiskPartition has DiskIndex property.
                return Convert.ToInt32(mo["DiskIndex"]);
            }
        }
        catch 
        {
            // Fallback or error
        }
        // If failed, maybe it's a test? Return 1?
        // Throwing is safer.
        throw new InvalidOperationException($"Could not determine Disk Index for {driveLetter}");
    }

    private async Task ExtractIsoAsync(string isoPath, string driveLetter, IProgress<double> progress, CancellationToken ct)
    {
        using var isoStream = File.OpenRead(isoPath);
        using var cd = new DiscUtils.Iso9660.CDReader(isoStream, true);
        
        var files = cd.GetFiles("").ToList();
        int totalFiles = files.Count; // This is only root files? No, recursive?
        // GetFiles("") returns all files recursively if search pattern is empty? No.
        // We need recursive.
        
        // Helper to copy directory
        await CopyDirectoryAsync(cd.Root, driveLetter, progress, 0, 100, ct).ConfigureAwait(false);
    }

    private async Task CopyDirectoryAsync(DiscUtils.DiscDirectoryInfo dir, string destPath, IProgress<double> progress, double startPct, double endPct, CancellationToken ct)
    {
        if (!Directory.Exists(destPath)) Directory.CreateDirectory(destPath);

        var files = dir.GetFiles();
        var subDirs = dir.GetDirectories();
        int totalItems = files.Length + subDirs.Length;
        int currentItem = 0;

        foreach (var file in files)
        {
            ct.ThrowIfCancellationRequested();
            string destFile = Path.Combine(destPath, file.Name);
            
            using var sourceStream = file.OpenRead();
            using var destStream = File.Create(destFile);
            
            // Use stack allocation for buffer (81920 bytes = 80KB is reasonable for stack)
            Span<byte> buffer = stackalloc byte[81920];
            int bytesRead;
            while ((bytesRead = sourceStream.Read(buffer)) > 0)
            {
                destStream.Write(buffer.Slice(0, bytesRead));
            }
            
            currentItem++;
            // Update progress... (simplified)
        }

        foreach (var subDir in subDirs)
        {
            await CopyDirectoryAsync(subDir, Path.Combine(destPath, subDir.Name), progress, startPct, endPct, ct).ConfigureAwait(false);
        }
    }
}



======================================
FILE: UI\ViewModels\BurnSummaryHelper.cs
======================================

using System.Threading.Tasks;
using Avalonia.Controls;
using ProUSB.UI.Views;

namespace ProUSB.UI.ViewModels;

public static class BurnSummaryHelper {
    public static async Task ShowSummaryAsync(
        Window owner,
        string deviceName,
        string isoName,
        string fileSystem,
        string partitionScheme,
        int persistenceMB) {
        
        var dialog = new Window {
            Title = "Burn Complete",
            Width = 500,
            Height = 400,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false
        };

        var panel = new StackPanel { Margin = new Avalonia.Thickness(24) };

        panel.Children.Add(new TextBlock {
            Text = "✅ Burn Operation Complete!",
            FontSize = 20,
            FontWeight = Avalonia.Media.FontWeight.SemiBold,
            Foreground = Avalonia.Media.Brushes.LightGreen,
            Margin = new Avalonia.Thickness(0, 0, 0, 16)
        });

        panel.Children.Add(new TextBlock {
            Text = "Your USB drive is ready to use.",
            FontSize = 14,
            Foreground = Avalonia.Media.Brushes.Gray,
            Margin = new Avalonia.Thickness(0, 0, 0, 24)
        });

        panel.Children.Add(new TextBlock {
            Text = "Summary",
            FontSize = 16,
            FontWeight = Avalonia.Media.FontWeight.Bold,
            Margin = new Avalonia.Thickness(0, 0, 0, 12)
        });

        panel.Children.Add(new TextBlock {
            Text = $"Device: {deviceName}",
            Margin = new Avalonia.Thickness(0, 0, 0, 6)
        });

        panel.Children.Add(new TextBlock {
            Text = $"ISO: {System.IO.Path.GetFileName(isoName)}",
            Margin = new Avalonia.Thickness(0, 0, 0, 6)
        });

        panel.Children.Add(new TextBlock {
            Text = $"File System: {fileSystem.ToUpper()}",
            Margin = new Avalonia.Thickness(0, 0, 0, 6)
        });

        panel.Children.Add(new TextBlock {
            Text = $"Partition: {partitionScheme}",
            Margin = new Avalonia.Thickness(0, 0, 0, 6)
        });

        panel.Children.Add(new TextBlock {
            Text = $"Persistence: {(persistenceMB > 0 ? $"{persistenceMB} MB" : "Disabled")}",
            Margin = new Avalonia.Thickness(0, 0, 0, 24)
        });

        panel.Children.Add(new TextBlock {
            Text = "Next Steps",
            FontSize = 16,
            FontWeight = Avalonia.Media.FontWeight.Bold,
            Margin = new Avalonia.Thickness(0, 0, 0, 12)
        });

        panel.Children.Add(new TextBlock {
            Text = "1. Safely eject your USB drive\n" +
                   "2. Insert it into your target computer\n" +
                   "3. Boot from USB (usually F12/F2/DEL at startup)\n" +
                   "4. Follow on-screen installation instructions",
            Margin = new Avalonia.Thickness(0, 0, 0, 24)
        });

        var closeButton = new Button {
            Content = "CLOSE",
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Stretch,
            Padding = new Avalonia.Thickness(20, 10),
            Background = Avalonia.Media.Brushes.DodgerBlue,
            Foreground = Avalonia.Media.Brushes.White
        };
        closeButton.Click += (s, e) => dialog.Close();
        panel.Children.Add(closeButton);

        dialog.Content = new ScrollViewer { Content = panel };

        await dialog.ShowDialog(owner);
    }
}





======================================
FILE: UI\ViewModels\DeviceBurnProgress.cs
======================================

using CommunityToolkit.Mvvm.ComponentModel;

namespace ProUSB.UI.ViewModels;

public partial class DeviceBurnProgress : ObservableObject {
    [ObservableProperty] string deviceName = "";
    [ObservableProperty] string deviceId = "";
    [ObservableProperty] double progress;
    [ObservableProperty] string status = "Queued";
    [ObservableProperty] bool isComplete;
    [ObservableProperty] bool hasFailed;
}




======================================
FILE: UI\ViewModels\MainViewModel.cs
======================================

using System;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.Linq;
using Avalonia;
using Avalonia.Platform.Storage;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ProUSB.Domain;
using ProUSB.Domain.Drivers;
using ProUSB.Services.Burn;
using ProUSB.Services.Logging;
using ProUSB.Services.Verification;
using ProUSB.Services.IsoCreation;
using ProUSB.Services.Profiles;
using ProUSB.Services.Diagnostics;
using ProUSB.UI.Views;
using ProUSB.UI;

using Mass.Core.UI;

namespace ProUSB.UI.ViewModels;

public partial class MainViewModel : ViewModelBase {
    private readonly ParallelBurnService _burn;
    private readonly MultiDeviceBurnOrchestrator _multiDeviceBurner;
    private readonly BootVerificationService _verifier;
    private readonly IsoCreationService _isoCreator;
    private readonly ProfileManager _profileManager;
    private readonly SmartHealthChecker _healthChecker;
    private readonly IDriverFactory _fac;
    private readonly FileLogger _logger;
    private CancellationTokenSource? _cts;

    [ObservableProperty] string status = "Ready.";
    [ObservableProperty] double prog;
    [ObservableProperty] UsbDeviceInfo? selDev;
    [ObservableProperty] ObservableCollection<UsbDeviceInfo> selectedDevices = new();
    [ObservableProperty] ObservableCollection<DeviceBurnProgress> deviceProgress = new();
    [ObservableProperty] string selectionSummary = "No devices selected";
    [ObservableProperty] int persistenceSize = 0;
    [ObservableProperty] string iso = "";
    [ObservableProperty] bool isBusy;
    [ObservableProperty] string logText = "";
    [ObservableProperty] bool canCancel;
    [ObservableProperty] bool isRefreshing;
    [ObservableProperty] bool logScrollTrigger;
    
    
    [ObservableProperty] ObservableCollection<LogEntry> filteredLogs = new();
    [ObservableProperty] string searchText = "";
    [ObservableProperty] LogLevel selectedLogLevel = LogLevel.Info;
    [ObservableProperty] bool showInfoLogs = true;
    [ObservableProperty] bool showWarnLogs = true;
    [ObservableProperty] bool showErrorLogs = true;
    [ObservableProperty] bool showDebugLogs = false;

    
    [ObservableProperty] ObservableCollection<BurnProfile> profiles = new();
    [ObservableProperty] BurnProfile? selectedProfile;
    [ObservableProperty] string newProfileName = "";

    
    [ObservableProperty] bool isVerifying;
    [ObservableProperty] string verificationResult = "";

    
    [ObservableProperty] SmartHealthReport? healthReport;
    [ObservableProperty] bool isCheckingHealth;

    
    [ObservableProperty] bool isCreatingIso;

    public ObservableCollection<string> FileSystems { get; } = new() {
        "FAT32", "NTFS", "exFAT", "UDF", "ReFS"
    };

    public ObservableCollection<string> ClusterSizes { get; } = new() {
        "Default", "512 bytes", "1024 bytes (1K)", "2048 bytes (2K)", "4096 bytes (4K)",
        "8192 bytes (8K)", "16384 bytes (16K)", "32768 bytes (32K)", "65536 bytes (64K)"
    };

    [ObservableProperty] int partitionSchemeIndex = 0;
    [ObservableProperty] int fileSystemIndex = 0;
    [ObservableProperty] int clusterSizeIndex = 0;
    [ObservableProperty] bool quickFormat = true;
    [ObservableProperty] bool bypassWin11;
    [ObservableProperty] bool isRaw;

    public ObservableCollection<UsbDeviceInfo> Devs { get; } = new();

    public MainViewModel(
        ParallelBurnService b,
        MultiDeviceBurnOrchestrator multiDeviceBurner,
        BootVerificationService verifier,
        IsoCreationService isoCreator,
        ProfileManager profileManager,
        SmartHealthChecker healthChecker,
        IDriverFactory f,
        FileLogger l
    ) {
        _burn = b;
        _multiDeviceBurner = multiDeviceBurner;
        _verifier = verifier;
        _isoCreator = isoCreator;
        _profileManager = profileManager;
        _healthChecker = healthChecker;
        _fac = f;
        _logger = l;

        RefreshProfiles();
        FilterLogs(); 
        Task.Run(Refresh);
    }

    private void Log(string m) {
        string msg = $"{DateTime.Now:HH:mm:ss}: {m}";
        LogText += msg + Environment.NewLine;
        _logger.Info(m);
        LogScrollTrigger = !LogScrollTrigger;
        FilterLogs();
    }

    private void RefreshProfiles() {
        Profiles.Clear();
        foreach(var profile in _profileManager.GetAllProfiles()) {
            Profiles.Add(profile);
        }
    }

    private Window? GetMainWindow() {
        if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop) {
            return desktop.MainWindow;
        }
        return null;
    }

    private void UpdateSelectionSummary() {
        if(SelectedDevices.Count == 0) {
            SelectionSummary = "No devices selected";
        } else if(SelectedDevices.Count == 1) {
            SelectionSummary = $"1 device selected: {SelectedDevices[0].FriendlyName}";
        } else {
            var totalSize = SelectedDevices.Sum(d => d.TotalSize);
            var sizeMB = totalSize / (1024.0 * 1024.0 * 1024.0);
            SelectionSummary = $"{SelectedDevices.Count} devices selected ({sizeMB:F1} GB total)";
        }
    }

    private void UpdateDeviceProgress(string deviceId, double progress, string status) {
        var item = DeviceProgress.FirstOrDefault(d => d.DeviceId == deviceId);
        if(item != null) {
            item.Progress = progress;
            item.Status = status;
            item.IsComplete = status.Contains("Complete");
            item.HasFailed = status.Contains("Failed");
        }

        Prog = DeviceProgress.Count > 0 ? DeviceProgress.Average(d => d.Progress) : 0;

        var active = DeviceProgress.Count(d => !d.IsComplete && !d.HasFailed);
        if(active > 0) {
            Status = $"Burning {active} device(s)...";
        }
    }

    private string FormatFileSize(long bytes) {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while(len >= 1024 && order < sizes.Length - 1) {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    [RelayCommand]
    public void FilterLogs() {
        FilteredLogs.Clear();
        var logs = _logger.FilterAndSearch(ShowInfoLogs, ShowWarnLogs, ShowErrorLogs, ShowDebugLogs, SearchText);
        foreach(var log in logs) {
            FilteredLogs.Add(log);
        }
    }

    [RelayCommand]
    public async Task ExportLogs() {
        var w = GetMainWindow();
        if(w == null) return;

        var saveOptions = new FilePickerSaveOptions {
            Title = "Export Logs",
            SuggestedFileName = $"ProUSBMediaSuite_Logs_{DateTime.Now:yyyyMMdd_HHmmss}",
            FileTypeChoices = new[] {
                new FilePickerFileType("Text File") { Patterns = new[] { "*.txt" } },
                new FilePickerFileType("CSV File") { Patterns = new[] { "*.csv" } },
                new FilePickerFileType("JSON File") { Patterns = new[] { "*.json" } }
            }
        };

        var result = await w.StorageProvider.SaveFilePickerAsync(saveOptions);
        if(result == null) return;

        var path = result.Path.LocalPath;
        var ext = System.IO.Path.GetExtension(path).ToLowerInvariant();

        try {
            switch(ext) {
                case ".txt":
                    await _logger.ExportToTextAsync(path);
                    break;
                case ".csv":
                    await _logger.ExportToCsvAsync(path);
                    break;
                case ".json":
                    await _logger.ExportToJsonAsync(path);
                    break;
                default:
                    await _logger.ExportToTextAsync(path + ".txt");
                    break;
            }

            Status = $"✅ Logs exported to {Path.GetFileName(path)}";
            Log($"Logs exported: {path}");
        } catch(Exception ex) {
            Status = $"❌ Export failed: {ex.Message}";
            Log($"Export error: {ex.Message}");
        }
    }

    [RelayCommand]
    public void ClearLogs() {
        _logger.ClearLogs();
        FilteredLogs.Clear();
        LogText = "";
        Log("Logs cleared");
    }

    [RelayCommand]
    public async Task Refresh() {
        IsRefreshing = true;
        Status = "Scanning...";
        Devs.Clear();
        try {
            var l = await _fac.EnumerateDevicesAsync(CancellationToken.None);
            Log($"Found {l.Count()} devices");
            foreach(var d in l) {
                Devs.Add(d);
                Log($"Device: {d.FriendlyName} ({d.DeviceId})");
            }
            Status = Devs.Count > 0 ? $"Found {Devs.Count} device(s)." : "No devices found.";
        } catch(Exception e) {
            Log($"Refresh Error: {e.Message}");
            Status = $"Error: {e.Message}";
        } finally {
            IsRefreshing = false;
        }
    }

    [RelayCommand]
    public async Task Browse() {
        Log("Browse called");
        var w = GetMainWindow();
        if(w == null) {
            Log("MainWindow is null");
            return;
        }

        var options = new FilePickerOpenOptions {
            AllowMultiple = false,
            Title = "Select ISO Image",
            FileTypeFilter = new[] {
                new FilePickerFileType("ISO Images") { Patterns = new[] { "*.iso" } },
                new FilePickerFileType("All Files") { Patterns = new[] { "*" } }
            }
        };

        var f = await w.StorageProvider.OpenFilePickerAsync(options);
        if(f.Count > 0) {
            Iso = f[0].Path.LocalPath;
            Status = "ISO selected.";
            Log($"ISO selected: {Iso}");
        }
    }

    [RelayCommand]
    public void SelectAll() {
        SelectedDevices.Clear();
        foreach(var dev in Devs) {
            SelectedDevices.Add(dev);
        }
        UpdateSelectionSummary();
        Log($"Selected all {SelectedDevices.Count} devices");
    }

    [RelayCommand]
    public void ClearAll() {
        SelectedDevices.Clear();
        UpdateSelectionSummary();
        Log("Cleared all device selections");
    }

    [RelayCommand]
    public async Task Start() {
        Log("Start called");

        if(SelectedDevices.Count == 0 && SelDev != null) {
            SelectedDevices.Add(SelDev);
            UpdateSelectionSummary();
        }

        if(SelectedDevices.Count == 0) {
            Log("Start aborted: No devices selected");
            Status = "Please select at least one device.";
            return;
        }

        if(string.IsNullOrEmpty(Iso) || !File.Exists(Iso)) {
            Log("Start aborted: ISO not found");
            Status = "Please select a valid ISO file.";
            return;
        }

        var confirmMsg = SelectedDevices.Count == 1
            ? $"{SelectedDevices[0].FriendlyName} ({SelectedDevices[0].DeviceId})"
            : $"{SelectedDevices.Count} devices:\n" +
              string.Join("\n", SelectedDevices.Select(d => $"  • {d.FriendlyName}"));

        CancelCommand.NotifyCanExecuteChanged();
        _cts = new();
        Prog = 0;

        DeviceProgress.Clear();
        foreach(var dev in SelectedDevices) {
            DeviceProgress.Add(new DeviceBurnProgress {
                DeviceName = dev.FriendlyName,
                DeviceId = dev.DeviceId,
                Progress = 0,
                Status = "Queued"
            });
        }

        Log($"Starting multi-device burn for {SelectedDevices.Count} device(s)");
        Status = $"Preparing {SelectedDevices.Count} device(s)...";

        string pt = PartitionSchemeIndex switch {
            0 => "gpt",
            1 => "mbr",
            2 => "hybrid",
            3 => "superfloppy",
            _ => "gpt"
        };

        string fs = FileSystemIndex switch {
            0 => "fat32",
            1 => "ntfs",
            2 => "exfat",
            3 => "udf",
            4 => "refs",
            _ => "fat32"
        };

        int cs = ClusterSizeIndex switch {
            1 => 512,
            2 => 1024,
            3 => 2048,
            4 => 4096,
            5 => 8192,
            6 => 16384,
            7 => 32768,
            8 => 65536,
            _ => 0
        };

        try {
            var baseConfig = new DeploymentConfiguration {
                JobName = "MultiDeviceBurn",
                TargetDevice = SelectedDevices[0],
                SourceIso = new IsoMetadata { FilePath = Iso },
                Strategy = IsRaw ? BurnStrategy.RawSectorWrite : BurnStrategy.FileSystemCopy,
                PartitionScheme = pt,
                FileSystem = fs,
                ClusterSize = cs,
                QuickFormat = QuickFormat,
                BypassWin11 = BypassWin11,
                PersistenceSize = PersistenceSize
            };

            await _multiDeviceBurner.BurnMultipleAsync(
                SelectedDevices.ToList(),
                Iso,
                baseConfig,
                UpdateDeviceProgress,
                _cts.Token
            );

            var succeeded = DeviceProgress.Count(d => d.Status.Contains("Complete"));
            var failed = DeviceProgress.Count(d => d.Status.Contains("Failed"));

            Status = succeeded == SelectedDevices.Count
                ? "✅ ALL DONE - All devices ready to boot!"
                : $"⚠️ Completed: {succeeded} succeeded, {failed} failed";

            Prog = 100;
            Log("Multi-device burn completed");
            Log($"Summary: {succeeded} succeeded, {failed} failed");
            Log($"Format: {fs.ToUpper()} on {pt.ToUpper()}");
            if(PersistenceSize > 0) Log($"Persistence: {PersistenceSize} MB");

            if(succeeded > 0) {
                Log("Auto-verifying burned devices...");
                foreach(var dev in SelectedDevices) {
                    try {
                        var verifyResult = await _verifier.VerifyDeviceAsync(dev, _cts.Token);
                        Log($"  {dev.FriendlyName}: {verifyResult.GetSummary()}");
                    } catch {
                        Log($"  {dev.FriendlyName}: Verification skipped");
                    }
                }
            }
        } catch(OperationCanceledException) {
            Status = "⚠️ Operation cancelled by user";
            Log("User cancelled multi-device burn");
            Prog = 0;
        } catch(Exception ex) {
            Status = $"❌ Error: {ex.Message}";
            Prog = 0;
            Log($"Multi-device burn error: {ex.Message}");
        } finally {
            IsBusy = false;
            CanCancel = false;
            CancelCommand.NotifyCanExecuteChanged();
            _cts?.Dispose();
            _cts = null;
        }
    }

    [RelayCommand(CanExecute = nameof(CanCancel))]
    public void Cancel() {
        if(_cts == null) return;

        Log("Cancel requested by user");
        Status = "Cancelling all operations...";
        _cts.Cancel();
        CanCancel = false;
        CancelCommand.NotifyCanExecuteChanged();
    }

    [RelayCommand]
    public async Task VerifyDevice() {
        if(SelectedDevices.Count == 0 && SelDev == null) {
            Status = "Please select a device to verify.";
            Log("Verify aborted: No device selected");
            return;
        }

        var deviceToVerify = SelectedDevices.Count > 0 ? SelectedDevices[0] : SelDev!;

        IsVerifying = true;
        Log($"Verifying bootability of {deviceToVerify.FriendlyName}...");
        Status = "Verifying...";

        try {
            var result = await _verifier.VerifyDeviceAsync(deviceToVerify, CancellationToken.None);

            VerificationResult = result.GetSummary();
            Log(VerificationResult);

            foreach(var detail in result.Details) {
                Log($"  {detail}");
            }

            foreach(var warning in result.Warnings) {
                Log($"  ⚠️ {warning}");
            }

            Status = result.IsBootable ? "✅ Drive is bootable" : "❌ Drive is NOT bootable";
        } catch(Exception ex) {
            Log($"Verification error: {ex.Message}");
            VerificationResult = $"❌ Verification failed: {ex.Message}";
            Status = "Verification failed";
        } finally {
            IsVerifying = false;
        }
    }

    [RelayCommand]
    public async Task CheckHealth() {
        if(SelDev == null) {
            Status = "Please select a device to check health.";
            return;
        }

        IsCheckingHealth = true;
        Status = "Checking drive health...";
        Log($"Checking health for {SelDev.FriendlyName}...");

        try {
            HealthReport = await _healthChecker.CheckDriveHealthAsync(SelDev.PhysicalIndex, CancellationToken.None);
            
            Log($"Health Check: {HealthReport.Status} (Score: {HealthReport.HealthScore})");
            Log($"  {HealthReport.Message}");
            if(HealthReport.Temperature > 0) Log($"  Temperature: {HealthReport.Temperature}C");
            
            Status = $"Health: {HealthReport.Status} - {HealthReport.Message}";
        } catch(Exception ex) {
            Log($"Health check failed: {ex.Message}");
            Status = "Health check failed.";
        } finally {
            IsCheckingHealth = false;
        }
    }

    [RelayCommand]
    public async Task CreateIso() {
        if(SelDev == null) {
            Status = "Please select a device to create ISO from.";
            Log("CreateISO aborted: No device selected");
            return;
        }

        Log($"Starting ISO creation from {SelDev.FriendlyName}");

        var w = GetMainWindow();
        if(w == null) {
            Log("MainWindow is null");
            return;
        }

        var saveOptions = new FilePickerSaveOptions {
            Title = "Save ISO Image",
            SuggestedFileName = $"{SelDev.FriendlyName.Replace(" ", "_")}.iso",
            FileTypeChoices = new[] {
                new FilePickerFileType("ISO Image") { Patterns = new[] { "*.iso" } }
            },
            DefaultExtension = "iso"
        };

        var result = await w.StorageProvider.SaveFilePickerAsync(saveOptions);
        if(result == null) {
            Log("ISO creation cancelled by user");
            return;
        }

        var outputPath = result.Path.LocalPath;

        IsCreatingIso = true;
        IsBusy = true;
        CanCancel = true;
        CancelCommand.NotifyCanExecuteChanged();
        _cts = new();
        Prog = 0;

        try {
            var progress = new Progress<IsoCreationProgress>(p => {
                Prog = p.PercentComplete;
                Status = p.Message;
            });

            var createResult = await _isoCreator.CreateIsoFromDeviceAsync(
                SelDev,
                outputPath,
                IsoCreationMode.RawCopy,
                progress,
                _cts.Token
            );

            if(createResult.Success) {
                Status = $"✅ ISO created successfully";
                Log($"ISO created: {outputPath}");
                Log($"File size: {FormatFileSize(createResult.FileSizeBytes)}");
                Log($"Creation time: {createResult.Duration.TotalSeconds:F1}s");
                Prog = 100;
            } else {
                Status = $"❌ ISO creation failed: {createResult.ErrorMessage}";
                Log($"ISO creation failed: {createResult.ErrorMessage}");
                Prog = 0;
            }
        } catch(OperationCanceledException) {
            Status = "⚠️ ISO creation cancelled";
            Log("User cancelled ISO creation");
            Prog = 0;
        } catch(Exception ex) {
            Status = $"❌ Error: {ex.Message}";
            Log($"ISO creation error: {ex.Message}");
            Prog = 0;
        } finally {
            IsCreatingIso = false;
            IsBusy = false;
            CanCancel = false;
            CancelCommand.NotifyCanExecuteChanged();
            _cts?.Dispose();
            _cts = null;
        }
    }

    [RelayCommand]
    public void LoadProfile() {
        if(SelectedProfile == null) return;

        Log($"Loading profile: {SelectedProfile.Name}");

        PartitionSchemeIndex = SelectedProfile.PartitionScheme switch {
            "gpt" => 0,
            "mbr" => 1,
            "hybrid" => 2,
            "superfloppy" => 3,
            _ => 0
        };

        FileSystemIndex = SelectedProfile.FileSystem switch {
            "fat32" => 0,
            "ntfs" => 1,
            "exfat" => 2,
            "udf" => 3,
            "refs" => 4,
            _ => 0
        };

        ClusterSizeIndex = SelectedProfile.ClusterSize switch {
            512 => 1,
            1024 => 2,
            2048 => 3,
            4096 => 4,
            8192 => 5,
            16384 => 6,
            32768 => 7,
            65536 => 8,
            _ => 0
        };

        QuickFormat = SelectedProfile.QuickFormat;
        BypassWin11 = SelectedProfile.BypassWin11;
        IsRaw = SelectedProfile.IsRaw;
        PersistenceSize = SelectedProfile.PersistenceSize;

        Status = $"Loaded profile: {SelectedProfile.Name}";
        Log($"Profile loaded successfully");
    }

    [RelayCommand]
    public void SaveProfile() {
        if(string.IsNullOrWhiteSpace(NewProfileName)) {
            Status = "Please enter a profile name.";
            return;
        }

        var pt = PartitionSchemeIndex switch {
            0 => "gpt",
            1 => "mbr",
            2 => "hybrid",
            3 => "superfloppy",
            _ => "gpt"
        };

        var fs = FileSystemIndex switch {
            0 => "fat32",
            1 => "ntfs",
            2 => "exfat",
            3 => "udf",
            4 => "refs",
            _ => "fat32"
        };

        var cs = ClusterSizeIndex switch {
            1 => 512,
            2 => 1024,
            3 => 2048,
            4 => 4096,
            5 => 8192,
            6 => 16384,
            7 => 32768,
            8 => 65536,
            _ => 0
        };

        var profile = new BurnProfile {
            Name = NewProfileName,
            PartitionScheme = pt,
            FileSystem = fs,
            ClusterSize = cs,
            QuickFormat = QuickFormat,
            BypassWin11 = BypassWin11,
            IsRaw = IsRaw,
            PersistenceSize = PersistenceSize
        };

        _profileManager.SaveProfile(profile);
        RefreshProfiles();

        Status = $"Profile '{NewProfileName}' saved successfully";
        Log($"Saved profile: {NewProfileName}");
        NewProfileName = "";
    }

    [RelayCommand]
    public void DeleteProfile() {
        if(SelectedProfile == null || SelectedProfile.IsDefault) {
            Status = "Cannot delete default profiles.";
            return;
        }

        var profileName = SelectedProfile.Name;
        _profileManager.DeleteProfile(profileName);
        RefreshProfiles();

        Status = $"Profile '{profileName}' deleted";
        Log($"Deleted profile: {profileName}");
        SelectedProfile = null;
    }
}





======================================
FILE: UI\Views\ConfirmationDialog.axaml
======================================

<Window xmlns="https://github.com/avaloniaui" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" x:Class="ProUSB.UI.Views.ConfirmationDialog" Width="400" Height="220" SystemDecorations="BorderOnly" WindowStartupLocation="CenterOwner" Background="Transparent" TransparencyLevelHint="Mica">
    <Border Background="#1E1E1E" BorderBrush="#333333" BorderThickness="1" CornerRadius="8" Padding="24" BoxShadow="0 8 24 0 #66000000">
        <StackPanel Spacing="20">
            <StackPanel Spacing="8">
                <TextBlock Text="⚠️ WARNING" Foreground="#FF453A" FontSize="20" FontWeight="SemiBold" HorizontalAlignment="Center"/>
                <TextBlock Text="ALL DATA WILL BE ERASED" Foreground="#E0E0E0" FontSize="14" HorizontalAlignment="Center"/>
            </StackPanel>
            
            <Border Background="#2D2D2D" CornerRadius="6" Padding="16">
                <StackPanel Spacing="4">
                    <TextBlock x:Name="N" FontWeight="Medium" Foreground="White" HorizontalAlignment="Center" TextWrapping="Wrap"/>
                    <TextBlock x:Name="S" FontSize="12" Foreground="#A0A0A0" HorizontalAlignment="Center"/>
                </StackPanel>
            </Border>
            
            <Grid ColumnDefinitions="*,12,*">
                <Button Grid.Column="0" Click="OnCancelClick" Background="#3D3D3D" Foreground="White" CornerRadius="4" HorizontalAlignment="Stretch" HorizontalContentAlignment="Center" Cursor="Hand">
                    <TextBlock Text="CANCEL" Margin="0,4"/>
                </Button>
                <Button Grid.Column="2" Click="OnConfirmClick" Background="#D13438" Foreground="White" CornerRadius="4" HorizontalAlignment="Stretch" HorizontalContentAlignment="Center" Cursor="Hand">
                    <TextBlock Text="ERASE &amp; BURN" FontWeight="SemiBold" Margin="0,4"/>
                </Button>
            </Grid>
        </StackPanel>
    </Border>
</Window>


======================================
FILE: UI\Views\ConfirmationDialog.axaml.cs
======================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Interactivity;
namespace ProUSB.UI.Views;
public partial class ConfirmationDialog : Window {
    public ConfirmationDialog(){InitializeComponent();}
    private void InitializeComponent()=>AvaloniaXamlLoader.Load(this);
    public static ConfirmationDialog Create(string n, long s, string id){
        var d=new ConfirmationDialog();
        d.FindControl<TextBlock>("N")!.Text=n;
        d.FindControl<TextBlock>("S")!.Text=$"{s/1024.0/1024.0/1024.0:F2} GB";
        return d;
    }
    private void OnConfirmClick(object s,RoutedEventArgs e)=>Close(true);
    private void OnCancelClick(object s,RoutedEventArgs e)=>Close(false);
}



======================================
FILE: UI\Views\MainView.axaml
======================================

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="using:ProUSB.UI.ViewModels"
             xmlns:cv="using:Avalonia.Data.Converters"
             x:Class="ProUSB.UI.Views.MainView"
             x:DataType="vm:MainViewModel"
             DragDrop.AllowDrop="True">

    <UserControl.Styles>
        <!-- Typography -->
        <Style Selector="TextBlock.h1"><Setter Property="FontSize" Value="20"/><Setter Property="FontWeight" Value="SemiBold"/><Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/></Style>
        <Style Selector="TextBlock.h2"><Setter Property="FontSize" Value="14"/><Setter Property="FontWeight" Value="Medium"/><Setter Property="Foreground" Value="{DynamicResource TextSecondary}"/><Setter Property="Margin" Value="0,0,0,8"/></Style>
        <Style Selector="TextBlock.label"><Setter Property="FontSize" Value="12"/><Setter Property="Foreground" Value="{DynamicResource TextTertiary}"/><Setter Property="Margin" Value="0,0,0,4"/></Style>
        
        <!-- Controls -->
        <Style Selector="Border.card">
            <Setter Property="Background" Value="{DynamicResource CardBackground}"/>
            <Setter Property="CornerRadius" Value="8"/>
            <Setter Property="Padding" Value="16"/>
            <Setter Property="Margin" Value="0,0,0,16"/>
            <Setter Property="BoxShadow" Value="0 4 12 0 #40000000"/>
        </Style>
        
        <Style Selector="ComboBox">
            <Setter Property="Background" Value="{DynamicResource ControlBackground}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="12,8"/>
            <Setter Property="HorizontalAlignment" Value="Stretch"/>
            <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
        </Style>
        
        <Style Selector="TextBox">
            <Setter Property="Background" Value="{DynamicResource ControlBackground}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="12,8"/>
            <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
            <Setter Property="CaretBrush" Value="White"/>
        </Style>

        <Style Selector="Button.primary">
            <Setter Property="Background" Value="#6366F1"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="20,10"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>
        <Style Selector="Button.primary:pointerover"><Setter Property="Background" Value="#4F46E5"/></Style>
        <Style Selector="Button.primary:disabled"><Setter Property="Background" Value="#333333"/><Setter Property="Foreground" Value="#666666"/></Style>

        <Style Selector="Button.secondary">
            <Setter Property="Background" Value="{DynamicResource ControlBackground}"/>
            <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="12,8"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>
        <Style Selector="Button.secondary:pointerover"><Setter Property="Background" Value="#4D4D4D"/></Style>
        
        <Style Selector="Button.eject">
            <Setter Property="Background" Value="#FF6B35"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="8,6"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>
        <Style Selector="Button.eject:pointerover"><Setter Property="Background" Value="#FF7F4D"/></Style>

        <Style Selector="CheckBox">
            <Setter Property="Foreground" Value="{DynamicResource TextSecondary}"/>
        </Style>
        
        <Style Selector="NumericUpDown">
            <Setter Property="Background" Value="{DynamicResource ControlBackground}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
        </Style>
        
        <!-- Drag-Drop Visual Feedback -->
        <Style Selector="Border.drop-zone">
            <Setter Property="BorderThickness" Value="2"/>
            <Setter Property="BorderBrush" Value="Transparent"/>
            <Setter Property="CornerRadius" Value="8"/>
        </Style>
        <Style Selector="Border.drop-zone:dragging">
            <Setter Property="BorderBrush" Value="#6366F1"/>
            <Setter Property="Background" Value="#200078D4"/>
        </Style>
    </UserControl.Styles>

    <UserControl.Resources>
        <!-- Dark Theme Colors -->
        <Color x:Key="DarkWindowBackground">#0F0F12</Color>
        <Color x:Key="DarkCardBackground">#1A1A20</Color>
        <Color x:Key="DarkControlBackground">#09090B</Color>
        <Color x:Key="DarkTextPrimary">#FFFFFF</Color>
        <Color x:Key="DarkTextSecondary">#E0E0E0</Color>
        <Color x:Key="DarkTextTertiary">#A0A0A0</Color>
        
        <!-- Light Theme Colors -->
        <Color x:Key="LightWindowBackground">#F5F5F5</Color>
        <Color x:Key="LightCardBackground">#FFFFFF</Color>
        <Color x:Key="LightControlBackground">#EEEEEE</Color>
        <Color x:Key="LightTextPrimary">#0F0F12</Color>
        <Color x:Key="LightTextSecondary">#404040</Color>
        <Color x:Key="LightTextTertiary">#666666</Color>
        
        <SolidColorBrush x:Key="WindowBackground" Color="{DynamicResource DarkWindowBackground}"/>
        <SolidColorBrush x:Key="CardBackground" Color="{DynamicResource DarkCardBackground}"/>
        <SolidColorBrush x:Key="ControlBackground" Color="{DynamicResource DarkControlBackground}"/>
        <SolidColorBrush x:Key="TextPrimary" Color="{DynamicResource DarkTextPrimary}"/>
        <SolidColorBrush x:Key="TextSecondary" Color="{DynamicResource DarkTextSecondary}"/>
        <SolidColorBrush x:Key="TextTertiary" Color="{DynamicResource DarkTextTertiary}"/>
    </UserControl.Resources>

    <Grid RowDefinitions="40,*,Auto">
        <!-- Title Bar -->
        <Grid Grid.Row="0" ColumnDefinitions="Auto,*,Auto" Background="Transparent">
            <StackPanel Grid.Column="0" Orientation="Horizontal" Spacing="10" Margin="16,0">
                <TextBlock Text="⚡" VerticalAlignment="Center"/>
                <TextBlock Text="ProUSB Media Suite" VerticalAlignment="Center" FontWeight="SemiBold" FontSize="14"/>
            </StackPanel>
            
            <!-- Theme Toggle -->
            <StackPanel Grid.Column="2" Orientation="Horizontal" Spacing="8" Margin="0,0,120,0" IsHitTestVisible="True">
                <Button Command="{Binding ToggleThemeCommand}" Classes="secondary" Padding="8,4" ToolTip.Tip="Toggle Dark/Light Mode">
                    <TextBlock Text="🌙"/>
                </Button>
                <Button Command="{Binding ShowHistoryCommand}" Classes="secondary" Padding="8,4" ToolTip.Tip="View Burn History">
                    <TextBlock Text="📊"/>
                </Button>
                <Button Command="{Binding ShowLibraryCommand}" Classes="secondary" Padding="8,4" ToolTip.Tip="ISO Library">
                    <TextBlock Text="📚"/>
                </Button>
            </StackPanel>
        </Grid>

        <!-- Main Content -->
        <Grid Grid.Row="1" ColumnDefinitions="*,*" Margin="16">
            <!-- Left Column: Source & Destination -->
            <ScrollViewer Grid.Column="0" Margin="0,0,8,0">
                <StackPanel>
                    <!-- Device Selection -->
                    <TextBlock Text="DRIVE PROPERTIES" Classes="h2"/>
                    <Border Classes="card">
                        <StackPanel Spacing="12">
                            <StackPanel>
                                <TextBlock Text="Device" Classes="label"/>
                                <Grid ColumnDefinitions="*,8,Auto,8,Auto">
                                    <ComboBox Grid.Column="0" ItemsSource="{Binding Devs}" SelectedItem="{Binding SelDev}" PlaceholderText="Select USB Drive...">
                                        <ComboBox.ItemTemplate>
                                            <DataTemplate>
                                                <StackPanel>
                                                    <TextBlock Text="{Binding FriendlyName}" FontWeight="Medium"/>
                                                    <TextBlock Text="{Binding TotalSize}" FontSize="11" Foreground="#A0A0A0"/>
                                                </StackPanel>
                                            </DataTemplate>
                                        </ComboBox.ItemTemplate>
                                    </ComboBox>
                                    <Button Grid.Column="2" Command="{Binding RefreshCommand}" Classes="secondary" ToolTip.Tip="Refresh Devices">
                                        <TextBlock Text="⟳"/>
                                    </Button>
                                    <Button Grid.Column="4" 
                                            Command="{Binding EjectDeviceCommand}" 
                                            Classes="eject" 
                                            ToolTip.Tip="Safely Eject Device"
                                            IsEnabled="{Binding SelDev, Converter={x:Static cv:ObjectConverters.IsNotNull}}">
                                        <TextBlock Text="⏏"/>
                                    </Button>
                                </Grid>
                            </StackPanel>

                            <StackPanel>
                                <TextBlock Text="Boot Selection" Classes="label"/>
                                <Border Classes="drop-zone" Name="IsoDropZone" Padding="0">
                                    <Grid ColumnDefinitions="*,8,Auto">
                                        <TextBox Grid.Column="0" Text="{Binding Iso}" Watermark="Drag ISO here or click SELECT" IsReadOnly="True"/>
                                        <Button Grid.Column="2" Command="{Binding BrowseCommand}" Classes="secondary">
                                            <TextBlock Text="SELECT"/>
                                        </Button>
                                    </Grid>
                                </Border>
                                <TextBlock Text="💡 Tip: Drag and drop ISO files directly here!" FontSize="10" Foreground="#808080" Margin="0,4,0,0"/>
                            </StackPanel>
                            
                            <StackPanel IsVisible="{Binding SelDev, Converter={x:Static cv:ObjectConverters.IsNotNull}}">
                                <TextBlock Text="⚠️ Warning: All data on device will be destroyed." Foreground="#FF453A" FontSize="11"/>
                            </StackPanel>
                        </StackPanel>
                    </Border>

                    <!-- Format Options -->
                    <TextBlock Text="FORMAT OPTIONS" Classes="h2"/>
                    <Border Classes="card">
                        <StackPanel Spacing="12">
                            <StackPanel>
                                <TextBlock Text="Partition Scheme" Classes="label"/>
                                <ComboBox ItemsSource="{Binding PartitionSchemes}" SelectedIndex="{Binding PartitionSchemeIndex}"/>
                            </StackPanel>

                            <StackPanel>
                                <TextBlock Text="File System" Classes="label"/>
                                <ComboBox ItemsSource="{Binding FileSystems}" SelectedIndex="{Binding FileSystemIndex}"/>
                            </StackPanel>

                            <StackPanel>
                                <TextBlock Text="Cluster Size" Classes="label"/>
                                <ComboBox ItemsSource="{Binding ClusterSizes}" SelectedIndex="{Binding ClusterSizeIndex}"/>
                            </StackPanel>
                            
                            <Expander Header="Advanced Format Options" Foreground="#A0A0A0">
                                <StackPanel Spacing="12" Margin="0,8,0,0">
                                    <CheckBox IsChecked="{Binding QuickFormat}" Content="Quick Format"/>
                                    <CheckBox IsChecked="{Binding BypassWin11}" Content="Bypass Windows 11 Requirements (TPM/Secure Boot)"/>
                                    <CheckBox IsChecked="{Binding IsRaw}" Content="List USB Hard Drives"/>
                                    
                                    <!-- Persistence Size -->
                                    <StackPanel Spacing="4">
                                        <TextBlock Text="Persistence Size (MB) - For Linux Live USBs" Classes="label" Foreground="#A0A0A0"/>
                                        <Grid ColumnDefinitions="*,8,Auto">
                                            <NumericUpDown Grid.Column="0" 
                                                         Value="{Binding PersistenceSize}" 
                                                         Minimum="0" 
                                                         Maximum="32768" 
                                                         Increment="128"
                                                         FormatString="N0"
                                                         Padding="12,8"/>
                                            <TextBlock Grid.Column="2" 
                                                     Text="0 = Disabled" 
                                                     VerticalAlignment="Center" 
                                                     FontSize="10" 
                                                     Foreground="#808080"/>
                                        </Grid>
                                        <TextBlock Text="💡 Creates casper-rw file for persistent storage on Ubuntu/Mint Live USBs" 
                                                 FontSize="10" 
                                                 Foreground="#808080" 
                                                 TextWrapping="Wrap"/>
                                    </StackPanel>
                                </StackPanel>
                            </Expander>
                        </StackPanel>
                    </Border>
                </StackPanel>
            </ScrollViewer>

            <!-- Right Column: Status & Log -->
            <Grid Grid.Column="1" RowDefinitions="*,Auto" Margin="8,0,0,0">
                <!-- Log Console -->
                <Border Grid.Row="0" Classes="card" Background="#111111" BorderBrush="#333333" BorderThickness="1">
                    <Grid RowDefinitions="Auto,*">
                        <TextBlock Grid.Row="0" Text="LOG" Classes="label" Margin="0,0,0,8"/>
                        <TextBox Grid.Row="1" Text="{Binding LogText}" FontFamily="Consolas, Monospace" FontSize="11" Foreground="#00FF00" TextWrapping="Wrap" IsReadOnly="True" Background="Transparent" BorderThickness="0" CaretBrush="Transparent"/>
                    </Grid>
                </Border>

                <!-- Status & Action -->
                <StackPanel Grid.Row="1" Spacing="12">
                    <Border Classes="card" Padding="12">
                        <StackPanel Spacing="8">
                            <Grid ColumnDefinitions="*,Auto">
                                <StackPanel>
                                    <TextBlock Text="Status" Classes="label"/>
                                    <TextBlock Text="{Binding Status}" Foreground="#6366F1" FontWeight="SemiBold"/>
                                </StackPanel>
                                <!-- Estimated Time Remaining -->
                                <StackPanel Grid.Column="1" HorizontalAlignment="Right" IsVisible="{Binding TimeRemainingText, Converter={x:Static cv:StringConverters.IsNotNullOrEmpty}}">
                                    <TextBlock Text="Time Remaining" Classes="label" HorizontalAlignment="Right"/>
                                    <TextBlock Text="{Binding TimeRemainingText}" Foreground="#10B981" FontWeight="SemiBold" HorizontalAlignment="Right"/>
                                </StackPanel>
                            </Grid>
                            <ProgressBar Value="{Binding Prog}" Maximum="100" Height="6" Background="#333333" Foreground="#6366F1" CornerRadius="3"/>
                            <!-- Speed Indicator -->
                            <TextBlock Text="{Binding SpeedText}" FontSize="10" Foreground="#A0A0A0" HorizontalAlignment="Right" IsVisible="{Binding SpeedText, Converter={x:Static cv:StringConverters.IsNotNullOrEmpty}}"/>
                        </StackPanel>
                    </Border>

                    <Grid ColumnDefinitions="*,8,Auto">
                        <Button Command="{Binding StartCommand}" Classes="primary" HorizontalAlignment="Stretch" IsEnabled="{Binding !IsBusy}">
                            <TextBlock Text="START"/>
                        </Button>
                        
                        <Button Grid.Column="2" 
                                Command="{Binding CancelCommand}" 
                                Classes="secondary" 
                                IsEnabled="{Binding CanCancel}"
                                Background="#FF453A">
                            <TextBlock Text="CANCEL"/>
                        </Button>
                    </Grid>
                    
                    <!-- Close button logic might need adjustment if embedded -->
                </StackPanel>
            </Grid>
        </Grid>

        <!-- Footer / Status Bar -->
        <Border Grid.Row="2" Background="{DynamicResource CardBackground}" Padding="12,4">
            <Grid ColumnDefinitions="Auto,*,Auto,8,Auto">
                <TextBlock Text="Ready" FontSize="11" Foreground="#808080"/>
                <TextBlock Grid.Column="2" Text="✅ System Drive Protection Active" FontSize="11" Foreground="#10B981"/>
                <TextBlock Grid.Column="4" Text="{Binding VersionText}" FontSize="11" Foreground="#808080"/>
            </Grid>
        </Border>
    </Grid>
</UserControl>



======================================
FILE: UI\Views\MainView.axaml.cs
======================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace ProUSB.UI.Views;

public partial class MainView : UserControl
{
    public MainView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}




======================================
FILE: UI\Views\MainWindow.axaml
======================================

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:ProUSB.UI.ViewModels"
        xmlns:v="using:ProUSB.UI.Views"
        x:Class="ProUSB.UI.Views.MainWindow"
        x:DataType="vm:MainViewModel"
        Title="ProUSB Media Suite"
        Width="900" Height="700"
        MinWidth="700" MinHeight="600"
        WindowStartupLocation="CenterScreen"
        ExtendClientAreaToDecorationsHint="True"
        ExtendClientAreaTitleBarHeightHint="40"
        Background="{DynamicResource WindowBackground}"
        TransparencyLevelHint="Mica"
        Foreground="{DynamicResource TextPrimary}"
        DragDrop.AllowDrop="True">
    
    <v:MainView />
</Window>



======================================
FILE: UI\Views\MainWindow.axaml.cs
======================================

using Avalonia.Controls;
namespace ProUSB.UI.Views;
public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } }



======================================
FILE: UI\ViewLocator.cs
======================================

using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using CommunityToolkit.Mvvm.ComponentModel;
namespace ProUSB.UI;
public class ViewLocator : IDataTemplate {
    public Control? Build(object? d) {
        if (d is null) return null;
        var t = Type.GetType(d.GetType().FullName!.Replace("ViewModel", "View"));
        return t!=null ? (Control)Activator.CreateInstance(t)! : new TextBlock { Text="Missing View" };
    }
    public bool Match(object? d) => d is ObservableObject;
}



======================================
FILE: plugin.json
======================================

{
  "id": "prousb",
  "name": "ProUSB",
  "version": "1.0.0",
  "description": "USB bootable media creator",
  "author": "Mass Suite Team",
  "icon": "💾",
  "entryAssembly": "ProUSB.dll",
  "entryType": "ProUSB.ProUsbModule",
  "dependencies": [],
  "permissions": ["disk_access", "filesystem"],
  "enabled": true
}



======================================
FILE: ProUSB.csproj
======================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <LangVersion>14</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    
    <!-- Explicitly disable all auto-generated assembly attributes -->
    <GenerateAssemblyCompanyAttribute>false</GenerateAssemblyCompanyAttribute>
    <GenerateAssemblyConfigurationAttribute>false</GenerateAssemblyConfigurationAttribute>
    <GenerateAssemblyFileVersionAttribute>false</GenerateAssemblyFileVersionAttribute>
    <GenerateAssemblyInformationalVersionAttribute>false</GenerateAssemblyInformationalVersionAttribute>
    <GenerateAssemblyProductAttribute>false</GenerateAssemblyProductAttribute>
    <GenerateAssemblyTitleAttribute>false</GenerateAssemblyTitleAttribute>
    <GenerateAssemblyVersionAttribute>false</GenerateAssemblyVersionAttribute>
    <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Avalonia" Version="11.3.9" />
    <PackageReference Include="Avalonia.Desktop" Version="11.3.9" />
    <PackageReference Include="Avalonia.Themes.Fluent" Version="11.3.9" />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    <PackageReference Include="DiscUtils.Iso9660" Version="0.16.13" />
    <PackageReference Include="DiscUtils.Udf" Version="0.16.13" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="10.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="10.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="10.0.0" />
    <PackageReference Include="System.Management" Version="10.0.0" />
  </ItemGroup>

  <ItemGroup>
    <AvaloniaResource Include="Resources\os_catalog.json" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Mass.Core\Mass.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="plugin.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>



======================================
FILE: ProUsbModule.cs
======================================

using Mass.Core.Abstractions;
using Mass.Core.Plugins;
using Microsoft.Extensions.DependencyInjection;
using ProUSB.Domain.Drivers;
using ProUSB.Domain.Services;
using ProUSB.Infrastructure;
using ProUSB.Infrastructure.Drivers.Windows;
using ProUSB.Infrastructure.DiskManagement;
using ProUSB.Services.Burn;
using ProUSB.Services.Burn.Strategies;
using ProUSB.Services.Security;
using ProUSB.Services.Iso;
using ProUSB.Services.Logging;
using ProUSB.Services.Verification;
using ProUSB.Services.Diagnostics;
using ProUSB.Services.IsoCreation;
using ProUSB.Services.Profiles;
using ProUSB.Services.PxeBoot;
using ProUSB.Services.IsoDownload;
using ProUSB.UI.ViewModels;

namespace ProUSB;

public class ProUsbModule : IModule
{
    public PluginManifest Manifest => new()
    {
        Id = "prousb",
        Name = "ProUSB",
        Version = "1.0.0",
        Description = "USB bootable media creator",
        Author = "Mass Suite Team",
        Icon = "💾",
        EntryAssembly = "ProUSB.dll",
        EntryType = "ProUSB.ProUsbModule",
        Enabled = true
    };

    public void RegisterServices(IServiceCollection s)
    {
        s.AddSingleton<PortablePathManager>();
        s.AddSingleton<FileLogger>();
        s.AddSingleton<IDriverFactory, WindowsDriverFactory>();
        s.AddSingleton<NativeDiskFormatter>();
        s.AddSingleton<ISafetyGuard, StandardSafetyGuard>();
        s.AddSingleton<IsoIntegrityVerifier>();
        s.AddSingleton<IBurnStrategy, RawPipelinedWriteStrategy>();
        s.AddSingleton<IBurnStrategy, FileSystemDeploymentStrategy>();
        s.AddSingleton<ParallelBurnService>();
        s.AddSingleton<MultiDeviceBurnOrchestrator>();
        s.AddSingleton<BootVerificationService>();
        s.AddSingleton<SmartHealthChecker>();
        s.AddSingleton<IsoCreationService>();
        s.AddSingleton<ProfileManager>();
        s.AddSingleton<PxeBootImageService>();
        s.AddSingleton<OsCatalogService>();
        s.AddSingleton<IsoDownloadService>();
        s.AddSingleton<Services.IUsbBurnerService, Services.UsbBurnerService>();
        s.AddTransient<MainViewModel>();
    }

    public Task InitializeAsync(IServiceProvider services, CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    public Task ActivateAsync(CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    public Task DeactivateAsync(CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    public Task UnloadAsync(CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }
}





================================================================================
END OF PROUSB DOCUMENTATION
================================================================================

