================================================================================
MASS.CORE SOURCE CODE DOCUMENTATION
================================================================================
Created: 2025-12-01
Purpose: Complete source code documentation for Mass.Core project
================================================================================

PROJECT: Mass.Core
DESCRIPTION: Shared core functionality and plugin system for Mass Suite
TECHNOLOGY: .NET 10.0, C# 14
================================================================================

======================================
FILE: Abstractions\IConfigurationService.cs
======================================

namespace Mass.Core.Abstractions;

public interface IConfigurationService
{
    T Get<T>(string key, T defaultValue);
    void Set<T>(string key, T value);
    Task SaveAsync();
    Task LoadAsync();
    void Reset();
}



======================================
FILE: Abstractions\IDialogService.cs
======================================

using System.Threading.Tasks;

namespace Mass.Core.Abstractions;

public interface IDialogService
{
    Task ShowErrorDialogAsync(string title, string message, bool canRetry = false);
    Task ShowMessageDialogAsync(string title, string message);
}



======================================
FILE: Abstractions\IModule.cs
======================================

using Mass.Core.Plugins;
using Microsoft.Extensions.DependencyInjection;

namespace Mass.Core.Abstractions;

public interface IModule
{
    PluginManifest Manifest { get; }
    void RegisterServices(IServiceCollection services);
    Task InitializeAsync(IServiceProvider services, CancellationToken cancellationToken = default);
    Task ActivateAsync(CancellationToken cancellationToken = default);
    Task DeactivateAsync(CancellationToken cancellationToken = default);
    Task UnloadAsync(CancellationToken cancellationToken = default);
}



======================================
FILE: Abstractions\INavigable.cs
======================================

namespace Mass.Core.Abstractions;

public interface INavigable
{
    void OnNavigatedTo(object? parameter);
    void OnNavigatedFrom();
}



======================================
FILE: Abstractions\INavigationService.cs
======================================

namespace Mass.Core.Abstractions;

public interface INavigationService
{
    void NavigateTo<TViewModel>() where TViewModel : UI.ViewModelBase;
    void NavigateTo(Type viewModelType);
    void GoBack();
    bool CanGoBack { get; }
}



======================================
FILE: Abstractions\IPlugin.cs
======================================

namespace Mass.Core.Abstractions;

public interface IPlugin
{
    PluginMetadata Metadata { get; }
    Task InitializeAsync(IServiceProvider services, CancellationToken cancellationToken = default);
    Task<PluginCapabilities> GetCapabilitiesAsync(CancellationToken cancellationToken = default);
    Task ShutdownAsync(CancellationToken cancellationToken = default);
}

public sealed record PluginMetadata(
    string Id,
    string Name,
    string Version,
    string Author,
    string Description,
    string? IconPath = null,
    IReadOnlyList<string>? Dependencies = null);

[Flags]
public enum PluginCapabilities
{
    None = 0,
    ProvidesTools = 1 << 0,
    ProvidesWorkflows = 1 << 1,
    ProvidesHealthChecks = 1 << 2,
    ProvidesUI = 1 << 3,
    ProvidesCLI = 1 << 4
}



======================================
FILE: Abstractions\IService.cs
======================================

namespace Mass.Core.Abstractions;

public interface IService
{
    string ServiceName { get; }
    Task StartAsync(CancellationToken cancellationToken = default);
    Task StopAsync(CancellationToken cancellationToken = default);
    ServiceStatus GetStatus();
}

public enum ServiceStatus
{
    Stopped,
    Starting,
    Running,
    Stopping,
    Failed
}



======================================
FILE: Abstractions\IWorkflowActivity.cs
======================================

namespace Mass.Core.Abstractions;

public interface IWorkflowActivity
{
    string ActivityName { get; }
    string Description { get; }
    Task<ActivityResult> ExecuteAsync(ActivityContext context, CancellationToken cancellationToken = default);
}

public sealed record ActivityContext(
    IReadOnlyDictionary<string, object> Inputs,
    IDictionary<string, object> Outputs,
    IServiceProvider Services);

public sealed record ActivityResult(
    ActivityStatus Status,
    string? Message = null,
    Exception? Exception = null,
    TimeSpan? Duration = null)
{
    public static ActivityResult Success(string? message = null, TimeSpan? duration = null) =>
        new(ActivityStatus.Success, message, null, duration);

    public static ActivityResult Failure(string message, Exception? exception = null, TimeSpan? duration = null) =>
        new(ActivityStatus.Failure, message, exception, duration);

    public static ActivityResult Skipped(string reason, TimeSpan? duration = null) =>
        new(ActivityStatus.Skipped, reason, null, duration);

    public static ActivityResult Retry(string reason, TimeSpan? duration = null) =>
        new(ActivityStatus.Retry, reason, null, duration);
}

public enum ActivityStatus
{
    Success,
    Failure,
    Skipped,
    Retry
}



======================================
FILE: Configuration\AppSettings.cs
======================================

namespace Mass.Core.Configuration;

public class AppSettings
{
    public string Theme { get; set; } = "Dark";
    public string Language { get; set; } = "en-US";
    public string? StartupModule { get; set; }
    public bool CheckForUpdates { get; set; } = true;
    public bool MinimizeToTray { get; set; } = false;
    public TelemetrySettings Telemetry { get; set; } = new();
}



======================================
FILE: Configuration\JsonConfigurationService.cs
======================================

using System.Text.Json;
using Mass.Core.Abstractions;

namespace Mass.Core.Configuration;

public class JsonConfigurationService : IConfigurationService
{
    private readonly string _filePath;
    private readonly Dictionary<string, object> _cache = new();
    private readonly SemaphoreSlim _lock = new(1, 1);
    private bool _isDirty;

    public JsonConfigurationService(string filePath)
    {
        _filePath = filePath;
        Directory.CreateDirectory(Path.GetDirectoryName(_filePath)!);
    }

    public T Get<T>(string key, T defaultValue)
    {
        if (_cache.TryGetValue(key, out var value))
        {
            if (value is JsonElement element)
            {
                return element.Deserialize<T>() ?? defaultValue;
            }
            return (T)value;
        }
        return defaultValue;
    }

    public void Set<T>(string key, T value)
    {
        _cache[key] = value!;
        _isDirty = true;
    }

    public async Task SaveAsync()
    {
        if (!_isDirty) return;

        await _lock.WaitAsync();
        try
        {
            var json = JsonSerializer.Serialize(_cache, new JsonSerializerOptions
            {
                WriteIndented = true
            });
            await File.WriteAllTextAsync(_filePath, json);
            _isDirty = false;
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task LoadAsync()
    {
        await _lock.WaitAsync();
        try
        {
            if (!File.Exists(_filePath))
            {
                _cache.Clear();
                return;
            }

            var json = await File.ReadAllTextAsync(_filePath);
            var data = JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(json);
            
            if (data != null)
            {
                _cache.Clear();
                foreach (var kvp in data)
                {
                    _cache[kvp.Key] = kvp.Value;
                }
            }
        }
        finally
        {
            _lock.Release();
        }
    }

    public void Reset()
    {
        _cache.Clear();
        _isDirty = true;
    }
}



======================================
FILE: Configuration\TelemetrySettings.cs
======================================

namespace Mass.Core.Configuration;

public class TelemetrySettings
{
    public bool Enabled { get; set; } = false;
    public bool ConsentDecisionMade { get; set; } = false;
    public string InstallationId { get; set; } = Guid.NewGuid().ToString();
}



======================================
FILE: Configuration\UserPreferences.cs
======================================

namespace Mass.Core.Configuration;

public class UserPreferences
{
    public List<string> RecentFiles { get; set; } = new();
    public List<string> FavoriteModules { get; set; } = new();
    public WindowState? LastWindowState { get; set; }
}

public class WindowState
{
    public int X { get; set; }
    public int Y { get; set; }
    public int Width { get; set; } = 900;
    public int Height { get; set; } = 700;
    public bool IsMaximized { get; set; }
}



======================================
FILE: Domain\Models\Deployment.cs
======================================

namespace Mass.Core.Domain.Models;

public sealed class Deployment : Entity<Guid>
{
    public string Name { get; private set; }
    public DeploymentType Type { get; private set; }
    public DeploymentStatus Status { get; private set; }
    public DateTime? StartedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    public string? ErrorMessage { get; private set; }

    private Deployment(Guid id, string name, DeploymentType type) : base(id)
    {
        Name = name;
        Type = type;
        Status = DeploymentStatus.Pending;
    }

    public static Deployment Create(string name, DeploymentType type)
    {
        var deployment = new Deployment(Guid.NewGuid(), name, type);
        deployment.RaiseDomainEvent(new DeploymentCreatedEvent(deployment.Id, name, type));
        return deployment;
    }

    public void Start()
    {
        if (Status != DeploymentStatus.Pending)
            throw new InvalidOperationException($"Cannot start deployment in {Status} status");

        Status = DeploymentStatus.Running;
        StartedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new DeploymentStartedEvent(Id));
    }

    public void Complete()
    {
        if (Status != DeploymentStatus.Running)
            throw new InvalidOperationException($"Cannot complete deployment in {Status} status");

        Status = DeploymentStatus.Completed;
        CompletedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new DeploymentCompletedEvent(Id));
    }

    public void Fail(string errorMessage)
    {
        Status = DeploymentStatus.Failed;
        CompletedAt = DateTime.UtcNow;
        ErrorMessage = errorMessage;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new DeploymentFailedEvent(Id, errorMessage));
    }
}

public enum DeploymentType
{
    UsbProvisioning,
    PxeBoot,
    Combined
}

public enum DeploymentStatus
{
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled
}

public sealed class DeploymentCreatedEvent : DomainEvent
{
    public Guid DeploymentId { get; }
    public string Name { get; }
    public DeploymentType Type { get; }

    public DeploymentCreatedEvent(Guid deploymentId, string name, DeploymentType type)
    {
        DeploymentId = deploymentId;
        Name = name;
        Type = type;
    }
}

public sealed class DeploymentStartedEvent : DomainEvent
{
    public Guid DeploymentId { get; }

    public DeploymentStartedEvent(Guid deploymentId)
    {
        DeploymentId = deploymentId;
    }
}

public sealed class DeploymentCompletedEvent : DomainEvent
{
    public Guid DeploymentId { get; }

    public DeploymentCompletedEvent(Guid deploymentId)
    {
        DeploymentId = deploymentId;
    }
}

public sealed class DeploymentFailedEvent : DomainEvent
{
    public Guid DeploymentId { get; }
    public string ErrorMessage { get; }

    public DeploymentFailedEvent(Guid deploymentId, string errorMessage)
    {
        DeploymentId = deploymentId;
        ErrorMessage = errorMessage;
    }
}



======================================
FILE: Domain\Models\Image.cs
======================================

namespace Mass.Core.Domain.Models;

public sealed class Image : Entity<Guid>
{
    public string Name { get; private set; }
    public string FilePath { get; private set; }
    public ImageType Type { get; private set; }
    public long SizeBytes { get; private set; }
    public string? Description { get; private set; }
    public bool IsActive { get; private set; }

    private Image(Guid id, string name, string filePath, ImageType type, long sizeBytes) : base(id)
    {
        Name = name;
        FilePath = filePath;
        Type = type;
        SizeBytes = sizeBytes;
        IsActive = true;
    }

    public static Image Create(string name, string filePath, ImageType type, long sizeBytes, string? description = null)
    {
        var image = new Image(Guid.NewGuid(), name, filePath, type, sizeBytes)
        {
            Description = description
        };
        image.RaiseDomainEvent(new ImageRegisteredEvent(image.Id, name, type));
        return image;
    }

    public void UpdateDescription(string description)
    {
        Description = description;
        UpdatedAt = DateTime.UtcNow;
    }

    public void Activate()
    {
        if (IsActive) return;
        IsActive = true;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ImageActivatedEvent(Id));
    }

    public void Deactivate()
    {
        if (!IsActive) return;
        IsActive = false;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ImageDeactivatedEvent(Id));
    }
}

public enum ImageType
{
    Iso,
    Img,
    Wim,
    Vhd,
    Vmdk
}

public sealed class ImageRegisteredEvent : DomainEvent
{
    public Guid ImageId { get; }
    public string Name { get; }
    public ImageType Type { get; }

    public ImageRegisteredEvent(Guid imageId, string name, ImageType type)
    {
        ImageId = imageId;
        Name = name;
        Type = type;
    }
}

public sealed class ImageActivatedEvent : DomainEvent
{
    public Guid ImageId { get; }

    public ImageActivatedEvent(Guid imageId)
    {
        ImageId = imageId;
    }
}

public sealed class ImageDeactivatedEvent : DomainEvent
{
    public Guid ImageId { get; }

    public ImageDeactivatedEvent(Guid imageId)
    {
        ImageId = imageId;
    }
}



======================================
FILE: Domain\Models\ServerInstance.cs
======================================

namespace Mass.Core.Domain.Models;

public sealed class ServerInstance : Entity<Guid>
{
    public string Name { get; private set; }
    public ServerType Type { get; private set; }
    public int Port { get; private set; }
    public ServerStatus Status { get; private set; }
    public DateTime? StartedAt { get; private set; }
    public DateTime? StoppedAt { get; private set; }
    public int? ProcessId { get; private set; }

    private ServerInstance(Guid id, string name, ServerType type, int port) : base(id)
    {
        Name = name;
        Type = type;
        Port = port;
        Status = ServerStatus.Stopped;
    }

    public static ServerInstance Create(string name, ServerType type, int port)
    {
        var server = new ServerInstance(Guid.NewGuid(), name, type, port);
        server.RaiseDomainEvent(new ServerInstanceCreatedEvent(server.Id, name, type, port));
        return server;
    }

    public void Start(int processId)
    {
        Status = ServerStatus.Running;
        ProcessId = processId;
        StartedAt = DateTime.UtcNow;
        StoppedAt = null;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ServerInstanceStartedEvent(Id, processId));
    }

    public void Stop()
    {
        Status = ServerStatus.Stopped;
        ProcessId = null;
        StoppedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ServerInstanceStoppedEvent(Id));
    }

    public void MarkAsFailed(string reason)
    {
        Status = ServerStatus.Failed;
        StoppedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ServerInstanceFailedEvent(Id, reason));
    }
}

public enum ServerType
{
    PxeBoot,
    Tftp,
    Dhcp,
    Http
}

public enum ServerStatus
{
    Stopped,
    Starting,
    Running,
    Stopping,
    Failed
}

public sealed class ServerInstanceCreatedEvent : DomainEvent
{
    public Guid ServerId { get; }
    public string Name { get; }
    public ServerType Type { get; }
    public int Port { get; }

    public ServerInstanceCreatedEvent(Guid serverId, string name, ServerType type, int port)
    {
        ServerId = serverId;
        Name = name;
        Type = type;
        Port = port;
    }
}

public sealed class ServerInstanceStartedEvent : DomainEvent
{
    public Guid ServerId { get; }
    public int ProcessId { get; }

    public ServerInstanceStartedEvent(Guid serverId, int processId)
    {
        ServerId = serverId;
        ProcessId = processId;
    }
}

public sealed class ServerInstanceStoppedEvent : DomainEvent
{
    public Guid ServerId { get; }

    public ServerInstanceStoppedEvent(Guid serverId)
    {
        ServerId = serverId;
    }
}

public sealed class ServerInstanceFailedEvent : DomainEvent
{
    public Guid ServerId { get; }
    public string Reason { get; }

    public ServerInstanceFailedEvent(Guid serverId, string reason)
    {
        ServerId = serverId;
        Reason = reason;
    }
}



======================================
FILE: Domain\Models\UsbJob.cs
======================================

namespace Mass.Core.Domain.Models;

public sealed class UsbJob : Entity<Guid>
{
    public string ImagePath { get; private set; }
    public string TargetDrive { get; private set; }
    public UsbJobStatus Status { get; private set; }
    public long TotalBytes { get; private set; }
    public long ProcessedBytes { get; private set; }
    public int ProgressPercentage => TotalBytes > 0 ? (int)((ProcessedBytes * 100) / TotalBytes) : 0;
    public DateTime? StartedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    public string? ErrorMessage { get; private set; }

    private UsbJob(Guid id, string imagePath, string targetDrive, long totalBytes) : base(id)
    {
        ImagePath = imagePath;
        TargetDrive = targetDrive;
        TotalBytes = totalBytes;
        ProcessedBytes = 0;
        Status = UsbJobStatus.Pending;
    }

    public static UsbJob Create(string imagePath, string targetDrive, long totalBytes)
    {
        var job = new UsbJob(Guid.NewGuid(), imagePath, targetDrive, totalBytes);
        job.RaiseDomainEvent(new UsbJobCreatedEvent(job.Id, imagePath, targetDrive));
        return job;
    }

    public void Start()
    {
        Status = UsbJobStatus.Running;
        StartedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new UsbJobStartedEvent(Id));
    }

    public void UpdateProgress(long processedBytes)
    {
        if (processedBytes < 0 || processedBytes > TotalBytes)
            throw new ArgumentOutOfRangeException(nameof(processedBytes));

        ProcessedBytes = processedBytes;
        UpdatedAt = DateTime.UtcNow;
    }

    public void Complete()
    {
        Status = UsbJobStatus.Completed;
        CompletedAt = DateTime.UtcNow;
        ProcessedBytes = TotalBytes;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new UsbJobCompletedEvent(Id));
    }

    public void Fail(string errorMessage)
    {
        Status = UsbJobStatus.Failed;
        CompletedAt = DateTime.UtcNow;
        ErrorMessage = errorMessage;
        UpdatedAt = DateTime.UtcNow;
        RaiseDomainEvent(new UsbJobFailedEvent(Id, errorMessage));
    }
}

public enum UsbJobStatus
{
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled
}

public sealed class UsbJobCreatedEvent : DomainEvent
{
    public Guid JobId { get; }
    public string ImagePath { get; }
    public string TargetDrive { get; }

    public UsbJobCreatedEvent(Guid jobId, string imagePath, string targetDrive)
    {
        JobId = jobId;
        ImagePath = imagePath;
        TargetDrive = targetDrive;
    }
}

public sealed class UsbJobStartedEvent : DomainEvent
{
    public Guid JobId { get; }

    public UsbJobStartedEvent(Guid jobId)
    {
        JobId = jobId;
    }
}

public sealed class UsbJobCompletedEvent : DomainEvent
{
    public Guid JobId { get; }

    public UsbJobCompletedEvent(Guid jobId)
    {
        JobId = jobId;
    }
}

public sealed class UsbJobFailedEvent : DomainEvent
{
    public Guid JobId { get; }
    public string ErrorMessage { get; }

    public UsbJobFailedEvent(Guid jobId, string errorMessage)
    {
        JobId = jobId;
        ErrorMessage = errorMessage;
    }
}



======================================
FILE: Domain\DomainEvent.cs
======================================

namespace Mass.Core.Domain;

public abstract class DomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
    public string EventType => GetType().Name;
}



======================================
FILE: Domain\Entity.cs
======================================

namespace Mass.Core.Domain;

public abstract class Entity<TId> where TId : notnull
{
    public TId Id { get; protected init; }
    public DateTime CreatedAt { get; protected init; }
    public DateTime? UpdatedAt { get; protected set; }

    private readonly List<DomainEvent> _domainEvents = [];
    public IReadOnlyList<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    protected Entity(TId id)
    {
        Id = id;
        CreatedAt = DateTime.UtcNow;
    }

    protected void RaiseDomainEvent(DomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    public override bool Equals(object? obj)
    {
        if (obj is not Entity<TId> other)
            return false;

        if (ReferenceEquals(this, other))
            return true;

        if (GetType() != other.GetType())
            return false;

        return Id.Equals(other.Id);
    }

    public override int GetHashCode() => Id.GetHashCode();

    public static bool operator ==(Entity<TId>? left, Entity<TId>? right)
    {
        if (left is null && right is null)
            return true;

        if (left is null || right is null)
            return false;

        return left.Equals(right);
    }

    public static bool operator !=(Entity<TId>? left, Entity<TId>? right) => !(left == right);
}



======================================
FILE: Domain\ValueObject.cs
======================================

namespace Mass.Core.Domain;

public abstract class ValueObject : IEquatable<ValueObject>
{
    protected abstract IEnumerable<object?> GetEqualityComponents();

    public override bool Equals(object? obj)
    {
        if (obj is null || obj.GetType() != GetType())
            return false;

        return Equals((ValueObject)obj);
    }

    public bool Equals(ValueObject? other)
    {
        if (other is null)
            return false;

        return GetEqualityComponents()
            .SequenceEqual(other.GetEqualityComponents());
    }

    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Select(x => x?.GetHashCode() ?? 0)
            .Aggregate((x, y) => x ^ y);
    }

    public static bool operator ==(ValueObject? left, ValueObject? right)
    {
        if (left is null && right is null)
            return true;

        if (left is null || right is null)
            return false;

        return left.Equals(right);
    }

    public static bool operator !=(ValueObject? left, ValueObject? right) => !(left == right);
}



======================================
FILE: Logging\FileLogService.cs
======================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace Mass.Core.Logging;

public class FileLogService : ILogService
{
    private readonly string _logDirectory;
    private readonly string _currentLogFile;
    private readonly ConcurrentQueue<LogEntry> _logBuffer = new();
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private const int MaxLogFiles = 30;
    private const long MaxLogFileSize = 10 * 1024 * 1024; // 10MB

    public FileLogService()
    {
        var appData = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite");
        _logDirectory = Path.Combine(appData, "logs");
        Directory.CreateDirectory(_logDirectory);
        
        var today = DateTime.Now.ToString("yyyy-MM-dd");
        _currentLogFile = Path.Combine(_logDirectory, $"mass_{today}.log");
        
        CleanupOldLogs();
    }

    public void Log(LogLevel level, string category, string message, Exception? exception = null, Dictionary<string, object>? properties = null)
    {
        var entry = new LogEntry
        {
            Timestamp = DateTime.Now,
            Level = level,
            Category = category,
            Message = message,
            Exception = exception?.ToString(),
            Properties = properties ?? new Dictionary<string, object>()
        };

        _logBuffer.Enqueue(entry);
        WriteToFile(entry);
    }

    public void LogTrace(string message, string category = "Application") 
        => Log(LogLevel.Trace, category, message);

    public void LogDebug(string message, string category = "Application") 
        => Log(LogLevel.Debug, category, message);

    public void LogInformation(string message, string category = "Application") 
        => Log(LogLevel.Information, category, message);

    public void LogWarning(string message, string category = "Application") 
        => Log(LogLevel.Warning, category, message);

    public void LogError(string message, Exception? exception = null, string category = "Application") 
        => Log(LogLevel.Error, category, message, exception);

    public void LogCritical(string message, Exception? exception = null, string category = "Application") 
        => Log(LogLevel.Critical, category, message, exception);

    public IEnumerable<LogEntry> GetLogs(int maxCount = 1000)
    {
        return LoadLogsFromFile().Take(maxCount);
    }

    public IEnumerable<LogEntry> GetLogsByLevel(LogLevel level, int maxCount = 1000)
    {
        return LoadLogsFromFile().Where(l => l.Level == level).Take(maxCount);
    }

    public IEnumerable<LogEntry> SearchLogs(string searchTerm, int maxCount = 1000)
    {
        var lowerSearch = searchTerm.ToLowerInvariant();
        return LoadLogsFromFile()
            .Where(l => l.Message.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                       l.Category.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
            .Take(maxCount);
    }

    public void ClearLogs()
    {
        _logBuffer.Clear();
        try
        {
            if (File.Exists(_currentLogFile))
            {
                File.Delete(_currentLogFile);
            }
        }
        catch { }
    }

    private void WriteToFile(LogEntry entry)
    {
        _ = Task.Run(async () =>
        {
            await _writeLock.WaitAsync();
            try
            {
                CheckLogRotation();
                var line = $"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff}] [{entry.Level}] [{entry.Category}] {entry.Message}";
                if (!string.IsNullOrEmpty(entry.Exception))
                {
                    line += $"\n{entry.Exception}";
                }
                await File.AppendAllTextAsync(_currentLogFile, line + Environment.NewLine);
            }
            catch { }
            finally
            {
                _writeLock.Release();
            }
        });
    }

    private void CheckLogRotation()
    {
        if (File.Exists(_currentLogFile))
        {
            var fileInfo = new FileInfo(_currentLogFile);
            if (fileInfo.Length > MaxLogFileSize)
            {
                var timestamp = DateTime.Now.ToString("yyyy-MM-dd_HHmmss");
                var archiveName = Path.Combine(_logDirectory, $"mass_{timestamp}_archived.log");
                File.Move(_currentLogFile, archiveName);
                CleanupOldLogs();
            }
        }
    }

    private void CleanupOldLogs()
    {
        try
        {
            var logFiles = Directory.GetFiles(_logDirectory, "*.log")
                .Select(f => new FileInfo(f))
                .OrderByDescending(f => f.CreationTime)
                .ToList();

            foreach (var file in logFiles.Skip(MaxLogFiles))
            {
                file.Delete();
            }
        }
        catch { }
    }

    private List<LogEntry> LoadLogsFromFile()
    {
        var entries = new List<LogEntry>();
        
        try
        {
            if (!File.Exists(_currentLogFile))
                return entries;

            var lines = File.ReadAllLines(_currentLogFile);
            foreach (var line in lines)
            {
                if (TryParseLogLine(line, out var entry))
                {
                    entries.Add(entry);
                }
            }
        }
        catch { }

        return entries.OrderByDescending(e => e.Timestamp).ToList();
    }

    private bool TryParseLogLine(string line, out LogEntry entry)
    {
        entry = new LogEntry();
        
        try
        {
            var parts = line.Split(new[] { "] [", "] " }, StringSplitOptions.None);
            if (parts.Length < 4) return false;

            var timestampStr = parts[0].TrimStart('[');
            entry.Timestamp = DateTime.Parse(timestampStr);
            entry.Level = Enum.Parse<LogLevel>(parts[1]);
            entry.Category = parts[2];
            entry.Message = string.Join("] ", parts.Skip(3));
            
            return true;
        }
        catch
        {
            return false;
        }
    }
}



======================================
FILE: Logging\ILogService.cs
======================================

namespace Mass.Core.Logging;

public interface ILogService
{
    void Log(LogLevel level, string category, string message, Exception? exception = null, Dictionary<string, object>? properties = null);
    void LogTrace(string message, string category = "Application");
    void LogDebug(string message, string category = "Application");
    void LogInformation(string message, string category = "Application");
    void LogWarning(string message, string category = "Application");
    void LogError(string message, Exception? exception = null, string category = "Application");
    void LogCritical(string message, Exception? exception = null, string category = "Application");
    
    IEnumerable<LogEntry> GetLogs(int maxCount = 1000);
    IEnumerable<LogEntry> GetLogsByLevel(LogLevel level, int maxCount = 1000);
    IEnumerable<LogEntry> SearchLogs(string searchTerm, int maxCount = 1000);
    void ClearLogs();
}



======================================
FILE: Logging\LogEntry.cs
======================================

namespace Mass.Core.Logging;

public enum LogLevel
{
    Trace,
    Debug,
    Information,
    Warning,
    Error,
    Critical
}

public class LogEntry
{
    public DateTime Timestamp { get; set; } = DateTime.Now;
    public LogLevel Level { get; set; }
    public string Category { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public string? Exception { get; set; }
    public Dictionary<string, object> Properties { get; set; } = new();
}



======================================
FILE: Orchestration\WorkflowContext.cs
======================================

namespace Mass.Core.Orchestration;

public class WorkflowContext
{
    public Dictionary<string, object> Variables { get; } = new();
    public Dictionary<string, object> StepResults { get; } = new();
    public List<string> Logs { get; } = new();
    public CancellationToken CancellationToken { get; set; }

    public void Log(string message)
    {
        Logs.Add($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }

    public void SetVariable(string name, object value)
    {
        Variables[name] = value;
    }

    public object? GetVariable(string name)
    {
        return Variables.TryGetValue(name, out var value) ? value : null;
    }

    public void SetStepResult(string stepId, object result)
    {
        StepResults[stepId] = result;
    }

    public object? GetStepResult(string stepId)
    {
        return StepResults.TryGetValue(stepId, out var result) ? result : null;
    }

    public string InterpolateString(string input)
    {
        var result = input;
        
        foreach (var kvp in Variables)
        {
            result = result.Replace($"${{{kvp.Key}}}", kvp.Value?.ToString() ?? string.Empty);
        }
        
        return result;
    }
}



======================================
FILE: Orchestration\WorkflowDefinition.cs
======================================

namespace Mass.Core.Orchestration;

public class WorkflowDefinition
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Version { get; set; } = "1.0.0";
    public Dictionary<string, object> Parameters { get; set; } = new();
    public List<WorkflowStep> Steps { get; set; } = new();
}



======================================
FILE: Orchestration\WorkflowExecutor.cs
======================================

using System.Diagnostics;

namespace Mass.Core.Orchestration;

public class WorkflowExecutor
{
    public async Task<WorkflowResult> ExecuteAsync(WorkflowDefinition workflow, CancellationToken cancellationToken = default)
    {
        var context = new WorkflowContext
        {
            CancellationToken = cancellationToken
        };

        foreach (var param in workflow.Parameters)
        {
            context.SetVariable(param.Key, param.Value);
        }

        context.Log($"Starting workflow: {workflow.Name}");

        try
        {
            foreach (var step in workflow.Steps)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    context.Log("Workflow cancelled by user");
                    return new WorkflowResult { Success = false, Message = "Cancelled", Context = context };
                }

                if (!string.IsNullOrEmpty(step.Condition) && !EvaluateCondition(step.Condition, context))
                {
                    context.Log($"Skipping step '{step.Name}' - condition not met");
                    continue;
                }

                context.Log($"Executing step: {step.Name} ({step.Type})");

                var success = await ExecuteStepAsync(step, context);

                if (!success && !step.RunAlways)
                {
                    context.Log($"Step '{step.Name}' failed");
                    return new WorkflowResult { Success = false, Message = $"Step '{step.Name}' failed", Context = context };
                }
            }

            context.Log($"Workflow completed successfully: {workflow.Name}");
            return new WorkflowResult { Success = true, Message = "Completed", Context = context };
        }
        catch (Exception ex)
        {
            context.Log($"Workflow error: {ex.Message}");
            return new WorkflowResult { Success = false, Message = ex.Message, Context = context };
        }
    }

    private async Task<bool> ExecuteStepAsync(WorkflowStep step, WorkflowContext context)
    {
        var retries = 0;
        Exception? lastException = null;

        while (retries <= step.MaxRetries)
        {
            try
            {
                var result = step switch
                {
                    CommandStep commandStep => await ExecuteCommandStepAsync(commandStep, context),
                    HttpRequestStep httpStep => await ExecuteHttpRequestStepAsync(httpStep, context),
                    ScriptStep scriptStep => await ExecuteScriptStepAsync(scriptStep, context),
                    _ => throw new NotSupportedException($"Step type '{step.Type}' is not supported")
                };

                context.SetStepResult(step.Id, result);
                return true;
            }
            catch (Exception ex)
            {
                lastException = ex;
                retries++;

                if (retries <= step.MaxRetries)
                {
                    context.Log($"Step '{step.Name}' failed (attempt {retries}/{step.MaxRetries + 1}): {ex.Message}");
                    await Task.Delay(step.RetryDelayMs, context.CancellationToken);
                }
            }
        }

        context.Log($"Step '{step.Name}' failed after {retries} attempts: {lastException?.Message}");
        return false;
    }

    private async Task<object> ExecuteCommandStepAsync(CommandStep step, WorkflowContext context)
    {
        var command = context.InterpolateString(step.Parameters.GetValueOrDefault("command")?.ToString() ?? string.Empty);
        var workingDir = context.InterpolateString(step.Parameters.GetValueOrDefault("workingDirectory")?.ToString() ?? Environment.CurrentDirectory);

        var processInfo = new ProcessStartInfo
        {
            FileName = "cmd.exe",
            Arguments = $"/c {command}",
            WorkingDirectory = workingDir,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var process = Process.Start(processInfo);
        if (process == null)
            throw new InvalidOperationException("Failed to start process");

        var output = await process.StandardOutput.ReadToEndAsync();
        var error = await process.StandardError.ReadToEndAsync();

        await process.WaitForExitAsync(context.CancellationToken);

        if (process.ExitCode != 0)
        {
            throw new InvalidOperationException($"Command failed with exit code {process.ExitCode}: {error}");
        }

        context.Log($"Command output: {output}");
        return output;
    }

    private async Task<object> ExecuteHttpRequestStepAsync(HttpRequestStep step, WorkflowContext context)
    {
        var url = context.InterpolateString(step.Parameters.GetValueOrDefault("url")?.ToString() ?? string.Empty);
        var method = step.Parameters.GetValueOrDefault("method")?.ToString() ?? "GET";

        using var client = new HttpClient();
        var response = method.ToUpper() switch
        {
            "GET" => await client.GetAsync(url, context.CancellationToken),
            "POST" => await client.PostAsync(url, null, context.CancellationToken),
            _ => throw new NotSupportedException($"HTTP method '{method}' is not supported")
        };

        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync(context.CancellationToken);

        context.Log($"HTTP {method} {url} - Status: {response.StatusCode}");
        return content;
    }

    private async Task<object> ExecuteScriptStepAsync(ScriptStep step, WorkflowContext context)
    {
        var scriptPath = context.InterpolateString(step.Parameters.GetValueOrDefault("path")?.ToString() ?? string.Empty);
        var arguments = context.InterpolateString(step.Parameters.GetValueOrDefault("arguments")?.ToString() ?? string.Empty);
        var workingDir = context.InterpolateString(step.Parameters.GetValueOrDefault("workingDirectory")?.ToString() ?? Environment.CurrentDirectory);

        if (!File.Exists(scriptPath))
        {
            // Try to find relative to working directory
            var relativePath = Path.Combine(workingDir, scriptPath);
            if (File.Exists(relativePath))
            {
                scriptPath = relativePath;
            }
            else
            {
                throw new FileNotFoundException($"Script file not found: {scriptPath}");
            }
        }

        var extension = Path.GetExtension(scriptPath).ToLowerInvariant();
        var processInfo = new ProcessStartInfo
        {
            WorkingDirectory = workingDir,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        switch (extension)
        {
            case ".bat":
            case ".cmd":
                processInfo.FileName = "cmd.exe";
                processInfo.Arguments = $"/c \"{scriptPath}\" {arguments}";
                break;
            case ".ps1":
                processInfo.FileName = "powershell.exe";
                processInfo.Arguments = $"-NoProfile -ExecutionPolicy Bypass -File \"{scriptPath}\" {arguments}";
                break;
            default:
                // Try to execute directly (e.g. .exe or associated file)
                processInfo.FileName = scriptPath;
                processInfo.Arguments = arguments;
                break;
        }

        using var process = Process.Start(processInfo);
        if (process == null)
            throw new InvalidOperationException("Failed to start script process");

        var output = await process.StandardOutput.ReadToEndAsync();
        var error = await process.StandardError.ReadToEndAsync();

        await process.WaitForExitAsync(context.CancellationToken);

        if (process.ExitCode != 0)
        {
            throw new InvalidOperationException($"Script failed with exit code {process.ExitCode}: {error}");
        }

        context.Log($"Script output: {output}");
        return output;
    }

    private bool EvaluateCondition(string condition, WorkflowContext context)
    {
        var interpolated = context.InterpolateString(condition);
        return interpolated.Equals("true", StringComparison.OrdinalIgnoreCase);
    }
}

public class WorkflowResult
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public WorkflowContext? Context { get; set; }
}



======================================
FILE: Orchestration\WorkflowParser.cs
======================================

using System.Text.Json;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Mass.Core.Orchestration;

public class WorkflowParser
{
    private readonly IDeserializer _yamlDeserializer;
    private readonly JsonSerializerOptions _jsonOptions;

    public WorkflowParser()
    {
        _yamlDeserializer = new DeserializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .Build();

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
    }

    public WorkflowDefinition ParseFromFile(string filePath)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException($"Workflow file not found: {filePath}");

        var content = File.ReadAllText(filePath);
        var extension = Path.GetExtension(filePath).ToLowerInvariant();

        return extension switch
        {
            ".yaml" or ".yml" => ParseYaml(content),
            ".json" => ParseJson(content),
            _ => throw new NotSupportedException($"File extension '{extension}' is not supported. Use .yaml, .yml, or .json")
        };
    }

    public WorkflowDefinition ParseYaml(string yaml)
    {
        try
        {
            var rawData = _yamlDeserializer.Deserialize<Dictionary<string, object>>(yaml);
            return ConvertToWorkflowDefinition(rawData);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to parse YAML: {ex.Message}", ex);
        }
    }

    public WorkflowDefinition ParseJson(string json)
    {
        try
        {
            var rawData = JsonSerializer.Deserialize<Dictionary<string, object>>(json, _jsonOptions);
            if (rawData == null)
                throw new InvalidOperationException("Failed to deserialize JSON");

            return ConvertToWorkflowDefinition(rawData);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to parse JSON: {ex.Message}", ex);
        }
    }

    private WorkflowDefinition ConvertToWorkflowDefinition(Dictionary<string, object> data)
    {
        var workflow = new WorkflowDefinition
        {
            Id = GetStringValue(data, "id"),
            Name = GetStringValue(data, "name"),
            Description = GetStringValue(data, "description"),
            Version = GetStringValue(data, "version", "1.0.0")
        };

        if (data.TryGetValue("parameters", out var parametersObj) && parametersObj is Dictionary<object, object> parametersDict)
        {
            foreach (var kvp in parametersDict)
            {
                workflow.Parameters[kvp.Key.ToString() ?? string.Empty] = kvp.Value;
            }
        }

        if (data.TryGetValue("steps", out var stepsObj) && stepsObj is List<object> stepsList)
        {
            foreach (var stepObj in stepsList)
            {
                if (stepObj is Dictionary<object, object> stepDict)
                {
                    var stepData = stepDict.ToDictionary(k => k.Key.ToString() ?? string.Empty, v => v.Value);
                    var step = ConvertToWorkflowStep(stepData);
                    workflow.Steps.Add(step);
                }
            }
        }

        return workflow;
    }

    private WorkflowStep ConvertToWorkflowStep(Dictionary<string, object> stepData)
    {
        var type = GetStringValue(stepData, "type", "Command");

        WorkflowStep step = type.ToLowerInvariant() switch
        {
            "command" => new CommandStep(),
            "httprequest" or "http" => new HttpRequestStep(),
            "script" => new ScriptStep(),
            "plugin" => new PluginStep(),
            "service" => new ServiceStep(),
            _ => new CommandStep()
        };

        step.Id = GetStringValue(stepData, "id", Guid.NewGuid().ToString());
        step.Name = GetStringValue(stepData, "name");
        step.Condition = GetStringValue(stepData, "condition");
        step.MaxRetries = GetIntValue(stepData, "maxRetries", 0);
        step.RetryDelayMs = GetIntValue(stepData, "retryDelayMs", 1000);
        step.RunAlways = GetBoolValue(stepData, "runAlways", false);

        if (stepData.TryGetValue("parameters", out var parametersObj) && parametersObj is Dictionary<object, object> parametersDict)
        {
            foreach (var kvp in parametersDict)
            {
                step.Parameters[kvp.Key.ToString() ?? string.Empty] = kvp.Value;
            }
        }

        return step;
    }

    private string GetStringValue(Dictionary<string, object> data, string key, string defaultValue = "")
    {
        return data.TryGetValue(key, out var value) ? value?.ToString() ?? defaultValue : defaultValue;
    }

    private int GetIntValue(Dictionary<string, object> data, string key, int defaultValue = 0)
    {
        if (data.TryGetValue(key, out var value))
        {
            if (value is int intValue) return intValue;
            if (int.TryParse(value?.ToString(), out var parsed)) return parsed;
        }
        return defaultValue;
    }

    private bool GetBoolValue(Dictionary<string, object> data, string key, bool defaultValue = false)
    {
        if (data.TryGetValue(key, out var value))
        {
            if (value is bool boolValue) return boolValue;
            if (bool.TryParse(value?.ToString(), out var parsed)) return parsed;
        }
        return defaultValue;
    }
}



======================================
FILE: Orchestration\WorkflowStep.cs
======================================

namespace Mass.Core.Orchestration;

public abstract class WorkflowStep
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty;
    public Dictionary<string, object> Parameters { get; set; } = new();
    public string? Condition { get; set; }
    public int MaxRetries { get; set; } = 0;
    public int RetryDelayMs { get; set; } = 1000;
    public bool RunAlways { get; set; } = false;
}

public class CommandStep : WorkflowStep
{
    public CommandStep()
    {
        Type = "Command";
    }
}

public class HttpRequestStep : WorkflowStep
{
    public HttpRequestStep()
    {
        Type = "HttpRequest";
    }
}

public class ScriptStep : WorkflowStep
{
    public ScriptStep()
    {
        Type = "Script";
    }
}

public class PluginStep : WorkflowStep
{
    public PluginStep()
    {
        Type = "Plugin";
    }
}

public class ServiceStep : WorkflowStep
{
    public ServiceStep()
    {
        Type = "Service";
    }
}



======================================
FILE: Plugins\PluginDiscoveryService.cs
======================================

using System.Text.Json;

namespace Mass.Core.Plugins;

public class PluginDiscoveryService
{
    private readonly List<string> _pluginPaths;

    public PluginDiscoveryService(params string[] pluginPaths)
    {
        _pluginPaths = pluginPaths.ToList();
    }

    public async Task<List<DiscoveredPlugin>> DiscoverPluginsAsync()
    {
        var discoveredPlugins = new List<DiscoveredPlugin>();

        foreach (var basePath in _pluginPaths)
        {
            if (!Directory.Exists(basePath))
            {
                continue;
            }

            var pluginDirectories = Directory.GetDirectories(basePath);

            foreach (var pluginDir in pluginDirectories)
            {
                var manifestPath = Path.Combine(pluginDir, "plugin.json");
                
                if (!File.Exists(manifestPath))
                {
                    continue;
                }

                try
                {
                    var json = await File.ReadAllTextAsync(manifestPath);
                    var manifest = JsonSerializer.Deserialize<PluginManifest>(json);

                    if (manifest != null && ValidateManifest(manifest))
                    {
                        discoveredPlugins.Add(new DiscoveredPlugin
                        {
                            Manifest = manifest,
                            PluginPath = pluginDir,
                            ManifestPath = manifestPath
                        });
                    }
                }
                catch
                {
                }
            }
        }

        return discoveredPlugins;
    }

    private bool ValidateManifest(PluginManifest manifest)
    {
        return !string.IsNullOrWhiteSpace(manifest.Id) &&
               !string.IsNullOrWhiteSpace(manifest.Name) &&
               !string.IsNullOrWhiteSpace(manifest.Version) &&
               !string.IsNullOrWhiteSpace(manifest.EntryAssembly) &&
               !string.IsNullOrWhiteSpace(manifest.EntryType);
    }
}

public class DiscoveredPlugin
{
    public PluginManifest Manifest { get; set; } = null!;
    public string PluginPath { get; set; } = string.Empty;
    public string ManifestPath { get; set; } = string.Empty;
}



======================================
FILE: Plugins\PluginLifecycleManager.cs
======================================

using Mass.Core.Abstractions;

namespace Mass.Core.Plugins;

public class PluginLifecycleManager
{
    private readonly PluginLoader _loader;
    private readonly Dictionary<string, LoadedPlugin> _loadedPlugins = new();

    public IReadOnlyDictionary<string, LoadedPlugin> LoadedPlugins => _loadedPlugins;

    public PluginLifecycleManager(PluginLoader loader)
    {
        _loader = loader;
    }

    public async Task<bool> LoadPluginAsync(DiscoveredPlugin discoveredPlugin, IServiceProvider services)
    {
        if (_loadedPlugins.ContainsKey(discoveredPlugin.Manifest.Id))
        {
            return false;
        }

        try
        {
            // Note: PluginLoader needs to be updated to return IModule instead of IPlugin
            // For now assuming we cast or update PluginLoader
            var module = _loader.LoadPlugin(discoveredPlugin.PluginPath, discoveredPlugin.Manifest) as IModule;
            
            if (module == null)
            {
                return false;
            }

            var loadedPlugin = new LoadedPlugin
            {
                Manifest = discoveredPlugin.Manifest,
                Module = module,
                State = PluginState.Loaded
            };

            _loadedPlugins[discoveredPlugin.Manifest.Id] = loadedPlugin;

            return true;
        }
        catch (Exception ex)
        {
            var errorPlugin = new LoadedPlugin
            {
                Manifest = discoveredPlugin.Manifest,
                Module = null,
                State = PluginState.Failed,
                ErrorMessage = ex.Message
            };
            _loadedPlugins[discoveredPlugin.Manifest.Id] = errorPlugin;
            return false;
        }
    }

    public async Task<bool> InitializePluginAsync(string pluginId, IServiceProvider services, CancellationToken cancellationToken = default)
    {
        if (!_loadedPlugins.TryGetValue(pluginId, out var loadedPlugin) || loadedPlugin.Module == null)
        {
            return false;
        }

        try
        {
            loadedPlugin.State = PluginState.Starting;
            await loadedPlugin.Module.InitializeAsync(services, cancellationToken);
            await loadedPlugin.Module.ActivateAsync(cancellationToken);
            loadedPlugin.State = PluginState.Running;
            return true;
        }
        catch (Exception ex)
        {
            loadedPlugin.State = PluginState.Failed;
            loadedPlugin.ErrorMessage = ex.Message;
            return false;
        }
    }

    public async Task<bool> ShutdownPluginAsync(string pluginId, CancellationToken cancellationToken = default)
    {
        if (!_loadedPlugins.TryGetValue(pluginId, out var loadedPlugin) || loadedPlugin.Module == null)
        {
            return false;
        }

        try
        {
            loadedPlugin.State = PluginState.Stopping;
            await loadedPlugin.Module.DeactivateAsync(cancellationToken);
            await loadedPlugin.Module.UnloadAsync(cancellationToken);
            loadedPlugin.State = PluginState.Stopped;
            return true;
        }
        catch (Exception ex)
        {
            loadedPlugin.State = PluginState.Failed;
            loadedPlugin.ErrorMessage = ex.Message;
            return false;
        }
    }

    public void UnloadPlugin(string pluginId)
    {
        if (_loadedPlugins.TryGetValue(pluginId, out var loadedPlugin))
        {
            _loader.UnloadPlugin(pluginId);
            _loadedPlugins.Remove(pluginId);
        }
    }
}

public class LoadedPlugin
{
    public PluginManifest Manifest { get; set; } = null!;
    public IModule? Module { get; set; }
    public PluginState State { get; set; }
    public string? ErrorMessage { get; set; }
}

public enum PluginState
{
    Discovered,
    Loaded,
    Starting,
    Running,
    Stopping,
    Stopped,
    Failed
}



======================================
FILE: Plugins\PluginLoader.cs
======================================

using System.Reflection;
using System.Runtime.Loader;
using Mass.Core.Abstractions;

namespace Mass.Core.Plugins;

public class PluginLoader
{
    private readonly Dictionary<string, AssemblyLoadContext> _loadContexts = new();

    public IModule? LoadPlugin(string pluginPath, PluginManifest manifest)
    {
        var assemblyPath = Path.Combine(pluginPath, manifest.EntryAssembly);
        
        if (!File.Exists(assemblyPath))
        {
            throw new FileNotFoundException($"Plugin assembly not found: {assemblyPath}");
        }

        var loadContext = new PluginLoadContext(assemblyPath);
        _loadContexts[manifest.Id] = loadContext;

        var assembly = loadContext.LoadFromAssemblyPath(assemblyPath);
        var pluginType = assembly.GetType(manifest.EntryType);

        if (pluginType == null)
        {
            throw new TypeLoadException($"Plugin type not found: {manifest.EntryType}");
        }

        if (!typeof(IModule).IsAssignableFrom(pluginType))
        {
            throw new InvalidOperationException($"Type {manifest.EntryType} does not implement IModule");
        }

        return Activator.CreateInstance(pluginType) as IModule;
    }

    public void UnloadPlugin(string pluginId)
    {
        if (_loadContexts.TryGetValue(pluginId, out var context))
        {
            context.Unload();
            _loadContexts.Remove(pluginId);
        }
    }

    private class PluginLoadContext : AssemblyLoadContext
    {
        private readonly AssemblyDependencyResolver _resolver;

        public PluginLoadContext(string pluginPath) : base(isCollectible: true)
        {
            _resolver = new AssemblyDependencyResolver(pluginPath);
        }

        protected override Assembly? Load(AssemblyName assemblyName)
        {
            var assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);
            if (assemblyPath != null)
            {
                return LoadFromAssemblyPath(assemblyPath);
            }

            return null;
        }

        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
        {
            var libraryPath = _resolver.ResolveUnmanagedDllToPath(unmanagedDllName);
            if (libraryPath != null)
            {
                return LoadUnmanagedDllFromPath(libraryPath);
            }

            return IntPtr.Zero;
        }
    }
}



======================================
FILE: Plugins\PluginManifest.cs
======================================

using System.Text.Json.Serialization;

namespace Mass.Core.Plugins;

public sealed class PluginManifest
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;

    [JsonPropertyName("version")]
    public string Version { get; set; } = string.Empty;

    [JsonPropertyName("author")]
    public string Author { get; set; } = string.Empty;

    [JsonPropertyName("description")]
    public string Description { get; set; } = string.Empty;

    [JsonPropertyName("entryAssembly")]
    public string EntryAssembly { get; set; } = string.Empty;

    [JsonPropertyName("entryType")]
    public string EntryType { get; set; } = string.Empty;

    [JsonPropertyName("dependencies")]
    public List<string> Dependencies { get; set; } = new();

    [JsonPropertyName("capabilities")]
    public List<string> Capabilities { get; set; } = new();

    [JsonPropertyName("permissions")]
    public List<string> Permissions { get; set; } = new();

    [JsonPropertyName("icon")]
    public string? Icon { get; set; }

    [JsonPropertyName("enabled")]
    public bool Enabled { get; set; } = true;
}



======================================
FILE: Results\Result.cs
======================================

namespace Mass.Core.Results;

public readonly record struct Result<T>
{
    public bool IsSuccess { get; }
    public T? Value { get; }
    public Error? Error { get; }

    private Result(T value)
    {
        IsSuccess = true;
        Value = value;
        Error = null;
    }

    private Result(Error error)
    {
        IsSuccess = false;
        Value = default;
        Error = error;
    }

    public static Result<T> Success(T value) => new(value);
    public static Result<T> Failure(Error error) => new(error);

    public static implicit operator Result<T>(T value) => Success(value);
    public static implicit operator Result<T>(Error error) => Failure(error);

    public TResult Match<TResult>(
        Func<T, TResult> onSuccess,
        Func<Error, TResult> onFailure) =>
        IsSuccess ? onSuccess(Value!) : onFailure(Error!);

    public async Task<TResult> MatchAsync<TResult>(
        Func<T, Task<TResult>> onSuccess,
        Func<Error, Task<TResult>> onFailure) =>
        IsSuccess ? await onSuccess(Value!) : await onFailure(Error!);
}

public sealed record Error(
    string Code,
    string Message,
    ErrorType Type = ErrorType.Failure,
    Exception? Exception = null)
{
    public static Error Validation(string code, string message) =>
        new(code, message, ErrorType.Validation);

    public static Error NotFound(string code, string message) =>
        new(code, message, ErrorType.NotFound);

    public static Error Conflict(string code, string message) =>
        new(code, message, ErrorType.Conflict);

    public static Error Failure(string code, string message, Exception? exception = null) =>
        new(code, message, ErrorType.Failure, exception);
}

public enum ErrorType
{
    Validation,
    NotFound,
    Conflict,
    Failure
}



======================================
FILE: Scripting\IScriptingService.cs
======================================

using System.Threading.Tasks;

namespace Mass.Core.Scripting;

public interface IScriptingService
{
    void RegisterObject(string name, object obj);
    Task<object?> ExecuteAsync(string code);
    void Reset();
}



======================================
FILE: Scripting\LuaScriptingService.cs
======================================

using System;
using System.Threading.Tasks;
using NLua;

namespace Mass.Core.Scripting;

public class LuaScriptingService : IScriptingService, IDisposable
{
    private Lua _lua;

    public LuaScriptingService()
    {
        _lua = new Lua();
        _lua.LoadCLRPackage();
    }

    public void RegisterObject(string name, object obj)
    {
        _lua[name] = obj;
    }

    public Task<object?> ExecuteAsync(string code)
    {
        return Task.Run(() =>
        {
            try
            {
                var result = _lua.DoString(code);
                if (result != null && result.Length > 0)
                {
                    return result[0];
                }
                return null;
            }
            catch (Exception ex)
            {
                return (object?)ex.Message;
            }
        });
    }

    public void Reset()
    {
        _lua.Dispose();
        _lua = new Lua();
        _lua.LoadCLRPackage();
    }

    public void Dispose()
    {
        _lua?.Dispose();
    }
}



======================================
FILE: Security\CredentialService.cs
======================================

using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;

namespace Mass.Core.Security;

public class CredentialService : ICredentialService
{
    private readonly string _credentialPath;
    private List<StoredCredential> _credentials = new();

    public CredentialService()
    {
        var appData = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite");
        Directory.CreateDirectory(appData);
        _credentialPath = Path.Combine(appData, "credentials.dat");
        LoadCredentials();
    }

    public void StoreCredential(string id, string name, string username, SecureString password)
    {
        var plainPassword = SecureStringToString(password);
        var encryptedPassword = EncryptString(plainPassword);

        var existing = _credentials.FirstOrDefault(c => c.Id == id);
        if (existing != null)
        {
            existing.Name = name;
            existing.Username = username;
            existing.EncryptedPassword = encryptedPassword;
        }
        else
        {
            _credentials.Add(new StoredCredential
            {
                Id = id,
                Name = name,
                Username = username,
                EncryptedPassword = encryptedPassword,
                CreatedAt = DateTime.Now
            });
        }

        SaveCredentials();
    }

    public StoredCredential? GetCredential(string id)
    {
        var credential = _credentials.FirstOrDefault(c => c.Id == id);
        if (credential != null)
        {
            credential.LastUsed = DateTime.Now;
            SaveCredentials();
        }
        return credential;
    }

    public SecureString? GetPassword(string id)
    {
        var credential = GetCredential(id);
        if (credential == null)
            return null;

        try
        {
            var decrypted = DecryptString(credential.EncryptedPassword);
            return StringToSecureString(decrypted);
        }
        catch
        {
            return null;
        }
    }

    public IEnumerable<StoredCredential> GetAllCredentials()
    {
        return _credentials.Select(c => new StoredCredential
        {
            Id = c.Id,
            Name = c.Name,
            Username = c.Username,
            CreatedAt = c.CreatedAt,
            LastUsed = c.LastUsed
        });
    }

    public void DeleteCredential(string id)
    {
        _credentials.RemoveAll(c => c.Id == id);
        SaveCredentials();
    }

    public void ClearAll()
    {
        _credentials.Clear();
        SaveCredentials();
    }

    private void LoadCredentials()
    {
        try
        {
            if (File.Exists(_credentialPath))
            {
                var json = File.ReadAllText(_credentialPath);
                _credentials = JsonSerializer.Deserialize<List<StoredCredential>>(json) ?? new List<StoredCredential>();
            }
        }
        catch
        {
            _credentials = new List<StoredCredential>();
        }
    }

    private void SaveCredentials()
    {
        try
        {
            var json = JsonSerializer.Serialize(_credentials);
            File.WriteAllText(_credentialPath, json);
        }
        catch { }
    }

    private static string EncryptString(string plainText)
    {
        if (OperatingSystem.IsWindows())
        {
            var plainBytes = Encoding.UTF8.GetBytes(plainText);
            var encryptedBytes = ProtectedData.Protect(plainBytes, null, DataProtectionScope.CurrentUser);
            return Convert.ToBase64String(encryptedBytes);
        }
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));
    }

    private static string DecryptString(string encryptedText)
    {
        if (OperatingSystem.IsWindows())
        {
            var encryptedBytes = Convert.FromBase64String(encryptedText);
            var plainBytes = ProtectedData.Unprotect(encryptedBytes, null, DataProtectionScope.CurrentUser);
            return Encoding.UTF8.GetString(plainBytes);
        }
        return Encoding.UTF8.GetString(Convert.FromBase64String(encryptedText));
    }

    private static string SecureStringToString(SecureString secureString)
    {
        IntPtr ptr = IntPtr.Zero;
        try
        {
            ptr = Marshal.SecureStringToGlobalAllocUnicode(secureString);
            return Marshal.PtrToStringUni(ptr) ?? string.Empty;
        }
        finally
        {
            if (ptr != IntPtr.Zero)
                Marshal.ZeroFreeGlobalAllocUnicode(ptr);
        }
    }

    private static SecureString StringToSecureString(string str)
    {
        var secureString = new SecureString();
        foreach (char c in str)
        {
            secureString.AppendChar(c);
        }
        secureString.MakeReadOnly();
        return secureString;
    }
}



======================================
FILE: Security\ElevationService.cs
======================================

using System.Diagnostics;
using System.Security.Principal;

namespace Mass.Core.Security;

public class ElevationService : IElevationService
{
    public bool IsElevated
    {
        get
        {
            if (OperatingSystem.IsWindows())
            {
                using var identity = WindowsIdentity.GetCurrent();
                var principal = new WindowsPrincipal(identity);
                return principal.IsInRole(WindowsBuiltInRole.Administrator);
            }
            return false;
        }
    }

    public bool RequiresElevation(string operation)
    {
        var elevatedOperations = new[]
        {
            "disk_format",
            "disk_partition",
            "service_install",
            "driver_install",
            "system_modify"
        };

        return elevatedOperations.Contains(operation.ToLowerInvariant());
    }

    public Task<bool> RequestElevationAsync(string reason)
    {
        if (IsElevated)
            return Task.FromResult(true);

        return Task.FromResult(false);
    }

    public void RestartAsAdmin()
    {
        if (IsElevated)
            return;

        try
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = Environment.ProcessPath ?? Process.GetCurrentProcess().MainModule?.FileName ?? string.Empty,
                UseShellExecute = true,
                Verb = "runas"
            };

            Process.Start(startInfo);
            Environment.Exit(0);
        }
        catch
        {
        }
    }
}



======================================
FILE: Security\ICredentialService.cs
======================================

using System.Security;

namespace Mass.Core.Security;

public class StoredCredential
{
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Username { get; set; } = string.Empty;
    public string EncryptedPassword { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.Now;
    public DateTime? LastUsed { get; set; }
}

public interface ICredentialService
{
    void StoreCredential(string id, string name, string username, SecureString password);
    StoredCredential? GetCredential(string id);
    SecureString? GetPassword(string id);
    IEnumerable<StoredCredential> GetAllCredentials();
    void DeleteCredential(string id);
    void ClearAll();
}



======================================
FILE: Security\IElevationService.cs
======================================

using System.Security.Principal;

namespace Mass.Core.Security;

public interface IElevationService
{
    bool IsElevated { get; }
    bool RequiresElevation(string operation);
    Task<bool> RequestElevationAsync(string reason);
    void RestartAsAdmin();
}



======================================
FILE: Services\ActivityService.cs
======================================

using System.Text.Json;

namespace Mass.Core.Services;

public class ActivityService : IActivityService
{
    private readonly string _activityPath;
    private readonly string _favoritesPath;
    private List<ActivityItem> _activities = new();
    private List<FavoriteItem> _favorites = new();
    private const int MaxHistory = 50;

    public ActivityService()
    {
        var appData = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite");
        Directory.CreateDirectory(appData);
        _activityPath = Path.Combine(appData, "activity_history.json");
        _favoritesPath = Path.Combine(appData, "favorites.json");
        LoadData();
    }

    public IEnumerable<ActivityItem> GetRecentActivities()
    {
        return _activities.OrderByDescending(a => a.Timestamp).Take(10);
    }

    public void AddActivity(string title, string description, string icon = "")
    {
        _activities.Insert(0, new ActivityItem
        {
            Title = title,
            Description = description,
            Icon = icon,
            Timestamp = DateTime.Now
        });

        if (_activities.Count > MaxHistory)
        {
            _activities = _activities.Take(MaxHistory).ToList();
        }

        SaveActivities();
    }

    public void ClearHistory()
    {
        _activities.Clear();
        SaveActivities();
    }

    public IEnumerable<FavoriteItem> GetFavorites()
    {
        return _favorites;
    }

    public void AddFavorite(string id, string type, string name, string icon, string target)
    {
        if (!_favorites.Any(f => f.Id == id))
        {
            _favorites.Add(new FavoriteItem
            {
                Id = id,
                Type = type,
                Name = name,
                Icon = icon,
                Target = target
            });
            SaveFavorites();
        }
    }

    public void RemoveFavorite(string id)
    {
        var item = _favorites.FirstOrDefault(f => f.Id == id);
        if (item != null)
        {
            _favorites.Remove(item);
            SaveFavorites();
        }
    }

    public bool IsFavorite(string id)
    {
        return _favorites.Any(f => f.Id == id);
    }

    private void LoadData()
    {
        try
        {
            if (File.Exists(_activityPath))
            {
                var json = File.ReadAllText(_activityPath);
                _activities = JsonSerializer.Deserialize<List<ActivityItem>>(json) ?? new List<ActivityItem>();
            }

            if (File.Exists(_favoritesPath))
            {
                var json = File.ReadAllText(_favoritesPath);
                _favorites = JsonSerializer.Deserialize<List<FavoriteItem>>(json) ?? new List<FavoriteItem>();
            }
        }
        catch
        {
            // Ignore load errors, start fresh
            _activities = new List<ActivityItem>();
            _favorites = new List<FavoriteItem>();
        }
    }

    private void SaveActivities()
    {
        try
        {
            var json = JsonSerializer.Serialize(_activities);
            File.WriteAllText(_activityPath, json);
        }
        catch { }
    }

    private void SaveFavorites()
    {
        try
        {
            var json = JsonSerializer.Serialize(_favorites);
            File.WriteAllText(_favoritesPath, json);
        }
        catch { }
    }
}



======================================
FILE: Services\IActivityService.cs
======================================

namespace Mass.Core.Services;

public interface IActivityService
{
    IEnumerable<ActivityItem> GetRecentActivities();
    void AddActivity(string title, string description, string icon = "");
    void ClearHistory();

    IEnumerable<FavoriteItem> GetFavorites();
    void AddFavorite(string id, string type, string name, string icon, string target);
    void RemoveFavorite(string id);
    bool IsFavorite(string id);
}

public class ActivityItem
{
    public string Title { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Icon { get; set; } = "";
    public DateTime Timestamp { get; set; } = DateTime.Now;
    
    public string TimeDisplay => Timestamp.ToString("HH:mm");
}

public class FavoriteItem
{
    public string Id { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty; // Module, Workflow, Plugin
    public string Name { get; set; } = string.Empty;
    public string Icon { get; set; } = "";
    public string Target { get; set; } = string.Empty;
}



======================================
FILE: Services\IIpcService.cs
======================================

using System.Threading;
using System.Threading.Tasks;

namespace Mass.Core.Services;

public interface IIpcService
{
    Task<bool> StartServerAsync(CancellationToken ct = default);
    Task<bool> StopServerAsync(CancellationToken ct = default);
    Task<string> GetStatusAsync(CancellationToken ct = default);
}



======================================
FILE: Services\ILocalizationService.cs
======================================

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;

namespace Mass.Core.Services;

public interface ILocalizationService : INotifyPropertyChanged
{
    CultureInfo CurrentCulture { get; }
    string this[string key] { get; }
    string GetString(string key);
    void SetLanguage(string cultureCode);
    IEnumerable<CultureInfo> AvailableCultures { get; }
}



======================================
FILE: Services\INotificationService.cs
======================================

namespace Mass.Core.Services;

public enum NotificationSeverity
{
    Info,
    Warning,
    Error
}

public class Notification
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Title { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public NotificationSeverity Severity { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.Now;
}

public interface INotificationService
{
    void ShowNotification(string title, string message, NotificationSeverity severity = NotificationSeverity.Info);
    event EventHandler<Notification> NotificationReceived;
    IEnumerable<Notification> GetRecentNotifications(int count = 10);
    void ClearNotifications();
}



======================================
FILE: Services\IpcService.cs
======================================

using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Mass.Core.Services;

public class IpcService : IIpcService
{
    private const string PipeName = "MassBootServerPipe";
    private const string ServerExecutable = "ProPXEServer.API.exe"; // Adjust based on actual output
    private Process? _serverProcess;

    public async Task<bool> StartServerAsync(CancellationToken ct = default)
    {
        try
        {
            if (_serverProcess != null && !_serverProcess.HasExited)
                return true;

            // Locate the server executable
            // Assuming it's in a relative path or known location
            // For dev: src/ProPXEServer/ProPXEServer.API/bin/Debug/net10.0/ProPXEServer.API.exe
            // For prod: ./ProPXEServer.API.exe
            
            string serverPath = FindServerExecutable();
            if (string.IsNullOrEmpty(serverPath))
                return false;

            var startInfo = new ProcessStartInfo
            {
                FileName = serverPath,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            _serverProcess = Process.Start(startInfo);
            return _serverProcess != null;
        }
        catch
        {
            return false;
        }
    }

    public async Task<bool> StopServerAsync(CancellationToken ct = default)
    {
        try
        {
            if (_serverProcess == null || _serverProcess.HasExited)
                return true;

            _serverProcess.Kill(); // Simple kill for now, graceful shutdown via IPC later
            await _serverProcess.WaitForExitAsync(ct);
            _serverProcess = null;
            return true;
        }
        catch
        {
            return false;
        }
    }

    public async Task<string> GetStatusAsync(CancellationToken ct = default)
    {
        if (_serverProcess == null || _serverProcess.HasExited)
            return "Stopped";

        return "Running";
    }

    private string FindServerExecutable()
    {
        // Simple search logic
        string current = AppDomain.CurrentDomain.BaseDirectory;
        string devPath = Path.GetFullPath(Path.Combine(current, "../../../../src/ProPXEServer/ProPXEServer.API/bin/Debug/net10.0/ProPXEServer.API.exe"));
        
        if (File.Exists(devPath)) return devPath;
        
        // Prod path
        string prodPath = Path.Combine(current, "ProPXEServer.API.exe");
        if (File.Exists(prodPath)) return prodPath;

        return string.Empty;
    }
}



======================================
FILE: Services\IStatusService.cs
======================================

namespace Mass.Core.Services;

public interface IStatusService
{
    IEnumerable<ModuleStatus> GetModuleStatuses();
    SystemStatus GetSystemStatus();
    
    void StartMonitoring();
    void StopMonitoring();
    event EventHandler<SystemStatus> StatusUpdated;
}

public class ModuleStatus
{
    public string Name { get; set; } = string.Empty;
    public string Status { get; set; } = "Ready";
    public string Icon { get; set; } = "";
    public string Color { get; set; } = "#10B981"; // Green
}

public class SystemStatus
{
    public double CpuUsagePercent { get; set; }
    public double MemoryUsageBytes { get; set; }
    public double TotalMemoryBytes { get; set; }
    public TimeSpan Uptime { get; set; }
    public List<DiskInfo> Disks { get; set; } = new();
    public NetworkStatus Network { get; set; } = new();
    
    public string CpuDisplay => $"{CpuUsagePercent:F1}%";
    public string MemoryDisplay => $"{MemoryUsageBytes / 1024 / 1024:F0} MB / {TotalMemoryBytes / 1024 / 1024:F0} MB";
    public string UptimeDisplay => Uptime.ToString(@"dd\.hh\:mm\:ss");
}

public class NetworkStatus
{
    public double BytesSentPerSecond { get; set; }
    public double BytesReceivedPerSecond { get; set; }
    public long TotalBytesSent { get; set; }
    public long TotalBytesReceived { get; set; }
    
    public string UploadSpeedDisplay => FormatBytes(BytesSentPerSecond) + "/s";
    public string DownloadSpeedDisplay => FormatBytes(BytesReceivedPerSecond) + "/s";
    
    private static string FormatBytes(double bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        while (bytes >= 1024 && order < sizes.Length - 1)
        {
            order++;
            bytes /= 1024;
        }
        return $"{bytes:F2} {sizes[order]}";
    }
}

public class DiskInfo
{
    public string Name { get; set; } = string.Empty;
    public string Label { get; set; } = string.Empty;
    public double TotalSpaceBytes { get; set; }
    public double FreeSpaceBytes { get; set; }
    public double UsagePercent => TotalSpaceBytes > 0 ? (1 - (FreeSpaceBytes / TotalSpaceBytes)) * 100 : 0;
}



======================================
FILE: Services\JsonLocalizationService.cs
======================================

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace Mass.Core.Services;

public class JsonLocalizationService : ILocalizationService
{
    private readonly string _localesPath;
    private Dictionary<string, string> _currentStrings = new();
    private CultureInfo _currentCulture = new("en-US");

    public event PropertyChangedEventHandler? PropertyChanged;

    public CultureInfo CurrentCulture
    {
        get => _currentCulture;
        private set
        {
            if (_currentCulture != value)
            {
                _currentCulture = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(CurrentCulture)));
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Item[]"));
            }
        }
    }

    public IEnumerable<CultureInfo> AvailableCultures { get; private set; } = new List<CultureInfo>();

    public string this[string key] => GetString(key);

    public JsonLocalizationService(string localesPath)
    {
        _localesPath = localesPath;
        LoadAvailableCultures();
        LoadLanguage("en-US"); // Default
    }

    public string GetString(string key)
    {
        if (_currentStrings.TryGetValue(key, out var value))
        {
            return value;
        }
        return $"[{key}]";
    }

    public void SetLanguage(string cultureCode)
    {
        LoadLanguage(cultureCode);
    }

    private void LoadAvailableCultures()
    {
        var cultures = new List<CultureInfo>();
        if (Directory.Exists(_localesPath))
        {
            foreach (var file in Directory.GetFiles(_localesPath, "*.json"))
            {
                try
                {
                    var code = Path.GetFileNameWithoutExtension(file);
                    cultures.Add(new CultureInfo(code));
                }
                catch { /* Ignore invalid filenames */ }
            }
        }
        
        if (!cultures.Any(c => c.Name == "en-US"))
        {
            cultures.Add(new CultureInfo("en-US"));
        }

        AvailableCultures = cultures;
    }

    private void LoadLanguage(string cultureCode)
    {
        var filePath = Path.Combine(_localesPath, $"{cultureCode}.json");
        if (File.Exists(filePath))
        {
            try
            {
                var json = File.ReadAllText(filePath);
                var strings = JsonSerializer.Deserialize<Dictionary<string, string>>(json);
                if (strings != null)
                {
                    _currentStrings = strings;
                    CurrentCulture = new CultureInfo(cultureCode);
                    return;
                }
            }
            catch
            {
                // Log error
            }
        }

        // Fallback to empty if not found, or keep previous if failure
        if (_currentStrings.Count == 0)
        {
             _currentStrings = new Dictionary<string, string>();
             CurrentCulture = new CultureInfo(cultureCode);
        }
    }
}



======================================
FILE: Services\NotificationService.cs
======================================

using System.Collections.Concurrent;

namespace Mass.Core.Services;

public class NotificationService : INotificationService
{
    private readonly ConcurrentQueue<Notification> _notifications = new();
    private const int MaxNotifications = 50;

    public event EventHandler<Notification>? NotificationReceived;

    public void ShowNotification(string title, string message, NotificationSeverity severity = NotificationSeverity.Info)
    {
        var notification = new Notification
        {
            Title = title,
            Message = message,
            Severity = severity,
            Timestamp = DateTime.Now
        };

        _notifications.Enqueue(notification);
        
        while (_notifications.Count > MaxNotifications)
        {
            _notifications.TryDequeue(out _);
        }

        NotificationReceived?.Invoke(this, notification);
    }

    public IEnumerable<Notification> GetRecentNotifications(int count = 10)
    {
        return _notifications.Reverse().Take(count);
    }

    public void ClearNotifications()
    {
        _notifications.Clear();
    }
}



======================================
FILE: Services\ResourceAlertService.cs
======================================

namespace Mass.Core.Services;

public class ResourceThresholds
{
    public double CpuWarning { get; set; } = 80.0;
    public double CpuCritical { get; set; } = 95.0;
    public double MemoryWarning { get; set; } = 80.0;
    public double MemoryCritical { get; set; } = 95.0;
    public double DiskWarning { get; set; } = 90.0;
    public double DiskCritical { get; set; } = 95.0;
}

public class ResourceAlertService : IDisposable
{
    private readonly IStatusService _statusService;
    private readonly INotificationService _notificationService;
    private readonly ResourceThresholds _thresholds;
    private readonly HashSet<string> _activeAlerts = new();
    private Timer? _checkTimer;

    public ResourceAlertService(
        IStatusService statusService, 
        INotificationService notificationService,
        ResourceThresholds? thresholds = null)
    {
        _statusService = statusService;
        _notificationService = notificationService;
        _thresholds = thresholds ?? new ResourceThresholds();
    }

    public void Start()
    {
        _checkTimer?.Dispose();
        _checkTimer = new Timer(CheckThresholds, null, 0, 5000);
    }

    public void Stop()
    {
        _checkTimer?.Change(Timeout.Infinite, 0);
    }

    private void CheckThresholds(object? state)
    {
        var status = _statusService.GetSystemStatus();

        CheckCpuThreshold(status.CpuUsagePercent);
        CheckMemoryThreshold(status.MemoryUsageBytes, status.TotalMemoryBytes);
        CheckDiskThresholds(status.Disks);
    }

    private void CheckCpuThreshold(double cpuPercent)
    {
        const string alertKey = "cpu";
        
        if (cpuPercent >= _thresholds.CpuCritical)
        {
            RaiseAlert(alertKey, "Critical CPU Usage", 
                $"CPU usage is at {cpuPercent:F1}%", NotificationSeverity.Error);
        }
        else if (cpuPercent >= _thresholds.CpuWarning)
        {
            RaiseAlert(alertKey, "High CPU Usage", 
                $"CPU usage is at {cpuPercent:F1}%", NotificationSeverity.Warning);
        }
        else
        {
            ClearAlert(alertKey);
        }
    }

    private void CheckMemoryThreshold(double used, double total)
    {
        const string alertKey = "memory";
        var percent = (used / total) * 100;
        
        if (percent >= _thresholds.MemoryCritical)
        {
            RaiseAlert(alertKey, "Critical Memory Usage", 
                $"Memory usage is at {percent:F1}%", NotificationSeverity.Error);
        }
        else if (percent >= _thresholds.MemoryWarning)
        {
            RaiseAlert(alertKey, "High Memory Usage", 
                $"Memory usage is at {percent:F1}%", NotificationSeverity.Warning);
        }
        else
        {
            ClearAlert(alertKey);
        }
    }

    private void CheckDiskThresholds(List<DiskInfo> disks)
    {
        foreach (var disk in disks)
        {
            var alertKey = $"disk_{disk.Name}";
            
            if (disk.UsagePercent >= _thresholds.DiskCritical)
            {
                RaiseAlert(alertKey, $"Critical Disk Space: {disk.Name}", 
                    $"Disk usage is at {disk.UsagePercent:F1}%", NotificationSeverity.Error);
            }
            else if (disk.UsagePercent >= _thresholds.DiskWarning)
            {
                RaiseAlert(alertKey, $"Low Disk Space: {disk.Name}", 
                    $"Disk usage is at {disk.UsagePercent:F1}%", NotificationSeverity.Warning);
            }
            else
            {
                ClearAlert(alertKey);
            }
        }
    }

    private void RaiseAlert(string key, string title, string message, NotificationSeverity severity)
    {
        if (!_activeAlerts.Contains(key))
        {
            _activeAlerts.Add(key);
            _notificationService.ShowNotification(title, message, severity);
        }
    }

    private void ClearAlert(string key)
    {
        _activeAlerts.Remove(key);
    }

    public void Dispose()
    {
        _checkTimer?.Dispose();
    }
}



======================================
FILE: Services\StatusService.cs
======================================

using System.Diagnostics;
using System.Net.NetworkInformation;

namespace Mass.Core.Services;

public class StatusService : IStatusService, IDisposable
{
    private readonly Process _currentProcess;
    private Timer? _monitoringTimer;
    private readonly PerformanceCounter? _cpuCounter;
    private long _previousBytesSent;
    private long _previousBytesReceived;
    private DateTime _previousNetworkCheck = DateTime.Now;
    
    public event EventHandler<SystemStatus>? StatusUpdated;

    public StatusService()
    {
        _currentProcess = Process.GetCurrentProcess();
        
        try
        {
            if (OperatingSystem.IsWindows())
            {
                _cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
                _cpuCounter.NextValue();
            }
            
            InitializeNetworkCounters();
        }
        catch
        {
        }
    }

    public void StartMonitoring()
    {
        _monitoringTimer?.Dispose();
        _monitoringTimer = new Timer(OnMonitoringTick, null, 0, 1000);
    }

    public void StopMonitoring()
    {
        _monitoringTimer?.Change(Timeout.Infinite, 0);
    }

    private void OnMonitoringTick(object? state)
    {
        var status = GetSystemStatus();
        StatusUpdated?.Invoke(this, status);
    }

    public IEnumerable<ModuleStatus> GetModuleStatuses()
    {
        return new[]
        {
            new ModuleStatus { Name = "ProUSB", Icon = "", Status = "Ready", Color = "#10B981" },
            new ModuleStatus { Name = "MassBoot", Icon = "", Status = "Active", Color = "#3B82F6" },
            new ModuleStatus { Name = "Orchestrator", Icon = "", Status = "Idle", Color = "#6B7280" }
        };
    }

    public SystemStatus GetSystemStatus()
    {
        double cpuUsage = 0;
        try
        {
            if (_cpuCounter != null)
            {
                cpuUsage = _cpuCounter.NextValue();
            }
        }
        catch { }

        var disks = new List<DiskInfo>();
        try
        {
            foreach (var drive in DriveInfo.GetDrives().Where(d => d.IsReady && d.DriveType == DriveType.Fixed))
            {
                disks.Add(new DiskInfo
                {
                    Name = drive.Name,
                    Label = drive.VolumeLabel,
                    TotalSpaceBytes = drive.TotalSize,
                    FreeSpaceBytes = drive.TotalFreeSpace
                });
            }
        }
        catch { }

        return new SystemStatus
        {
            CpuUsagePercent = cpuUsage,
            MemoryUsageBytes = _currentProcess.WorkingSet64,
            TotalMemoryBytes = GC.GetGCMemoryInfo().TotalAvailableMemoryBytes,
            Uptime = DateTime.Now - _currentProcess.StartTime,
            Disks = disks,
            Network = GetNetworkStatus()
        };
    }

    private void InitializeNetworkCounters()
    {
        try
        {
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(ni => ni.OperationalStatus == OperationalStatus.Up && 
                            ni.NetworkInterfaceType != NetworkInterfaceType.Loopback);
            
            foreach (var ni in interfaces)
            {
                var stats = ni.GetIPv4Statistics();
                _previousBytesSent += stats.BytesSent;
                _previousBytesReceived += stats.BytesReceived;
            }
        }
        catch { }
    }

    private NetworkStatus GetNetworkStatus()
    {
        var networkStatus = new NetworkStatus();
        
        try
        {
            long currentBytesSent = 0;
            long currentBytesReceived = 0;
            
            var interfaces = NetworkInterface.GetAllNetworkInterfaces()
                .Where(ni => ni.OperationalStatus == OperationalStatus.Up && 
                            ni.NetworkInterfaceType != NetworkInterfaceType.Loopback);
            
            foreach (var ni in interfaces)
            {
                var stats = ni.GetIPv4Statistics();
                currentBytesSent += stats.BytesSent;
                currentBytesReceived += stats.BytesReceived;
            }
            
            var now = DateTime.Now;
            var elapsed = (now - _previousNetworkCheck).TotalSeconds;
            
            if (elapsed > 0)
            {
                networkStatus.BytesSentPerSecond = (currentBytesSent - _previousBytesSent) / elapsed;
                networkStatus.BytesReceivedPerSecond = (currentBytesReceived - _previousBytesReceived) / elapsed;
            }
            
            networkStatus.TotalBytesSent = currentBytesSent;
            networkStatus.TotalBytesReceived = currentBytesReceived;
            
            _previousBytesSent = currentBytesSent;
            _previousBytesReceived = currentBytesReceived;
            _previousNetworkCheck = now;
        }
        catch { }
        
        return networkStatus;
    }

    public void Dispose()
    {
        _monitoringTimer?.Dispose();
        _cpuCounter?.Dispose();
    }
}



======================================
FILE: Telemetry\ITelemetryService.cs
======================================

namespace Mass.Core.Telemetry;

public interface ITelemetryService
{
    bool IsEnabled { get; }
    void TrackEvent(string eventName, IDictionary<string, string>? properties = null);
    void TrackException(Exception exception, IDictionary<string, string>? properties = null);
    void TrackPageView(string pageName);
    Task FlushAsync();
}



======================================
FILE: Telemetry\LocalTelemetryService.cs
======================================

using System.Collections.Concurrent;
using System.Text.Json;
using Mass.Core.Abstractions;
using Mass.Core.Configuration;

namespace Mass.Core.Telemetry;

public class LocalTelemetryService : ITelemetryService
{
    private readonly IConfigurationService _configService;
    private readonly ConcurrentQueue<TelemetryEvent> _eventBuffer = new();
    private readonly string _logDirectory;
    private readonly Timer _flushTimer;
    private const int FlushIntervalMs = 60000; // 1 minute

    public bool IsEnabled => _configService.Get<AppSettings>("AppSettings", new AppSettings())?.Telemetry?.Enabled ?? false;

    public LocalTelemetryService(IConfigurationService configService)
    {
        _configService = configService;
        _logDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite", "logs", "telemetry");
        Directory.CreateDirectory(_logDirectory);
        _flushTimer = new Timer(async _ => await FlushAsync(), null, FlushIntervalMs, FlushIntervalMs);
    }

    public void TrackEvent(string eventName, IDictionary<string, string>? properties = null)
    {
        if (!IsEnabled) return;

        var telemetryEvent = new TelemetryEvent
        {
            Timestamp = DateTime.UtcNow,
            Type = "Event",
            Name = eventName,
            Properties = SanitizeProperties(properties)
        };

        _eventBuffer.Enqueue(telemetryEvent);
    }

    public void TrackException(Exception exception, IDictionary<string, string>? properties = null)
    {
        if (!IsEnabled) return;

        var props = properties ?? new Dictionary<string, string>();
        props["Message"] = exception.Message;
        props["StackTrace"] = exception.StackTrace ?? string.Empty;
        props["Source"] = exception.Source ?? string.Empty;

        var telemetryEvent = new TelemetryEvent
        {
            Timestamp = DateTime.UtcNow,
            Type = "Exception",
            Name = exception.GetType().Name,
            Properties = SanitizeProperties(props)
        };

        _eventBuffer.Enqueue(telemetryEvent);
    }

    public void TrackPageView(string pageName)
    {
        if (!IsEnabled) return;

        var telemetryEvent = new TelemetryEvent
        {
            Timestamp = DateTime.UtcNow,
            Type = "PageView",
            Name = pageName
        };

        _eventBuffer.Enqueue(telemetryEvent);
    }

    public async Task FlushAsync()
    {
        if (_eventBuffer.IsEmpty) return;

        var eventsToWrite = new List<TelemetryEvent>();
        while (_eventBuffer.TryDequeue(out var evt))
        {
            eventsToWrite.Add(evt);
        }

        if (eventsToWrite.Count == 0) return;

        var fileName = $"telemetry_{DateTime.UtcNow:yyyy-MM-dd}.json";
        var filePath = Path.Combine(_logDirectory, fileName);

        try
        {
            var json = JsonSerializer.Serialize(eventsToWrite, new JsonSerializerOptions { WriteIndented = true });
            
            // Append to file (reading existing first if needed, but for simplicity just appending lines or writing array)
            // Since JSON array is tricky to append to, we'll write line-delimited JSON (NDJSON) or just append to a list if we read it first.
            // For robustness and simplicity in local logging, let's use NDJSON (Newlines Delimited JSON) which is easier to append.
            
            var lines = eventsToWrite.Select(e => JsonSerializer.Serialize(e));
            await File.AppendAllLinesAsync(filePath, lines);
        }
        catch
        {
            // Fail silently for telemetry
        }
    }

    private Dictionary<string, string>? SanitizeProperties(IDictionary<string, string>? properties)
    {
        if (properties == null) return null;

        var sanitized = new Dictionary<string, string>();
        var userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        foreach (var kvp in properties)
        {
            var value = kvp.Value;
            if (!string.IsNullOrEmpty(value) && value.Contains(userProfile, StringComparison.OrdinalIgnoreCase))
            {
                value = value.Replace(userProfile, "%USERPROFILE%", StringComparison.OrdinalIgnoreCase);
            }
            sanitized[kvp.Key] = value;
        }

        return sanitized;
    }

    private class TelemetryEvent
    {
        public DateTime Timestamp { get; set; }
        public string Type { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
        public Dictionary<string, string>? Properties { get; set; }
    }
}



======================================
FILE: UI\CommandPaletteService.cs
======================================

namespace Mass.Core.UI;

public class CommandPaletteService : ICommandPaletteService
{
    private readonly Dictionary<string, CommandPaletteItem> _commands = new();
    private readonly Queue<string> _recentCommands = new();
    private const int MaxRecentCommands = 10;

    public void RegisterCommand(string id, string title, string description, string category, Action action, string icon = "", string shortcut = "")
    {
        _commands[id] = new CommandPaletteItem
        {
            Id = id,
            Title = title,
            Description = description,
            Category = category,
            Action = action,
            Icon = icon,
            Shortcut = shortcut
        };
    }

    public void UnregisterCommand(string id)
    {
        _commands.Remove(id);
    }

    public IEnumerable<CommandPaletteItem> SearchCommands(string query)
    {
        if (string.IsNullOrWhiteSpace(query))
            return GetAllCommands();

        var lowerQuery = query.ToLowerInvariant();
        
        return _commands.Values
            .Where(cmd => 
                cmd.Title.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ||
                cmd.Description.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ||
                cmd.Category.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase))
            .OrderByDescending(cmd => 
                cmd.Title.StartsWith(lowerQuery, StringComparison.OrdinalIgnoreCase) ? 2 :
                cmd.Title.Contains(lowerQuery, StringComparison.OrdinalIgnoreCase) ? 1 : 0);
    }

    public IEnumerable<CommandPaletteItem> GetAllCommands()
    {
        return _commands.Values.OrderBy(c => c.Category).ThenBy(c => c.Title);
    }

    public void ExecuteCommand(string id)
    {
        if (_commands.TryGetValue(id, out var command))
        {
            command.Action?.Invoke();
            AddToRecentCommands(id);
        }
    }

    public IEnumerable<string> GetRecentCommands(int count = 5)
    {
        return _recentCommands.Reverse().Take(count);
    }

    public void AddToRecentCommands(string commandId)
    {
        if (_recentCommands.Contains(commandId))
        {
            var temp = _recentCommands.Where(c => c != commandId).ToList();
            _recentCommands.Clear();
            foreach (var cmd in temp)
                _recentCommands.Enqueue(cmd);
        }

        _recentCommands.Enqueue(commandId);
        
        while (_recentCommands.Count > MaxRecentCommands)
        {
            _recentCommands.Dequeue();
        }
    }
}



======================================
FILE: UI\ICommandPaletteService.cs
======================================

namespace Mass.Core.UI;

public class CommandPaletteItem
{
    public string Id { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public string Icon { get; set; } = string.Empty;
    public string Shortcut { get; set; } = string.Empty;
    public Action? Action { get; set; }
}

public interface ICommandPaletteService
{
    void RegisterCommand(string id, string title, string description, string category, Action action, string icon = "", string shortcut = "");
    void UnregisterCommand(string id);
    IEnumerable<CommandPaletteItem> SearchCommands(string query);
    IEnumerable<CommandPaletteItem> GetAllCommands();
    void ExecuteCommand(string id);
    IEnumerable<string> GetRecentCommands(int count = 5);
    void AddToRecentCommands(string commandId);
}



======================================
FILE: UI\IOperationsConsoleService.cs
======================================

namespace Mass.Core.UI;

public class OperationLogEntry
{
    public DateTime Timestamp { get; set; } = DateTime.Now;
    public string Operation { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public OperationLogLevel Level { get; set; }
    public string Details { get; set; } = string.Empty;
}

public enum OperationLogLevel
{
    Info,
    Success,
    Warning,
    Error
}

public interface IOperationsConsoleService
{
    void LogOperation(string operation, string message, OperationLogLevel level = OperationLogLevel.Info);
    void LogSuccess(string operation, string message);
    void LogWarning(string operation, string message);
    void LogError(string operation, string message, Exception? exception = null);
    IEnumerable<OperationLogEntry> GetRecentOperations(int count = 100);
    event EventHandler<OperationLogEntry> OperationLogged;
    void Clear();
}



======================================
FILE: UI\OperationsConsoleService.cs
======================================

using System.Collections.Concurrent;

namespace Mass.Core.UI;

public class OperationsConsoleService : IOperationsConsoleService
{
    private readonly ConcurrentQueue<OperationLogEntry> _operations = new();
    private const int MaxOperations = 500;

    public event EventHandler<OperationLogEntry>? OperationLogged;

    public void LogOperation(string operation, string message, OperationLogLevel level = OperationLogLevel.Info)
    {
        var entry = new OperationLogEntry
        {
            Timestamp = DateTime.Now,
            Operation = operation,
            Message = message,
            Level = level,
            Status = level.ToString()
        };

        _operations.Enqueue(entry);
        
        while (_operations.Count > MaxOperations)
        {
            _operations.TryDequeue(out _);
        }

        OperationLogged?.Invoke(this, entry);
    }

    public void LogSuccess(string operation, string message)
    {
        LogOperation(operation, message, OperationLogLevel.Success);
    }

    public void LogWarning(string operation, string message)
    {
        LogOperation(operation, message, OperationLogLevel.Warning);
    }

    public void LogError(string operation, string message, Exception? exception = null)
    {
        var details = exception?.ToString() ?? string.Empty;
        var entry = new OperationLogEntry
        {
            Timestamp = DateTime.Now,
            Operation = operation,
            Message = message,
            Level = OperationLogLevel.Error,
            Status = "Error",
            Details = details
        };

        _operations.Enqueue(entry);
        
        while (_operations.Count > MaxOperations)
        {
            _operations.TryDequeue(out _);
        }

        OperationLogged?.Invoke(this, entry);
    }

    public IEnumerable<OperationLogEntry> GetRecentOperations(int count = 100)
    {
        return _operations.Reverse().Take(count);
    }

    public void Clear()
    {
        _operations.Clear();
    }
}



======================================
FILE: UI\ViewModelBase.cs
======================================

using CommunityToolkit.Mvvm.ComponentModel;

namespace Mass.Core.UI;

public abstract partial class ViewModelBase : ObservableObject
{
    [ObservableProperty]
    private bool _isBusy;

    [ObservableProperty]
    private string _title = string.Empty;
}



======================================
FILE: Updates\IRollbackService.cs
======================================

namespace Mass.Core.Updates;

public interface IRollbackService
{
    Task<bool> BackupCurrentVersionAsync();
    Task<bool> RestorePreviousVersionAsync();
    IEnumerable<string> GetAvailableBackups();
    Task CleanupOldBackupsAsync(int keepCount = 3);
    bool HasBackup();
}



======================================
FILE: Updates\IUpdateService.cs
======================================

namespace Mass.Core.Updates;

public interface IUpdateService
{
    string CurrentVersion { get; }
    Task<UpdateCheckResult> CheckForUpdatesAsync();
    Task<string> DownloadUpdateAsync(UpdateInfo update, IProgress<double>? progress = null);
    Task<bool> VerifyUpdateAsync(string filePath, string expectedHash);
    Task ScheduleInstallAsync(string updateFilePath);
    event EventHandler<UpdateStatus> StatusChanged;
}



======================================
FILE: Updates\RollbackService.cs
======================================

using System.IO.Compression;

namespace Mass.Core.Updates;

public class RollbackService : IRollbackService
{
    private readonly string _backupDirectory;
    private readonly string _applicationDirectory;

    public RollbackService()
    {
        var appData = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MassSuite");
        _backupDirectory = Path.Combine(appData, "backups");
        _applicationDirectory = AppDomain.CurrentDomain.BaseDirectory;
        Directory.CreateDirectory(_backupDirectory);
    }

    public async Task<bool> BackupCurrentVersionAsync()
    {
        try
        {
            var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var backupFileName = $"backup_{timestamp}.zip";
            var backupPath = Path.Combine(_backupDirectory, backupFileName);

            await Task.Run(() =>
            {
                ZipFile.CreateFromDirectory(_applicationDirectory, backupPath, CompressionLevel.Fastest, false);
            });

            await CleanupOldBackupsAsync();
            return true;
        }
        catch
        {
            return false;
        }
    }

    public async Task<bool> RestorePreviousVersionAsync()
    {
        try
        {
            var latestBackup = GetAvailableBackups().OrderByDescending(b => b).FirstOrDefault();
            if (string.IsNullOrEmpty(latestBackup))
                return false;

            var backupPath = Path.Combine(_backupDirectory, latestBackup);

            await Task.Run(() =>
            {
                var tempExtractPath = Path.Combine(Path.GetTempPath(), "MassSuite_Restore");
                if (Directory.Exists(tempExtractPath))
                    Directory.Delete(tempExtractPath, true);

                ZipFile.ExtractToDirectory(backupPath, tempExtractPath);

                foreach (var file in Directory.GetFiles(tempExtractPath, "*", SearchOption.AllDirectories))
                {
                    var relativePath = Path.GetRelativePath(tempExtractPath, file);
                    var targetPath = Path.Combine(_applicationDirectory, relativePath);
                    
                    Directory.CreateDirectory(Path.GetDirectoryName(targetPath)!);
                    File.Copy(file, targetPath, true);
                }

                Directory.Delete(tempExtractPath, true);
            });

            return true;
        }
        catch
        {
            return false;
        }
    }

    public IEnumerable<string> GetAvailableBackups()
    {
        try
        {
            return Directory.GetFiles(_backupDirectory, "backup_*.zip")
                .Select(Path.GetFileName)
                .Where(f => f != null)
                .Cast<string>();
        }
        catch
        {
            return Enumerable.Empty<string>();
        }
    }

    public async Task CleanupOldBackupsAsync(int keepCount = 3)
    {
        await Task.Run(() =>
        {
            try
            {
                var backups = Directory.GetFiles(_backupDirectory, "backup_*.zip")
                    .Select(f => new FileInfo(f))
                    .OrderByDescending(f => f.CreationTime)
                    .Skip(keepCount);

                foreach (var backup in backups)
                {
                    backup.Delete();
                }
            }
            catch { }
        });
    }

    public bool HasBackup()
    {
        return GetAvailableBackups().Any();
    }
}



======================================
FILE: Updates\UpdateInfo.cs
======================================

namespace Mass.Core.Updates;

public class UpdateInfo
{
    public string Version { get; set; } = string.Empty;
    public string ReleaseNotes { get; set; } = string.Empty;
    public string DownloadUrl { get; set; } = string.Empty;
    public string Sha256Hash { get; set; } = string.Empty;
    public DateTime PublishedAt { get; set; }
    public long SizeBytes { get; set; }
    public bool IsPrerelease { get; set; }
}

public class UpdateCheckResult
{
    public bool UpdateAvailable { get; set; }
    public UpdateInfo? LatestVersion { get; set; }
    public string CurrentVersion { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
}

public enum UpdateStatus
{
    CheckingForUpdates,
    UpdateAvailable,
    Downloading,
    ReadyToInstall,
    Installing,
    UpToDate,
    Error
}



======================================
FILE: Updates\UpdateService.cs
======================================

using System.Reflection;
using System.Security.Cryptography;
using System.Text.Json;

namespace Mass.Core.Updates;

public class UpdateService : IUpdateService
{
    private const string GitHubApiUrl = "https://api.github.com/repos/YourOrg/ProUSBMediaSuite/releases/latest";
    private readonly HttpClient _httpClient;

    public string CurrentVersion { get; }
    public event EventHandler<UpdateStatus>? StatusChanged;

    public UpdateService()
    {
        CurrentVersion = Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";
        _httpClient = new HttpClient();
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "ProUSBMediaSuite");
    }

    public async Task<UpdateCheckResult> CheckForUpdatesAsync()
    {
        StatusChanged?.Invoke(this, UpdateStatus.CheckingForUpdates);

        try
        {
            var response = await _httpClient.GetStringAsync(GitHubApiUrl);
            var release = JsonSerializer.Deserialize<GitHubRelease>(response);

            if (release == null)
            {
                return new UpdateCheckResult
                {
                    UpdateAvailable = false,
                    CurrentVersion = CurrentVersion,
                    Message = "Unable to check for updates"
                };
            }

            var latestVersion = release.TagName.TrimStart('v');
            var isNewer = CompareVersions(latestVersion, CurrentVersion) > 0;

            if (isNewer)
            {
                var asset = release.Assets.FirstOrDefault(a => a.Name.EndsWith(".zip"));
                if (asset != null)
                {
                    StatusChanged?.Invoke(this, UpdateStatus.UpdateAvailable);
                    return new UpdateCheckResult
                    {
                        UpdateAvailable = true,
                        CurrentVersion = CurrentVersion,
                        LatestVersion = new UpdateInfo
                        {
                            Version = latestVersion,
                            ReleaseNotes = release.Body,
                            DownloadUrl = asset.BrowserDownloadUrl,
                            PublishedAt = release.PublishedAt,
                            SizeBytes = asset.Size,
                            IsPrerelease = release.Prerelease
                        },
                        Message = $"Version {latestVersion} is available"
                    };
                }
            }

            StatusChanged?.Invoke(this, UpdateStatus.UpToDate);
            return new UpdateCheckResult
            {
                UpdateAvailable = false,
                CurrentVersion = CurrentVersion,
                Message = "You are running the latest version"
            };
        }
        catch (Exception ex)
        {
            StatusChanged?.Invoke(this, UpdateStatus.Error);
            return new UpdateCheckResult
            {
                UpdateAvailable = false,
                CurrentVersion = CurrentVersion,
                Message = $"Error checking for updates: {ex.Message}"
            };
        }
    }

    public async Task<string> DownloadUpdateAsync(UpdateInfo update, IProgress<double>? progress = null)
    {
        StatusChanged?.Invoke(this, UpdateStatus.Downloading);

        var tempPath = Path.Combine(Path.GetTempPath(), "MassSuite");
        Directory.CreateDirectory(tempPath);

        var fileName = $"MassSuite-{update.Version}.zip";
        var filePath = Path.Combine(tempPath, fileName);

        try
        {
            using var response = await _httpClient.GetAsync(update.DownloadUrl, HttpCompletionOption.ResponseHeadersRead);
            response.EnsureSuccessStatusCode();

            var totalBytes = response.Content.Headers.ContentLength ?? 0;
            var downloadedBytes = 0L;

            using var contentStream = await response.Content.ReadAsStreamAsync();
            using var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None, 8192, true);

            var buffer = new byte[8192];
            int bytesRead;

            while ((bytesRead = await contentStream.ReadAsync(buffer)) > 0)
            {
                await fileStream.WriteAsync(buffer.AsMemory(0, bytesRead));
                downloadedBytes += bytesRead;

                if (totalBytes > 0)
                {
                    progress?.Report((double)downloadedBytes / totalBytes * 100);
                }
            }

            StatusChanged?.Invoke(this, UpdateStatus.ReadyToInstall);
            return filePath;
        }
        catch
        {
            StatusChanged?.Invoke(this, UpdateStatus.Error);
            throw;
        }
    }

    public Task<bool> VerifyUpdateAsync(string filePath, string expectedHash)
    {
        if (string.IsNullOrEmpty(expectedHash))
            return Task.FromResult(true);

        try
        {
            using var sha256 = SHA256.Create();
            using var fileStream = File.OpenRead(filePath);
            var hash = BitConverter.ToString(sha256.ComputeHash(fileStream)).Replace("-", "");
            return Task.FromResult(hash.Equals(expectedHash, StringComparison.OrdinalIgnoreCase));
        }
        catch
        {
            return Task.FromResult(false);
        }
    }

    public Task ScheduleInstallAsync(string updateFilePath)
    {
        var updateMarkerPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, ".update_pending");
        File.WriteAllText(updateMarkerPath, updateFilePath);
        return Task.CompletedTask;
    }

    private static int CompareVersions(string version1, string version2)
    {
        var v1Parts = version1.Split('.').Select(int.Parse).ToArray();
        var v2Parts = version2.Split('.').Select(int.Parse).ToArray();

        for (int i = 0; i < Math.Max(v1Parts.Length, v2Parts.Length); i++)
        {
            var v1 = i < v1Parts.Length ? v1Parts[i] : 0;
            var v2 = i < v2Parts.Length ? v2Parts[i] : 0;

            if (v1 > v2) return 1;
            if (v1 < v2) return -1;
        }

        return 0;
    }

    private class GitHubRelease
    {
        public string TagName { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
        public string Body { get; set; } = string.Empty;
        public bool Prerelease { get; set; }
        public DateTime PublishedAt { get; set; }
        public List<GitHubAsset> Assets { get; set; } = new();
    }

    private class GitHubAsset
    {
        public string Name { get; set; } = string.Empty;
        public string BrowserDownloadUrl { get; set; } = string.Empty;
        public long Size { get; set; }
    }
}



======================================
FILE: Mass.Core.csproj
======================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <LangVersion>14</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="10.0.0" />
    <PackageReference Include="NLua" Version="1.7.6" />
    <PackageReference Include="System.Diagnostics.PerformanceCounter" Version="10.0.0" />
    <PackageReference Include="YamlDotNet" Version="16.3.0" />
  </ItemGroup>

</Project>




================================================================================
END OF MASS.CORE DOCUMENTATION
================================================================================

